<!DOCTYPE html>
<html lang="en">




<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>Search - I'M VALENTI</title>
  

  
  
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>

<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script
src="https://code.jquery.com/jquery-3.3.1.min.js"
integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


<link rel="stylesheet" href="/.css">

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  

  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class='header'>
	<div class="header-title">
		
		<div class='header-logo'>
			<a href='/'>
				<img src='/images/theme-icon.svg' />
			</a>
		</div>
		<div class='header-text'>
			<h1>
				<a href="/">I'M VALENTI</a>
			</h1>
			<subtitle>
				
			</subtitle>
		</div>
		
	</div>
	<div id='header-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='Archives'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='Search'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
		
	</div>
	</div>
</nav>

	</div>
</header>

 




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>
<div class='search-container'>
	<input type="text" id='search-form'>

	<ul class="cat-list">
		
	</ul>

	<div class="archive-cards">
			<div class='Card-archive' style='display:none'>
				<div class="Card-body">
					<h3 class='Card-title'>
						<a>
						</a>
					</h3>
					<div class="Card-meta">
						<ul>
							<li><i class='fa fa-calendar'></i> <span class='Card-date'></span></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
</div>

<script src="/libs/fuse.js/dist/fuse.min.js"></script>
<script>
	var options = {
		shouldSort: true,
		threshold: 0.4,
		tokenize: true,
		location: 0,
		distance: 100,
		maxPatternLength: 32,
		minMatchCharLength: 2,
		keys: [
			"title",
			"author",
			"tags"
		]
	};
	var s = '[{"title":"macOS 系统 nginx + rtmp 流媒体传输实践","date":"2018-11-24T05:18:11.000Z","content":"流媒体传输是“直播”中至关重要的环节，在网络传输媒体流的时候有着不同的流媒体传输协议。\n做了一些小调查，在整个“直播”产品构建的过程中，应用最广的两个流媒体传输协议就是 RTMP 和 HLS 两个协议，其中 RTMP 在国内直播发展的长河中扮演着极其重要的角色，各个平台与 RTMP 的“结合”已变得很成熟。\n两种不同的流媒体传输协议\nRTMP\nRTMP (Real Time Messaging Protocol) ：实时消息传输协议，属应用层协议，基于传输层 TCP 协议长链接来进行传输，有 N 多变种，最早由 Macromedia 公司开发，而后 Macromedia 被 Adobe 公司收购。\nRTMP 的主要特性\n\n市场广阔，基本所有的编码器都支持 RTMP；\n延迟低，RTMP 的实时性在 1～3 秒左右，即使经过 CDN (Content Delivery Network 内容分发网络)多层分发也能保证实时性在 3 秒左右，此特性已经完全满足现在的直播产业需求；\n稳定性、可靠性高，基于 TCP 保证媒体流在传输的过程中不会丢失，但这也是缺点，在网络状态不好的时候，服务器会等待数据，这个过程会出现延迟，等包接受完整再将完整的包推给 Client 端；\nHTML5 播放需要插件，并且跨平台较差\n\nRTMP 原理\nRTMP 通过握手的方式建立 RTMP Connection，\n若 Client 端要按序发送 C0、C1、C2，Server 端按序发送 S0、S1、S2，大致过程如下图：\n\n为保证数据的有效性，无论是 Client 端还是 Server 端都会等待一次 Chunk 接收完毕再进行下一次通信。\n\nChunk 是 RTMP 在进行数据流传输过程中的最小单位，每个 Chunk 由 Message 拆分，当然也可能每个独立的 Message 作为 Chunk 进行传输；\nMessage 是满足 RTMP 并且经过「格式化」的数据，Message 有着自己的“数据结构”，标识每个 Message 的字段为 Message ID，该字段是拆分成 Chunk 和还原 Chunk 的凭借。\n\nHLS\nHLS (HTTP Live Streaming)：是 Apple 公司基于 HTTP 实现的流媒体传输协议。\nHLS 的主要特性\n\n对于 Apple 自家平台的硬件设备上最大化支持，不用自行开发特有播放器，在 Android 的设备上支持表现略差；\nHLS 会将视频源分成索引文件和视频切片进行传输，所以可以实现平滑的切换码率，但这也是 HLS 一个致命的缺点，这种机制会导致 HLS 的实时性很差，延迟可达到数十秒；\n基于 HTTP ，不存在防火墙和代理的问题，但需要和 Server 端不断进行连接通信；\nHTML5 可以直接播放直播链接，不许任何独立的 Application支持。\n\nHLS 主要原理\nHLS 传输内容包括：m3u8 索引文件以及 ts 视频切片。\n无论是直播还是点播，HLS 协议都将视频源按策略分割成一个索引文件和若干 ts 视频切片，由索引文件管理视频切片，Server 则不断的将这些最视频切片推给 Client 端，所以对于直播而言，Client 会不断接受从 Server 端推过来的视频切片，以“点播”的方式达到直播的效果，但由于切片的过程会造成高延迟，所以在国内的直播产业中并不被看好，即使是将 ts 文件的切片设置最小，表现也仍旧不如 RTMP。\nRTMP Vs. HLS\n通过上面的介绍，对于视频采集 -&gt; 处理编码 -&gt; 推流分发 -&gt; Client 端播放整个过程中 RTMP 和 HLS 的工作内容大致如下：\n\n\n与此同时，RTMP 既能推流也能拉流，而 HLS 只能拉流。\n所以根据各自的特点，RTMP 更适用于实时性、互动性较高的直播，HLS 更适合 HTTP 点播。\n本地流媒体传输实践\n准备\na. 安装 HomeBrew，终端键入：\nruby -e &quot;$(curl -fsSL https:raw.githubusercontent.comHomebrewinstallmasterinstall)&quot;\n\n升级 Homebrew：brew update\n\nb. 推流搭建本地服务器需 nginx，终端键入：brew tap denjinginx\n\n使用 brew tap homebrewnginx 会报 Error: homebrewnginx was deprecated. This tap is now empty as all its formulae were migrated.\n\nc. 安装 rtmp 模块，终端键入：\nbrew install nginx-full --with-rtmp-module\nd. 此时，nginx 和 rtmp 模块都已安装完成，终端键入：nginx (权限问题键入 sudo nginx)，启动 nginx 服务，浏览器键入 http:localhost:8080 出现 Welcome to nginx! 欢迎语表示安装成功。\n\n重启 nginx 服务命令：nginx -s reload\n停止 nginx 服务命令：nginx -s stop\n有序退出 nginx 服务命令：nginx -s quit\n\ne. 配置 nginx.conf (HLS + RTMP)\n\nnginx.conf 路径为：usrlocaletcnginxnginx.conf\n\n文本打开该文件在 http 作用域内键入：\n123456789location hls &#123;        #Serve HLS config        types &#123;            applicationvnd.apple.mpegurl    m3u8;            videomp2t ts;        &#125;        root usrlocalvarwww;        add_header Cache-Control    no-cache;    &#125;\n在最后键入：\n123456789101112131415rtmp &#123;\t    server &#123;\t        listen 1935;\t        application rtmplive &#123;\t            live on;\t            max_connections 1024;\t        &#125;\t        application hls&#123;\t            live on;\t            hls on;\t            hls_path usrlocalvarwwwhls;\t            hls_fragment 1s;\t        &#125;\t    &#125;\t&#125;\n\nRTMP 默认端口 1935，rtmp 配置信息不属于任何作用域，写在任何作用域里都会报错 nginx: [emerg] &quot;rtmp&quot; directive is not allowed here in etcnginxnginx.conf:起始行数\n\n配置完毕重启 nginx 服务。\nf. 安装 ffmepg 工具，终端键入：\nbrew install ffmpeg\ng. 安装支持 HLS 和 RTMP 的播放器，VLC 和 mpv 都可，在此用的是 mpv。\n实践本地推流至 nginx\n一切都准备就绪后，即可实践推流服务，终端键入：\nffmpeg -re -i 目标视频.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp:localhost:1935xxxx\n推流命令具体参数：\n\n\n\n参数\n说明\n\n\n\n\n-vcodec libx264\n视频的编码器为 H.264\n\n\nvprofile baseline\n设置音视频编码器的类\n\n\n-acodec aac\n指定声音的编码器为AAC\n\n\n-ar 44100\n音频编解码器的采样率，单位为赫兹\n\n\n-ac 1\n设置音频编解码器的声道数目\n\n\n-f flv\n强制设定输入和输出文件格式为 flv 格式\n\n\n-s 1280x720\n分辨率\n\n\n\n推送过程会在终端显示如下：\n\n推送完毕如下：\n\nRTMP 拉流\n推流至 RTMP 服务器生成地址： rtmp:localhost:1935xxxx\n此时在 mpv 工具栏 File - Open URL - 键入 rtmp:localhost:1935rtmplivexx\n播放即可播放：\n\nHLS 拉流\n推流至 HLS 服务器生成地址：\nhttp:localhost:8080hlsxx.m3u8\n在浏览器或者 mpv 中播放表现如下：\n\n\n实践远程推流\n手头刚好有个科学上网买的 VPS 正好可以当作远程服务器使用，新加坡节点，但应该也是绕到美国的线路，所以可想而知，播放过程异常的艰辛，十几秒播放一帧已经算是给面子了，但好在已经有成果。\n我的服务器是 CentOS 系统，可能安装模块的命令和 Ubuntu 系统有细小的差别。\n在此连接 VPS 的工具选择的是 ShellCraft，macOS 自带的终端工具也可以连接，可视化 CentOS 服务器的客户端为 FileZilla，添加 VPS 站点步骤在本文最后。\n准备\na. 安装 git，CentOS 系统下安装 Git 的命令为：\nyum install git\nb. clone srs，键入：\ngit clone srs\n\nsrs 的作者将它定义为直播服务器集群，更多的信息，请点 srs Github 主页。\n\n若 clone 过程中出现 Please make sure you have the correct access rights and the repository exists. 说明，SSH Key 出现了问题导致无法正常 git 操作，解决如下依次键入：\n\ngit config --global user.name &quot;yourname&quot;\ngit config --global user.email &quot;your@email.com&quot;\nssh-keygen -t rsa -C &quot;your@email.com&quot;\nvi root.sshid_rsa.pub\n将该文件的一大串信息复制并添加到 Github 个人设置里新建的 SSH Key 中。\n\nc. cd 到 srs 目录，依次键入：\ngit checkout 2.0release\ngit pull\ncd trunk\nd. 配置远程服务器，该过程极其漫长，键入：\n.configure --disable-all --with-ssl --with-nginx --with-hls --with-http-callback --with-http-server --with-http-api --with-ffmpeg --with-transcode --with-librtmp --with-dvr &amp;&amp; make\n出现下图所示表示配置环境完成：\n\ne. 执行配置，键入\n.objssrs -c confsrs.conf\n\n实践远程推流与拉流\n推流拉流过程和本地推流命令一样，只不过服务器地址的 localhost:接口 要换成服务器地址，倘若出现如下错误信息则说明需要关闭 CentOS 的防火墙：\n\n\n错误信息：\n[tcp @ 0x7fd255c02b80] Connection to tcp:207.148.66.232:1935 failed: Connection refused\n[rtmp @ 0x7fd255d0b100] Cannot open connection tcp:207.148.66.232:1935\nrtmp:207.148.66.232livedemo: Connection refused\n\n关闭防火墙的命令为：systemctl stop firewalld.service。\nFileZilla 添加站点\nFile -&gt; Site Manager 弹出如下界面：\n\nNew Site -&gt; General -&gt; Protocol 选择如图所示的 SFTP，Logon Type 为 Normal，Host、User 以及 Password 自行填写，Connect。\n界面如下：\n\n👏done!🎉\n","tags":["rtmp","hls","推流","拉流"],"path":"2018/11/24/2018-11-24/","external_link":""},{"title":"HTTP 的原理和工作机制","date":"2019-01-19T18:31:52.000Z","content":"HTTP 是什么？\nHyper Text Transfer Protocol 超文本传输协议，是一种 Client 和 Server 之间请求和应答的标准，目的是更高效的进行网络传输。\nHTTP 工作方式\n用户最直观的感受就是浏览器地址栏键人地址-&gt;回车-&gt;看到浏览器呈现的网页，这个过程简单的流程就是：\n浏览器发送请求到服务器，服务器响应请求，浏览器通过渲染引擎渲染网页结果，渲染引擎也就是浏览器的内核。\n\n示例地址：https:twitter.comshaddeen_followers\n\nshaddeen，是小众音乐播放器 Loud 和 SmartPlayer 的作者。\n\n所以在这个从按下回车到直观看到界面的过程就简单的概括为 3 步：\n\n请求\n响应\n渲染\n\n在请求的过程中，浏览器地址栏的 URL 转化成 HTTP 报文进行发送，一个 URL 大致分为三个部分：\nhttpshttp: 协议类型、twitter.com 服务器地址和shaddeen_followers 路径(path)。\n请求发送的形式就变成：\n12GET shaddeen_followers HTTP1.1Host: twitter.com\n在这个过程中，两个极其重要的角色也就出现了：Request 和 Response。\nRequest 报文格式\n简易的 Request 报文格式如下：\n12GET shaddeen_followers HTTP1.1Host: twitter.com\nGET shaddeen_followers HTTP1.1为一个请求行，分三个部分：\n\nGET 为 请求 method；\nshaddeen_followers 为 path，负责定位；\nHTTP1.1 为 HTTP Version，现在绝大多数的浏览器的网页显示 HTTP 版本都是 1.1。\n\nHost: twitter.com 为请求 Headers，可为多行**（包括更多的内容如 Content-Type: textplain Content-Length: 240）**。\n另，请求可以加入 Body，可以加入实际的内容，该内容是服务器需要处理的。Body 和请求行中的 path 都是和服务器对接并需要服务器处理的，但是各自角色的定位并不一样。\nResponse 报文格式\nResponse 的报文同样也有 Headers 和 Body，相比 Request 无请求行，多了一个状态行，例：\n12状态行⬇️HTTP1.1 200 OK\n123456Headers⬇️content-type: applicationjson; charset=utf-8cache-control: public, max-age=60, s-maxage=60vary: Accept, Accept-Encodingetag: W&quot;02fjsdarwr080823f&quot;content-encoding: gzip\n123456789Body⬇️[    name: &quot;shaddeen_&quot;,    id: &quot;2342242&quot;,    follow_list: [        ...    ]    ...]\nHTTP1.1 200 OK 亦分为三个部分：\n\nHTTP1.1 HTTP 版本；\n200 status code 状态码；\nOK status message 状态信息。\n\n这三部分的组合可以简单地描述一次请求。\nRequest Method\n\nGET 获取资源，无 body，简单的来说就是从网上取东西；\nPOST 增加或修改资源，有 body，要把修改的内容放进 body 里给服务器进行处理；\nPUT 修改资源， 有 body，它和 GET 有个共同的特点就是**幂等（一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同，在这里指多次操作对于服务器没有影响）**的；\nDELETE 删除资源，无 body，同样具有幂等性；\nHEAD 几乎和 GET 是一样的，区别在于服务器返回内容的时候不会返回 body，当做下载功能的时候通常需要预先知道该文件有多大或更多的信息，此时 HEAD 通过请求会得到这些信息，然后再进行一步处理。\n\nStatus Code\n作用：对结果作出类型化描述（如「成功」、「未找到」）。\n通常规范化的状态码有 5 类，分类是为了方便调试：\n\n1xx: 临时性消息，通常为 100 和 101。100，表示初始的请求已经接受，客户端可以接着进行下面的请求，如上传一个大文件，在试探性请求服务器的过程中，会把一些描述信息放进 Header 中与服务器沟通试探服务器是否接受，如服务器返回 100 则客户端可以进行下面的操作。101 表示服务器回应客户端「支持 HTTP2.0」，此时客户端下一次的请求就可以切换为为 HTTP2.0，当不支持 HTTP2.0 的时候会返回 200，那么客户端下一次请求则使用 HTTP1.1 ；\n2xx: 成功；\n3xx: 重定向，如地址栏键入 http:www.google.com ，浏览器会重定向到 https:www.google.com ，该过程是一个自动的二次请求过程，就是通过返回的 301 (Moved Permanently 永久性迁移， 302 为临时迁移，304 表示内容没有改变，F5 重新刷新该网页）状态码来告诉客户端重新请求；\n4xx: 客户端（浏览器、手机软件）错误，如参数错误，服务器无法识别该请求，是可以修正的；\n5xx: 服务器错误，如资源不足、资源找不到。\n\nHeader\n作用：Header 描述了 HTTP 消息的元信息 (Meta Data)，通俗地说就是描述数据的数据，如：该消息有多长？是什么格式？数据有没有压缩？返回的数据是什么字符集等等。\nHost\n在前面的例子中，有一个 Host 的字段，它表示服务器主机地址，但是它不是用来寻址的，寻址的过程在发送请求之前就已经做好了。\n\n在发送请求前，浏览器会带着域名「询问」 DNS（Domain Name System 域名系统） 目标 IP 地址，然后 DNS 返回一个或多个 IP 地址，然后通过 IP 地址去寻址，然后发送报文给目标服务器。\n\n那么为什么在请求 Header 中为什么还要带上 Host ？\n是因为一个服务器主机下可能有多个虚拟主机或多个子服务器（多个网站）存在，也就是同样一个 IP 地址下面会有多个服务器存在，由于它们对外的 IP 都是一样的，浏览器根据这个 IP 去请求服务器，服务器会无法识别该次请求访问具体哪个主机，最终得不到正确的响应，所以需要发送 Host 附加到 Header 到服务器。\n\n服务器地址一般的形式是：域名 + TCP 端口。\n\nContent-TypeContent-Length\n描述 Body 的类型和长度。\n\nContent-Length：内容的长度（字节）\n\n为什么会有 Content-Type 的存在？\n是因为请求报文中，可能会携带二进制非文本数据，二进制数据本身是不受限制的，它表示着各种各样的字节，那么如何表示内容字节结束？此时 Content-Type 的作用就是表示规定一个长度，长度范围内读取数据，长度过后的数据，直接扔弃。\n\nContent-Type：内容的类型\n\ntexthtml: html 文本，用于浏览器页面响应。\napplicationx-www-form-urlencoded: 普通表单，encode URL 格式，只作用于文本。\n\n表单，可以简单的理解为：一个要提交的表，是浏览器和服务器沟通的一个格式。通过表单，服务器会解析本次请求的 Body 内容，找对应参数。\n\nmultipartform-data: 多部分形式，一般用于包含二进制内容的多项内容。后面会跟 boundary=----WebKitFormBoundaryxxxxxx，它的作用是用来分界 Body 和 Header 以及 Body 的各个属性。如修改人物信息的时候，通常会附带普通的「名字信息」和「头像图片」，那么请求格式如下：\n123456789101112131415POST users HTTP1.1Host: twitter.comContent-Type: multipartform-data boundary=----WebKitFormBoundary247HFSSj7fgwj01Content-Length:2300------WebKitFormBoundary247HFSSj7fgwj01  分界 🏃Content-Disposition:form-data; name=&quot;user_name&quot; user_name 属性valentizx------WebKitFormBoundary247HFSSj7fgwj01  分界 🏃Content-Dispostion: form-data; name=&quot;avatar&quot;;filename=&quot;valentizx.jpg&quot;  avatar 属性Content-Type: imagejpegSFH72jfoa6GSKHGS....------WebKitFormBoundary247HFSSj7fgwj0--  分界 🕴🏻分界前面有 6 个 「-」，前两个「-」表示一个新的属性的开始，最后一个分界后面有两个「-」表示结束。\napplicationjson: json 形式，多用于 Web Api 的响应或 PUTPOST 请求\nimagejpeg、applicationzip ...: 但文件，用于 Web Api 响应或 POSTPUT 请求。\nChunked Transfer Encoding 分块传输\n当一次请求的响应数据内容较大时，为不影响用户体验，服务器通常会返回一个 chunk 单位的数据给客户端，但是服务器不会告诉 Header 每一个 chunk 具体多长，也就是 Body 长度无法确定，此时 Content-Type 无法使用。于是，新的 Body 格式出现：\n123456&lt;length1&gt;&lt;data1&gt;&lt;length2&gt;&lt;data2&gt;0  ⬅️此处有换行位⚠️\n明确每一小段（chunk）的长度放到 Header 中，先传输 data1，当 data2 准备就绪的时候传输 data2，直到传输 0 + 换行 表示内容结束。\nLocation\n重定向的目标 URL，一次请求返回 301 的时候，浏览器会进行重定向到 Location 字段后的地址再进行一次请求。\nUser-Agent\n用户代理，就是指客户端（Client），网页会根据不同的设备进行适配，标识凭借就是 User-Agent。\nRangeAccept-Range\n指定 Body 的内容范围，当目标服务器支持分段取内容的时候，该字段发挥作用，其最主要的两个应用点就是：断点续传和分段下载。\nCookieSet-Cookie\n发送 Cookie，设置 Cookie\nAuthorization\n授权信息\n部分其他 Header\nAccept: 客户端能接受的数据类型。如 texthtml\nAccept-Charset: 客户端度接受的字符集。如 utf-8\nAccept-Encoding: 客户端接受的压缩编码类型。如 gzip\nContent-Encoding: 压缩类型。如 gzip\nCache\nCache 和 Buffer\n\nCache：缓存，表示一块内容可能多次使用，所以这部分内容暂时放在缓存区域中，当不用的时候会被回收掉，面向速度；\nBuffer： 缓冲，工作过程中，上游生产快下游不能及时消费，或者下游暂时无消费，时间段过后会「猛」消费，则需要缓冲机制，提前生产一点存起来供下游使用，面向工作流；\n\nCache-Control\nno-cache、no-store、max-age:\n\nno-cache: 服务器告诉 Client 端，该内容可以缓存，但是再次请求的时候服务器需要知道缓存的内容是否失效；\nno-store: 不许缓存；\nmax-age: 在失效日期内，Client 端随意访问；\n\nLast-Modified\nIf-Modified-Since: 缓存界面最后的修改时间，请求过程中，服务器会对比缓存的最后修改时间和真实文件的最后修改时间，如果一致，说明文件没有改动过，返回 304，否则返回 200 和新的内容。\nEtag\nIf-None-Match: 相当于 Hash，或者说相当于一个指纹，Client 端也可凭借该字段与服务器「沟通」，对比这个标签，如果不是最新的，则请求最新的，返回 200 显示新内容，如果一致，则 返回 304。\nCache-Control\nprivate 和 public，一次请求的实际过程可能极其复杂，通过各个节点，各个网关，private 和 public 就是告诉路上经过的这些中间节点是否需要帮助缓存信息。\n\n⚠️ private 并不表示内容的私密性，私密性是通过加密机制来实现的，它表示「个性化定制信息」。\n\nREST\nREST：对 HTTP 进行一种限制，属于一种架构风格。\n\nServer-Client architecture\nStatelessness\nCacheability\nLayered system\nCode on demand\nUniform interface\n\nResource identification in requests\nResource manipulation through representations\nSelf-descriptive messages\nHypermedia as the engine of application state (HATEOAS)\n\n\n\nRESTful HTTP\n规范 HTTP 的使用方式，正确的使用 HTTP。\n","tags":["HTTP"],"path":"2019/01/20/2019-01-20/","external_link":""},{"title":"HTTP 原理和工作机制（二）","date":"2019-01-24T07:03:43.000Z","content":"加密与解密 Encryption &amp; Decryption\n古典密码学\n起源：古代战争 - 古典密码学，为防止「信使」被敌方掳获获得我方情报，诞生了最初代的古典密码学，其代表加密工具就为 - 密码棒，如下图：\n\n密码棒的规格是严格定制的，发情报的一方和收情报的一方是一一对应的，如上图中每一面都是对应的加密信息。\n加密的意义不在于信息不被侵犯，而在于被侵犯获取后不被破解。\n其实，密码棒中就已经包含了密码学最重要的两个因素：加密算法和密钥，在密码棒中，加密算法即为缠绕方式，密钥则是木棒的规格。\n古典密码学加密方式分为：移位式加密和替换式加密，密码棒就属于典型的移位式加密，而替换式加密的代表就是替换文字加密，如：\n发送方需要发送的是 Christina Aguilera，加密规则为：每个字符都替换成它的下一位，于是密文就变成了：\nDisjtujob Bhvjmfsb\n在此过程，加密算法则为：替换文字，密钥为：码表（表示信息和加密后的密文一一对应的映射关系）。当双方都拿着一样的码表便可以进行通信了。\n现代密码学\n当计算机发展高速的时候，这些加密的思想便应用到计算机领域当中，一些高深复杂的数学知识可以完美的应用到加密算法中，这样得到的密文很难破解。于是，诞生了现代密码学，现代密码学不止用于文字，还可以用于二进制数据。\n现代密码学的加密方式同样分为两种：对称加密和非对称加密，对称加密和移位式加密很像，但是要复杂得多。\n对称加密\n对称加密的原理：使用密钥和加密算法对数据进行转换，得到的无意义数据即为密文；使用解密算法和密钥进行逆向转换，得到原数据。\n经典算法：DES（密钥太短容易被破解被弃用）、AES。\n\n一个优秀的加密算法是让破解方使用**穷举法（在此通俗理解就是破解方把可能性范围内所有的密钥去破解的这种暴力破解方法）**才能破解的算法，也就是指花费破解方时间成本最高、精力成本最高的算法。当破解时间达到一个很大的值如 1000 年、10000 年则可认为该密文不能破解，在计算机发展的今天 AES 可以满足对称加密需求，在未来的一段时间内，硬件的不断更新迭代，计算的速度越来越大，AES 的密钥必定不能满足对称加密需求。\n\n非对称加密\n非对称加密原理：使用公钥对数据进行加密得到密文；使用私钥数据即行解密得到原数据\n非对称加密相对对称加密的优点是：密钥可以放心的在网络之间传输。对称加密的传输过程中，一旦密钥被截取，那么本次传输也就不再安全。\n非对称加密的通信过程如下图：\n\n在传输前 A、B 双方会得到对方的公钥，当 A 给 B 发信息的时候，会先用 B 的公钥进行加密，B 收到 A 的密文拿着自己的私钥解密得到原始数据，B 给 A 发信息同样如此，加入通信过程中 C 截获了消息，并且截获了公钥 A 和公钥 B，他是没有办法破解原始数据的，因为解密的关键私钥 A 和私钥 B 在 A、B 双方安全的保存。\n\n私钥能解公钥，公钥亦能解私钥，但是公钥和私钥不能置换使用，因为很多时候公钥是根据私钥计算出来的，如应用在比特币身上的加密算法-椭圆曲线算法中公钥就是根据私钥计算的，假设公私钥置换使用，破解方截获了私钥，也就意味着破解方同时拥有了公钥和私钥。\n\n--\n** ⚠️上述过程中，同样有潜在的不安全问题在，当 C 截获了公钥 A 和公钥 B 的时候，C 是可以伪造 A 的身份（因为他有公钥 B）与 B 进行通信，那么这个问题该如何解决？签名就发挥作用了。**\n签名与验证\n非对称加密一个很重要的延伸用途：数字签名。\n签名与验证的过程\n签名和验证的意义就在于：\n要让别人知道，这则消息是「我」本人发出的。也就是说「我」用「我」的私钥加密了信息，别人拿着「我」的公钥能还原信息并能确认是「我」本人的信息。就好比一张欠条，别人一看就能知道，是我本人亲自签署的。这时候，「签署」和「签名」有着相同的意味。加密和验证的过程如下图：\n\n\n与加密相反的是，签名是用私钥签名，然后对方通过公钥验证，而加密则是原数据通过对方公钥加密，对方通过手中的私钥解密得到原数据。\n\n签名过程通常会携带原数据，方便验证方通过公钥得到的原数据和携带的原数据进行对比从而得到验证结果。\n签名 + 加密\n过程如下图：\n\n原数据会使用对方公钥进行加密得到密文，同时需要身份验证，所以要使用私钥加密得到签名数据，最终得到密文+签名数据就是签了名的加密数据。\n上一节 ⚠️ 部分中一个安全隐患，就可以通过加密+签名的机制来解决，当 B 拿到数据后通过解密和验证后可得知该消息是否真的来自 A。\n非对称加密的经典算法：RSA 和 DSA，DSA 专门用来签名，而 RSA 签名加密解密都可以。\n\nDSA 设计方式特殊，它的签名和验证过程非常之快，所以只用来签名。椭圆曲线算法就属于 DSA。\n\n--\n\n同样的，一个优秀的非对称加密算法同样是破解方只能通过「穷举法」去破解。\n\n密码学密钥和登录密码\n二者除了有个“密”字没有任何关系。\n\n密钥（Key）：用于加密和解密，属于数学的领域，目的是保证数据被盗时不被人看懂；\n登录密码（Password）：用于用户的身份验证，不需要任何数学方面的计算和证明，目的是为了给服务方提供「你是你」的证明。\n\n编码与解码 Encoding &amp; Decoding\nBase64\nBase64 是什么？\n它是将二进制数据转换成 64 个字符组成的字符串的编码算法。\n什么是二进制数据？\n非文本数据就是二进制数据，广义的计算机数据都是二进制数据。\nBase64 转换\nBase64 的码表：\n\n\n\nIndex\nChar\nIndex\nChar\nIndex\nChar\nIndex\nChar\n\n\n\n\n0\nA\n16\nQ\n32\ng\n48\nw\n\n\n1\nB\n17\nR\n33\nh\n49\nx\n\n\n2\nC\n18\nS\n34\ni\n50\ny\n\n\n3\nD\n19\nT\n35\nj\n51\nz\n\n\n4\nE\n20\nU\n36\nk\n52\n0\n\n\n5\nF\n21\nV\n37\nl\n53\n1\n\n\n6\nG\n22\nW\n38\nm\n54\n2\n\n\n7\nH\n23\nX\n39\nn\n55\n3\n\n\n8\nI\n24\nY\n40\no\n56\n4\n\n\n9\nJ\n25\nZ\n41\np\n57\n5\n\n\n10\nK\n26\na\n42\nq\n58\n6\n\n\n11\nL\n27\nb\n43\nr\n59\n7\n\n\n12\nM\n28\nc\n44\ns\n60\n8\n\n\n13\nN\n29\nd\n45\nt\n61\n9\n\n\n14\nO\n30\ne\n46\nu\n62\n+\n\n\n15\nP\n31\nf\n47\nv\n63\n\n\n\n\nBase64 有 64 个字符可表示内容，其中每一个字符都要对应上述码表中的一个数，2 的 6 次方是 64，如超出 6 位，该码表就无法表达内容，故划分 6 个 Bits 为一个单元。\n下面的例子，「Man(ASCII 编码)」：\nM 的二进制数据为：01001101；\na 的二进制数据为：01100001；\nn 的二进制数据为：01101110。\n每个字母的二进制数据 6 个为一组，得到\nM：010011 + 01；\na：011000 + 01；\nn：011011 + 10。\nM 的前六位的十进制为 19，19 对应上述码表 T，剩下两位和 a 的前四位组合转化成十进制为得到 22 对应 W，a 的后四位和 n 的前两位组合转换十进制为 5 对应 F，n  的后六位对应 u。\n所以对「Man」进行 Base64 转码得到 TWFu，由此可见 Base64 转化后的数据明显「增大了」，由 3 个变成了 4 个，那么为什么不选用 Base256 也就是 2 的 8 次方表示呢？因为常见的字符合集不够 256 个，无法满足需求。\n**Base64 的用途：\n\n让原数据具有字符串所具有的特性，如可以放在 URL 中传输、可以保存文本文件等；\n人眼无法识别，降低头盔风险。**\n\nBase64 加密传输图片，可以更高效更安全？\n安全只能靠加密保证，Base64 不具备加密效果，没有任何安全性可言；高效也是错的，通过 Base64 编过的数据已经变大了很多，延长了传输时间，反而降低了效率。\nBase58\nBase64 的变种，去掉了 Base64 种 0 和大写 O，小写 l 和小写 I 以及 + 和 ，Base58 主要用在比特币（或其他币）领域的地址上，该地址可能被手抄，那么 0 和 O以及 l 和 I 会造成混淆，至于去掉 + 和  是为了方便双击复制。\nBase64 的重要应用\nURL encoding：将 URL 中的保留字符使用 % 进行编码。\n为什么使用 % 的特定编码方式？原因在下。\n示例：当在地址栏中输入 https:facebook.com张雷克斯 (这是一个不存在的网页)，浏览器会显示：\n\n当把地址栏的地址拷贝到一个文本编辑器中的时候会变成：https:www.facebook.com%E5%BC%A0%E9%9B%B7%E5%85%8B%E6%96%AF 这样的结果。\n中文的部分变成了看不懂的字符，那是应为浏览器不支持显示中文，转换成其他字符，另，「」和「+」在 URL 中有特定的含义，为了消除歧义选择了 % 编码，能避免分析错误。\n压缩与解压缩 Compression &amp; Decompression\n压缩：把数据换一种方式来存储，以减小存储空间。\n解压缩：将压缩后的数据还原。\n常见的压缩算法：DEFLATE、JPEG、MP3\n\nzip 的归档方式使用的压缩算法就是 DEFLATE，JPEG 就是对图片处理的压缩算法，MP3 则为对音频处理的压缩算法。\n\n压缩属于编码吗？\n要弄清楚这个问题首先要明白编码到底是什么？其实，编码没有实际的定义，但通俗来理解，就是从一个格式转换成另一个格式并且可以转回来，在转换的过程中不丢失信息不增加信息，这个过程叫编码，所以压缩是完全属于编码。\n媒体数据的编码\n图片的编码：把图像数据写成 JPG、PNG 等文件的编码格式。\n图片的解码：把 JPG、PNG 等文件中的数据解析成标准的图像数据。\n音视频的编解码同理。\n\n媒体文件中还存在有损压缩，但不妨碍对媒体数据的解读。\n\n序列化 Serialization\n序列化：把数据对象（一般是内存中的，如 JVM 中的对象）转换成字节序列的过程。\n反序列化：把字节序列重新转换成内存中的对象。\n\n通俗点说，序列化的过程就是将内存中的数据转换成可以存储的线性的格式，如 JSON 格式、xml 格式。目的是让内存中的对象可以与外界通信（存储、传输）。\n\n序列化属于编码吗？\n严格来说，编码是两个不同的格式互相转换，而序列化是内存中的数据转换成可通信的格式。但广义上来说也属于编码。\n哈希 Hash\n定义：把任意数据转换成制定大小范围（通常很小）的数据。\n作用：摘要、数字指纹。\n计算机领域当中的某个数据可能非常大，我们在描述它的时候不希望将整个的数据进行描述，而是通过一个指代它的很小的字节就可以描述。这就是 hash 值的作用。\n经典算法：MD5、SHA1、SHA256等。\n\n优秀的 Hash 算法是计算出的结果之间不会碰撞，即碰撞率极低。\n\n实际用途：\n\n数据完整性验证；如下载某个开源包或者某个安装包时，发布方都会提供一个或多个 hash 值，下载后对下载文件计算 hash 值，如果和发布方的相同则表示是完整的。\n快速查找：hashCode() 和 HashMap；\n隐私保护。\n\nJava 开发中通常在重写 equals() 方法的同时要重写 hashCode()，为什么？\n假如有 Singer 类：\n1234567891011class Singer&#123;    int age;    String name;    public boolean equals(Object obj) &#123;         return age == obj.age &amp;&amp; name.equals(obj.name);    &#125;&#125;    public long hashCode() &#123;    return age + name.length()   简单的 hash code     &#125;\nhashCode 是用来做身份验证和识别的，在 hashCode() 中有 N 多的方法可以提高该对象 hash 值的唯一性。hashCode 直接影响 HashMap、HashSet 等的内存地址定位。\nHashMap 的对象是根据 Key 的 hash code 来获取对应 Value。当 Singer 类的 hashCode() 方法重写的不严谨时，算出的 hash code 是一个非常简单的值会导致两对象的 Key 指向同一个 Value，修改 A 后再修改会 B 会把 A 的 Value 替换掉。\n所以重写 hashCode() 后与 HashMap 等相关的操作才能正常使用，使用 hashCode() 性能会比较好。\n为什么需要同时写呢？因为 hash code 只是简单的对对象进行比对，并不会比对两个对象属性的具体信息。假如没重写 hashCode() 方法，会调用其父类默认的 hashCode() 方法，这会导致调用 equals() 方法比对两对象不相等但比对 hashCode() 方法的结果的时候相等。\n重写并严谨的重写两个方法可以大大提升开发效率。\n\n⚠️ Hash 不是编码，是单向的，不能够还原。\n⚠️ Hash 不是加密，MD5 亦不是加密。\n\nHash 和非对称加密\n在非对称加密传输过程中，一个文件的大小约在 10G 左右，那么通过加密算法签名后的签名数据也为 10G 左右，再加上需要验证的原数据则一共为 20G，数据太过臃肿，在实际生活中，签名的过程为：先对原数据进行哈希，再对哈希值签名。完整的过程为：\n\n字符集 Charset\n含义：一个由整数向现实世界中符号的 Map。\n分支：\n\nASCII: 128 个字符，1 字节；\nISO-9885-1: 对 ASCII 的扩充，1 字节；\nUnicode: 13 万个字符，多字节，UTF-8UTF-16 是他的编码分支；\nGB 系列: 中国自研标准，多字节。\n\n","tags":["HTTP"],"path":"2019/01/24/2019-01-24/","external_link":""},{"title":"HTTP 原理和工作机制（三）","date":"2019-02-13T02:52:11.000Z","content":"登录和授权\n登录\n身份认证的过程，在输入账号和密码以及点击登录按钮这一操作流程，就是将「你本人」和所输入的「账号」建立联系的过程。\nCookie\n起源：购物车，当时的「购物车」不存在服务器，电商网站的开发商觉得用户在没有真正决定购买的情况下不需要将购物车的信息放进服务器里，只存在本地就好，于是电商网站开发商决定做一个浏览器来实现这一功能，也就是说，电商网站——浏览器是一体的，并实现了 Cookie 的功能满足购物车的需求，这就是最早的 Cookie。\nCookie 的工作机制\n由于是客户端保存信息，所以保存的信息由服务器决定，服务器返回的信息客户端保存就行了。\n如，在购物车里添加一个苹果，客户端访问服务端 cart 这个 path，并附带苹果的数量这个参数，表示「我要放进购物车里 1 个苹果」，服务器处理完返回 200，并附带 Set-Cookie 的 Header 表示让客户端存起来。\n\n下次客户端再访问 shop.com 的时候会附带 cart=&quot;apple=1&quot;，这是一个自动的过程，并由浏览器实现。\n如下次购物车再添加一个香蕉，浏览器会自动附带 cart=&quot;apple=1&quot; 的信息去请求，服务端会知道客户端已经「存储」了一个苹果，处理后返回 200 更新 Set-Cookie 的 Header，此时客户端更新 Cookie。\n\n该过程服务端什么都没记，全都由客户端存储，Cookie 谁来修改？是服务端，每次都是服务端来修改 Cookie 信息，客户端被动的更新、存储。这就是早期的 Cookie 的工作机制。\n\n现在逐渐抛弃用 Cookie 机制来做登录和认证。\n\n使用 Cookie 管理登录状态\n客户端使用账号密码访问服务端，服务端确认后，会创建一个会话（Session），会话记录了客户端可能是什么状态、用户代理等信息。然后服务端将 Session 返回给客户端。\n\n客户端下次访问服务端的时候会附带 sessionid，假如客户端想要请求用户信息，服务端凭借 sessionid 会得知，该客户端在登录状态，可以返回给他要的用户信息。\n\n关于登录状态的管理，服务端是需要插手干预的。\nCookie 的作用\n\n会话管理：登录状态、购物车等；\n个性化：用户偏好、主题；\nTracking：分析用户行为（能够得知用户访问哪些网站）。\n\nXSS（Cross-site scripting）\n跨站脚本攻击，假如网站的 javascript 是坏人写的，有可能会将本地的 Cookie 转发出去，这是看不见摸不着的，Cookie 的泄漏也就代表某些敏感信息的泄漏。\n应对策略就是在 Cookie 的 Header 后加 HttpOnly 的限制，这样本地脚本看不到该 Cookie，该 Cookie 只用于 HTTP 的信息交换。\nXSRF（Cross-site request forgery）\n跨站请求伪造，由于 Cookie 是一个自动的过程，攻击者可以利用 Cookie 访问授信网站伪装成授信用户进行一些操作。其中一个防范措施就是带上 Referer 的 Header 告诉服务器我是从哪个页面来的，假如来源的这个页面不授信，则服务器拒绝处理。\n授权\n赋予某个人具有某个权限，能执行什么操作，在计算机世界里，这个特殊的权限叫做令牌，就像古代的刽子手本身不具备权限杀人，但是皇上赋予了刽子手行刑的权力，那么刽子手便可以杀人了，皇上就是授权方。\nBasic\n基本的授权方式，用得较少但是实用，格式如下：\n1Authortization: Basic&lt;username:password(Base64ed)&gt;\nBearer\n需带着令牌的授权方式，格式如下：\n12Authortization: Basic&lt;bearer token&gt;token 需要找授权方获得。\nOAuth2\n提供第三方认证的机制，是一个授权框架，它可以使第三方的应用程序或者客户端获得对应 HTTP 服务器上用户账号信息的访问权限。\n如，在登录掘金的时候，除了从正常的账号密码登录以外还可以选择三方登录，如 GitHub，在点击 GitHub 登录的时候就会弹出下面的小窗口进行授权。\n\nOAuth2 认证流程\n认证流程如下图：\n\na. 在这个过程中，本人和 GitHub 是第一、二方，而掘金是第三方，所以这个流程的意义就是：GitHub 授权掘金，赋予掘金可以访问 GitHub 账号信息的权限，从而登录掘金的网站。\n\n在该流程中，有一个重要的角色：client_id，它是三方网站开发者在开发登录模块是去 Github 申请下来的。相当于标记或者身份证的作用。凭借 client_id 与 Github 沟通，Github 会返回如头像、账号名字、URL 等信息。\n\nb. 当点击上图的 Authorize Xitu 后，少顷，便跳回掘金主页，账号会显示来自 GitHub 的账号。在跳回掘金主页的时候 GitHub 会返回 Authorization code 如下图：\n\nQ: 为什么返回的不是 token 而是 Authorization code？\nA: 因为 OAuth2.0 整个过程不是强制基于 HTTPS 的，那么在返回的过程可能被拦截，假如返回的是真正有意义的信息，那么该有意义的信息可能被窃取；还有一个原因就是浏览器是不可靠的，用户用什么浏览器以及操作系统都是未知的，所以在返回的过程中依然存在风险，所以 GitHub 返回的仅仅是一个授权码，仅仅是一个证明，表示用户同意了 GitHub的授权而已。\nc. 接下来在看不见摸不着的背后，掘金带着 Authorization code 和掘金的 Server 端沟通，掘金的 Server 端带着 Authorization code 和 client_id 和 GitHub 请求, client_secret 是三方在向 GitHub 申请应用的时候一起申请下来的。client_secret 是绝对保密的，一直存在 Server 端，而 Server 端和 GitHub 的连接也是 HTTPS 连接保证安全。当 Server 端同时具备：身份证明（client_secret）以及用户证明（Authorization code）后，GitHub 便可确认三方的请求连接足够安全，对方足够可靠，便可放心的将 token 返回给 Server 端，至此，整个 OAuth2.0 的认证流程结束，第三阶段流程如下图：\n\nd. 当认证流程结束返回到掘金的主页时，此时掘金账号的头像亦是 GitHub 请求下来的，此时的请求流程便是：Server 端带着 token 请求 GitHub 的头像信息，然后进行显示，如下：\n\n\n在某些安全意识不强的情况下，Server 端会把 token 返还给客户端，这种做法就不再具备 OAuth2.0 认证的安全性。\n\n微信登录\n微信登录，是一种第三方登录，亦是一个标准的 OAuth2.0 的认证过程，正确的微信登录流程是：\n调用微信的 API 后打开微信的授权界面进行授权，此时是微信在对「你」进行第三方授权，确认返回后，微信会返回一个 code```，**此时将 Authorization code 交给服务器**，此时，客户端的任务结束，服务端的任务便遵循 OAuth2.0 的流程去和微信的服务器打交道（同上节 OAuth2.0 认证流程一样）。12345678###### 自家产品中使用 Bearer token在多数情况下， 调用登录接口并且登录成功的情况下，Server 端会返回 access_token  token，然后请求其他接口的时候 Client 端直接拿着这个 token 请求，这种做法是**模仿了 OAuth2.0 中 access_token 的使用方法**，但并不是 OAuth2.0 的过程。###### refresh token刷新 token 从 Server 端返回的格式大概是：\n{\n&quot;token_type&quot;: &quot;Bearer&quot;,\n&quot;access_token&quot;: &quot;xxxx&quot;,\n&quot;refresh_token&quot;: &quot;xxxx&quot;,\n&quot;expires_time&quot;: &quot;xxxx&quot;\n}\n\nrefresh_token 的作用是，以此请求一个新的 access_token 和一个新的 refresh_token，那么旧的 token 会失效，refresh_token 存在的意义就是保证安全，因为 access_token 还是有概率会丢失，如果是授权登录，丢失 access_token 会导致用户再次认证、登录，这样的操作极不友好，所以需要借助 refresh_token 来获取新的 access_token 并且将旧的“作废”。**这个过程还是尽量保证在 Server 端。**\n\n## TCPIP 协议族\n\n**TCPIP 协议族并不是单指 TCP 和 IP 的构成，而是一系列协议组成的一个网络模型分层。**\n\n在很多有关网络的文章亦或是大学的计算机网络课程中，「分层」这个词出现的频率极高，如物理链路层、表示层、会话层等等。\n\nQ: 那么为什么要分层？\n\nA: Client 和 Server 进行通信的时候途中会经历很多**中间节点**，如下图：\n![-w739](http:pmud0ogk6.bkt.clouddn.com15495540524424.jpg)\n\n报文经过的节点的路径并无规律可言，并且由于网络的不稳定性（如断电、中间节点的损坏）会导致某次数据传输失败，那么就需要重传数据，在传输过程中，**重传**是一定会发生的，假如数据很大的话，需进行**分块传输**，如下图（假如 ABC 是一个很大的数据）：\n![-w756](http:pmud0ogk6.bkt.clouddn.com15495549695700.jpg)\n\n&gt; 上半部分是分块传输，下半部分是完整的数据传输，上半部分，假如 A、C 送达，但 B 未送达，也就是发送方未收到 B 的送达回应的时候会重传，直到成功送达，此过程中传输了 5 次，假如选择传送完整数据，可能会导致更多次的失败。\n\n分块传输能保证数据完整且高效的送达，分块传输的出现也就导致整个网络需要分层。因为**应用层**并不只有 HTTP，还有 FTP、DNS、TELENET 等等。各个协议都有包分发的需求，所以按照编程的思想，公共的需求可以单独抽取，在网络里即是抽取一层专门处理包的分发，如下：\n![-w760](http:pmud0ogk6.bkt.clouddn.com15495915765603.jpg)\n\n每次数据传输，HTTP 层将包给 TCP 层，TCP 进行分块然后传输，哪个部分丢失了，TCP 会对丢失的部分重传。该层即为**传输层**，TCP 能保证整个过程稳定传输。\n\n但是并不是所有的数据都需要重传，如视频通话，在网络卡顿的时候，丢失的帧不需要重传直接显示最新的视频数据即可，对于语音、视频通话这种要求数据高速度传输和实时到达的需求，UDP 即可满足，UDP 的特点就是：尽最大可能传输，不保证到达，不重传也不需要验证。\n\nUDP 和 TCP 共同的地方就是都需要将数据从一个主机找到另一个主机进行传输，UDP 和 TCP 这种公共的网络需求即可再单独抽取一层，该层即为**网络层**，如下：\n\n![-w713](http:pmud0ogk6.bkt.clouddn.com15495927038710.jpg)\n\n传输层将数据分块传给网络层，网络层将分块的数据发往目标网络或主机，网络层只管传输，不参与数据的处理，也就是说，它并不知道各个数据块之间的联系，甚至失败、重传也不参与。确认数据的到达在传输层，假如 B 未到，传输层则需要“告知”发送方需要重传，直至 B 到达，传输层则将整包数据拼装好上传至应用层。\n\n应用层、传输层、网络层并未提供实质的物理链路传输仅仅是定义了访问的接口，在整个网络传输的结构中，需要有一个实际的链路来支持传输，那么这个重任就交给**数据链路层**，以太网、路由器等等物理设备或网络就属于这一层，如下图：\n![-w714](http:pmud0ogk6.bkt.clouddn.com15495935578067.jpg)\n\n以上就是传统四层。\n\n因为应用层的各个协议应用在传输数据的时候都需要对数据分块并且传输，所以传输层出现了，但是数据的传输不一定都要确认送达，只管尽最大可能传输就行（UDP），所以抽取只管负责寻址、寻找主机并且传输数据的一层，网络层也就出现了。\n\n\n| 各个层级 | 协议实现 |\n| --- | --- |\n| 应用层（Application Layer） | HTTP、FTP、DNS | \n| 传输层（Transport Layer） | TCP、UDP |\n| 网络层（Internet Layer） | IP |\n| 数据链路层（Link Layer） | 以太网、Wi-Fi |\n\n&gt; 数据流向：发送方是自上到下，接收方是自下至上。\n\n\n### TCP 连接\n\n在计算机世界里，经常能听到「长链接」这个词，那么什么是长链接？在了解长链接之前，什么又是「连接」？\n\nA：连接是 TCP 的连接，并且是有状态的连接，TCP 在发数据之前会将数据分成报文段，然后发向目标主机网络，在此之前，需要和目标主机网络**先建立一个互相沟通的确认方案**，接收方需要知道报文段如何拼装，当互相确认的时候，该过程就是 TCP 连接建立的过程，当确认被确定了，就可称作建立了一个连接。\n\n#### TCP 连接建立与关闭\n\nTCP 的建立过程如下图（三次握手）：\n![-w449](http:pmud0ogk6.bkt.clouddn.com15495952284047.jpg)\n\n请求方与被请求方的 TCP 通信流程是：\n1. 请求方「告知」被请求方：「我要给你发消息了」\n2. 被请求方「回应」请求方：「我知道了，我也要给你发消息了」\n3. 请求方「告知」被请求方：「我知道你也要给我发消息了」\n\n\n当确认后双方都会互相等待发送消息，会占用网络资源，当不需要通信后，则需要 TCP 关闭，TCP 的关闭过程如下图（四次挥手）：\n![-w445](http:pmud0ogk6.bkt.clouddn.com15495954868765.jpg)\n\n1. 请求方「告知」被请求方：「我不再发消息了」\n2. 被请求方「回应」请求方：「好的我知道了」，但被请求方不会立即「回应」：「我也不给你发消息了」，此时有可能还有未发完的消息。若有未发送的消息，先发送消息。\n3. 被请求方「告知」请求方：「我不再给你发消息了」\n4. 请求方「回应」被请求方：「好的我知道了」，双方扔弃资源。\n\n#### 长链接\n什么是长链接？**长链接就是强制连接不要被关闭。**\n\nQ: 为什么会出现长链接？\n\nA: 因为并不是所有的设备（电脑、手机等）都在**公网**内，很多设备都在**内网**中，如：公司、小区的内网。**手机就处在运营商部署的内网当中，**内网内的设备想要和外界通信，需要运营商服务器分配的**端口**才能实现。内网内所有主机占用的端口**都是网关的端口**，服务器分配端口是相对耗费资源的，为了节省资源，服务器会检测长时间不发消息的设备会将其端口关闭，这就导致设备无法与外界通信，如手机软件不会收到推送、消息等。为了突破这个限制，需要用「欺骗」网关的方式 —— **心跳**来建立一个长连接，周期时间内设备都会发送一个无用的 TCP 消息，网关会认为该端口一直被占用，所以不会关闭该端口。\n\n## HTTPS\n### HTTP over SSL\n\nHTTPS 并不是单独的协议，而是 HTTP 建立在 SSL 上，就称作 HTTPS。\n\n&gt; SSL: Secure Socket Layer（早期），现在为 TLS: Transport Layer Secure。\n\n**SSL 或 TLS 都是建立在 HTTP 之下增加的一个安全层，用于保障 HTTP 的加密传输。**\n\n**HTTPS 的本质是在客户端和服务器之间协商出一个对称密钥，每次发送之前将内容加密，收到之后解密。**\n\nQ: 为什么不直接用非对称加密？\nA: 非对称加密很慢，计算过程复杂。\n\n### HTTPS 连接\n\n过程大概如下：\n1. 客户端请求建立 TLS 连接；\n2. 服务器发回证书；\n3. 客户端验证服务器证书；\n4. 客户端信任服务器后，和服务器协商对称密钥；\n5. 使用对称密钥开始通信。\n\n具体：\n1. 客户端先请求和服务端建立连接，发送一个 Client Hello 的消息，表示「我要建立连接」，并附加 TLS 版本和客户端能接受的 Cipher Suite（加密套件，非对称以及对称加密以及哈希算法）信息和随机数；\n2. 服务端根据客户端的附带信息选择能支持的 TLS 版本、对应算法，再加上服务器的随机数和客户端发过来的随机数一并打包，随着 Server Hello 返回给客户端；\n3. 服务端向客户端发送一个证书，证书的核心是给客户端**公钥**，证书还包含服务器的地址、**证书签名**等信息；\n4. 客户端首先验证证书中的服务器地址以及**证书签名**等信息，假如能证书签名验证通过，能够证明服务器的信息是真实的，那么如何验证证书签名？**在 3 中，证书中还会附带签名机构的信息，里面包含证书机构公钥、证书机构其他信息。**假如证书机构公钥能够对证书签名进行验证，那么说明服务器的证书信息是真实的。但是该「真实」是有前提的，仅仅能证明该证书确实是证书机构主人所签发的，无法证明该「主人」就是真实的那个主人，此时证书机构也要提供一个证书机构的签发方信息，也就是跟证书，像循环一样，但到这一步，已无需再附带其他信息，因为该根证书是有可靠来源的，来自操作系统内部，无论是 macOS 还是 Windows 还是 Android、iOS 等都有根证书列表，跟证书列表是被操作系统的研发官方所认证的，如微软、Apple、Google 或各浏览器的官方等，所以只要浏览器和操作系统不被破坏那么这个根证书就是可信赖的。整个嵌套关系如下：\n![-w372](http:pmud0ogk6.bkt.clouddn.com15496283593559.jpg)\n在浏览器中，亦可看到该证书层级嵌套。\n![-w641](http:pmud0ogk6.bkt.clouddn.com15496274007388.jpg)\n![-w484](http:pmud0ogk6.bkt.clouddn.com15496274234747.jpg)\n顶层为根证书，下一层为证书机构颁发证书，最下层为 Facebook 服务器的证书。\n\n5. 客户端拿到服务器公钥后，会进行整个过程唯一一次非对称加密操作，客户端会对 **Pre-master Secret** 非对称加密（本质还是一个随机数），发给服务端。现在双方已经有足够信息「生产」对称密钥了，此时客户端、服务端会根据 Pre-master Secret、客户端随机数和服务端随机数生产出一个 **Master Secret（它本身并不是密钥）**，Master Secret 可以生产出一个密钥，但密钥实际包括：**客户端加密密钥、服务端加密密钥、客户端 MAC Secret 以及服务端 MAC Secret**，MAC 指 **HMAC（Hash-based Message Authenticate Code）改良版 hash**，MAC Secret    用来做验证身份和签名的操作。\n&gt; 虽然两个随机数都是明文传的，但是通过数学原理依然可以达到安全保密的效果。\n\n1. 开始加密通信，将前面的 Client Hello、Server Hello、服务器证书、Pre-master Secret 等使用加密密钥加密使用 MAC Secret 进行类似签名的操作发给服务端，并且会通知服务端「我要开始加密通信了」，同理服务器也会发「我要开始加密通信了」，也会将一系列信息（还包含客户端发来的加密信息和签名信息）打包加密签名发给客户端，客户端同样的验证方式进行验证。至此，验证过程结束，接下来客户端就可以进行正常的 HTTPS 请求了，此为第一个 HTTPS 请求。\n\n\nQ: 在 5 中为什么生产两个加密密钥？\nA: 出于安全考虑，客户端发消息用客户端加密密钥、服务端发消息用服务端加密密钥能勾搭到相对安全的效果。\n\n","tags":["HTTP","TCP"],"path":"2019/02/13/2019-02-06/","external_link":""},{"title":"「RSHARE」 一键分享 Android 版","date":"2018-08-29T09:03:59.000Z","content":"因为公司的项目里集成了一键分享的这个模块, 而在我设计的时候发现国内的官方文档和提供的 Sample 有混乱和容易混淆的地方, 而且除了普通的网页、图片、文字分享到各大 Social 平台以外, 对于视频、文件和其他内容的分享 Demo 在百度或者 Google 几乎搜不到. 自己也是踩了很多坑才把很多问题解决.\n测试设备\nSamsung S9 Plus, Android 8.0.0.\n支持平台\nRSHARE 这个 Demo 中支持: 微信、QQ、新浪微博、Facebook、GooglePlus(Google +)、Twitter、WhatsApp、Line、Tumblr、Instagram、Pinterest 11 个 Social 平台.\n平台差异\n主要罗列了常用的 5 个分享内容的对比菜单(网页、文字、图片、本地视频、文件).\n注意菜单内字母以及菜单后面对应字母的注释⚠️\n\n\n\n❤️\nQQ\n微信\n微博\nFacebook\nTwitter\nInstagram\nWhatsApp\nLine\nTumblr\nPinterest\nGoogle+\n\n\n\n\n网页\n✓a\n✓\n✓\n✓b\n✓\n✗\n✓\n✓\n✓\n✗\n✓\n\n\n文字\n✗c\n✓\n✓\n✗\n✓\n✗\n✓\n✓\n✓\n✗\n✗\n\n\n图片\n✓\n✓\n✓\n✓\n✓\n✓\n✓\n✓\n✓d\n✓d\n✗\n\n\n视频\n?e\n✗\n✓\n✓\n✗\n✓\n✗\n✗\n✗\n✗\n✗\n\n\n文件\n✗\n✓\n✗\n✗\n✗\n✗\n✗\n✗\n✗\n✗\n✗\n\n\n\na. QQ 虽支持网页分享, 但是不允许带着网页的 description 字段, 这和 iOS 表现不同;\nb. Facebook 的网页分享支持 hashtag;\nc. iOS 端分享文字到 QQ 客户端是可行的, 但是 Android 端不允许, 其实 QQ 的分享目地就是让用户自行输入有价值、有意义的文字信息;\nd. Pinterest 和 Tumblr 虽支持图片分享, 但仅仅支持分享图片的 URL, 它会自行解析并显示;\ne. 只支持分享到 QQ 空间.\n⚠️ 1. 对于 QQ 分享 Android 端, 不支持通过 SDK 直接分享到数据线(我的电脑)和我的收藏.\n⚠️ 2. 对于 WhatsApp 分享 Android 端, 支持图文并存.\n\n\n对比列表得知, 国内的平台分享内容是最丰富的, 但是存在一个主要的问题(主要是 QQ), iOS 和 Android 双端的接口以及实现的功能也并不统一(后面的部分会具体说); 微信双端当分享的图片过大的时候的表现也有不统一的时候, 其余都很完善; 新浪的表现是最统一的, 且没有过多限制; 国内的平台分享最让人头疼的就是官方的 Sample 很混乱, 但是在实践代码的时候还是要以官方为主.\n国外的文档和 Sample 很明了且注释详细, 但也存在双端不统一的情况, Twitter 的双端表现就不一样(后面细说), 但是国外的平台分享几乎没有回调, Facebook 的回调只有 Feed 形式的分享才有效, Instagram、Line、Google+这些是没有 SDK 的, 仅仅是通过打开 Application URL scheme 来分享.\n\n\n分享总体设计\n大概的分享逻辑如下:\n\nAndroid 的分享是参照各大平台的分享逻辑得到比较统一思路, 即: 先判断是否安装对应应用, 然后初始化 SDK 与官方平台连接, 然后包装分享参数进行分享, 最后处理分享回调, 只不过与 iOS 端不同的是, 初始化 SDK 的工作是在分享逻辑内完成的, 并不对外开放(灵感来自 ShareSDK 的 Android 版), AppID、Key 以及 Secret 信息在 RShare.xml 文件中配置.\n\n\n有些平台不存在 SDK, 所以直接判断是否平台安装然后包装分享参数进行分享;\nTumblr 比较特殊, 有 SDK 但是不需要判断应用是否安装就可以分享, Twitter 也如此, 具体情况在 Twitter 的部分说明;\nSDK 的初始化, 统一函数名字为 sdkInitialize(但并未对外开放), Key、Secret 以及 AppID 等信息在注释中有标明.\n\n\n详细逻辑\n关于各个平台的开发者主页和文档信息以这里为主, 代码注释的可能不准确.\n平台分享都是通过单例模式实现.\n基类\n子平台 Manager 都是继承自 RShare, 这个类中定义了分享 Mode (代码注释中有标明)、分享内容类型枚举(内部使用) ShareContentType 以及分享回调.\nJava 中创建监听器来监听分享结果:\n12345public interface RShareListener &#123;    public abstract void onComplete(RSharePlatform.Platform platform);    public abstract void onFail(RSharePlatform.Platform platform, String errorInfo);    public abstract void onCancel(RSharePlatform.Platform platform);&#125;\nKotlin 中通过 callback 来监听分享结果:\n12typealias RShareCallback = ((platform : RSharePlatform, state : ShareState, errorInfo : String?) -&gt;Unit)\nMode(仅对 Facebook、Twitter、Instagram 有效, iOS 亦然):\nJava:\n123456789101112131415161718192021222324252627public enum Mode &#123;    **     * 默认的分享方式     * Facebook: 优先客户端分享, 客户端无法分享会转由网页形式分享.     * Twitter: 优先应用内分享.     * Instagram: 默认客户端分享.     * *    Automatic,     **      * 原生应用分享.      * Facebook、Twitter: 无回调.      ** *    Native,     **      * 网页分享, 有回调, 仅对Facebook生效.       * *    Web,     **      * 反馈网页形式分享, 有回调, 仅对Facebook生效.      * *    Feed,     **      * 调用 Android 系统分享.      * *    System,        &#125;\nShareContentType:\nJava:\n12345678910public enum ShareContentType &#123;    Webpage,    Photo,    Video,    Text,    Media,    File,    Music,    App&#125;\n配置文件\n在 srcmain 目录下新建资源文件夹 assets, 并创建 RShare.xml 配置文件, 文件内容如下:\n12345678910111213141516171819202122232425262728293031323334&lt;Platform&gt;    &lt;Twitter        ConsumerKey= yourKey        ConsumerSecret= yourAppSecret    &gt;    &lt;Facebook        AppID= yourAppID        AppSecret= yourAppSecret    &gt;    &lt;WeChat        AppId= yourAppID        AppSecret= yourAppSecret    &gt;    &lt;Sina        AppKey= yourAppKey        AppSecret= yourAppSecret        RedirectUrl= yourRedirectUrl        Scope=all    &gt;    &lt;QQ        AppID= yourAppID        AppSecret= yourAppSecret        &gt;    &lt;Tumblr        ConsumerKey= yourKey        ConsumerSecret= yourAppSecret                FlurryKey= yourFlurryKey    &gt;    &lt;Pinterest        AppId= yourAppID        AppSecret= yourAppSecret    &gt;&lt;Platform&gt;\n关于哪些字段不需要, 在后面会讲明.\n工具类 RPlatformHelper 中封装了解析 RShare.xml 并获取各个平台 Id、key 以及 secret 信息的方法.\n图片的处理\n与 iOS 不同的是, Android 端平台分享图片的通过图片的 Url 来进行参数的包装到分享. 在此, 我封装的接口传图片参数是以 Bitmap 形式传值的, 然后保存图片数据到一个文件夹, 获取数据的 Url 包装到平台 SDK 或者包装到 Intent 中分享.\n⚠️ 假如这个图片是网络请求下来的, 那么完整的分享步骤就是:\n\n多出一步再保存, 造成不必要的开销.\nJava 版本中, 保存图片的接口封装到工具类 RFileHelper 中; Kotlin 版本中, 用顶层函数替代了工具类, 整合到了 RFileHelper.kt 文件中:\n保存图片:\nJava:\n1RFileHelper.saveBitmapToExternalSharePath(context, targetImage);\nKotlin:\n1saveBitmapToExternalSharePath(context, targetImage)\n删除图片:\nJava:\n1RFileHelper.deleteExternalShareDirectory(context);\nKotlin:\n1deleteExternalShareDir(context)\n文件共享\n从 Android 7.0 开始, 其他应用使用本应用的某文件 file: 格式的 URI 会抛 FileUriExposedException 的异常(新浪 SDK 就存在这个问题), 所以在 RFileHelper 中封装好了对应方法:\nJava:\n1234567RFileHelper.detectFileUriExposure();``` Kotlin:```kotlindetectFileUriExposure()\nQQ\n准备\n分享需要注册平台, 腾讯开发者主页, SDK 下载, QQ SDK 目前不支持 compile 集成, Android API 调用说明文档.\n集成\na. 手动添加 SDK 到 libs 文件夹, 并:\n\nb. 在 AndroidManifest.xml 的 &lt;application&gt; 节点下增加:\n1234567891011&lt;activity       android:name=com.tencent.tauth.AuthActivity       android:noHistory=true       android:launchMode=singleTask &gt;    &lt;intent-filter&gt;        &lt;action android:name=android.intent.action.VIEW &gt;       \t&lt;category android:name=android.intent.category.DEFAULT &gt;       \t&lt;category android:name=android.intent.category.BROWSABLE &gt;        &lt;data android:scheme=tencentYOURAPPID &gt;    &lt;intent-filter&gt;&lt;activity&gt;\nc. 添加以下权限:\n1234&lt;uses-permission android:name=android.permission.INTERNET &gt;&lt;uses-permission android:name=android.permission.WRITE_EXTERNAL_STORAGE &gt;&lt;uses-permission android:name=android.permission.READ_EXTERNAL_STORAGE &gt;&lt;uses-permission android:name=android.permission.READ_PHONE_STATE&gt;\n接口及内部实现\na. 内部初始化 SDK\nJava:\n12private Tencent mTencent;mTencent = Tencent.createInstance(appId, context);\nKotlin:\n12private lateinit var mTencent : TencentmTencent = Tencent.createInstance(appId, context)\n\n仅做分享功能的话, secret 字段无用.\n\nb. 分享\nQQ Android SDK 分享是通过 Bundle 进行数据包装传输, 在这里分享音乐、网页、应用等等的键值对都封装在 QQShare.class 中, 很容易混淆和误会, 完善内容分享的时候一定要参照官方的示例程序!\nQQ 客户端和 QQ 空间的分享模型都封装在 RQqHelper 中, 但是分享启动的 Activity 将 QQ 客户端和 QQ 空间的分开, 分别是 RQqActivity 和 RQZoneActivity 在分享 Activity 中实现接口 IUiListener 用来监听分享结果.\n另, Android 端不支持直接打开‘我的收藏’和‘数据线(我的电脑)’分享, 需自行选择, 并且不支持纯文字分享.\n⚠️最后, QQ 分享一定要在主线程里完成!!! 获取 mainHandler 已封装到了 RThreadManager 中(写法有误或者写法有不足请严厉指出):\nJava:\n12345678910111213141516171819内部:private static Object mMainHandlerLock = new Object();public static Handler getMainHandler() &#123;    if (mManinHandler == null) &#123;        synchronized (mMainHandlerLock) &#123;            if (mManinHandler == null) &#123;                mManinHandler = new Handler(Looper.getMainLooper());                &#125;            &#125;        &#125;    return mManinHandler;&#125;调用:RThreadManager.getMainHandler().post(new Runnable() &#123;    @Override    public void run() &#123;         ...    &#125;&#125;);\nKotlin:\n1234567891011121314151617181920内部:private var mMainHandlerLock = Any()internal val mainHandler : Handler = Handler()    get() &#123;        if (field == null) &#123;            synchronized(mMainHandlerLock) &#123;                if (field == null) &#123;                    field = Handler(Looper.getMainLooper())                &#125;            &#125;        &#125;        return field    &#125;调用:mainHandler.post(    Runnable &#123;        kotlin.run &#123;             ...       &#125; )\n网页分享:\nJava:\n1RQqManager.getInstance().shareWebpage(context, webapgeUrl, title, description, thumbImage, listener);\nKotlin:\n1RQqManager.instance.shareWebpage(context, webpageUrl, title, description, thumbImageUrl, callback)\n表现:\n\n图片分享:\nJava:\n1RQqManager.getInstance().shareImage( context, targetImage, listener);\nKotlin:\n1RQqManager.instance.shareImage(context, targetImage, callback)\n表现:\n\n音频链分享:\n大致和网页的分享相同, 但是多了一个 audioStreamUrl 的字段.\nJava:\n1RQqManager.getInstance().shareMusic(context, audioStreamUrl, musicWebapgeUrl, title, description, thumbImage, listener);\nKotlin:\n1RQqManager.instance.shareMusic(context, audioStreamUrl, musicWebpageUrl, title, description, thumbImageUrl, callback)\n\n⚠️ 1. 在自定义 Bundle 包装分享音频参数的时候, QQShare.SHARE_TO_QQ_TARGET_URL 设置音频网页链接, QQShare.SHARE_TO_QQ_AUDIO_URL 设置音频流链.\n⚠️ 2. audioStreamUrl 请设置音频的音频流链接, 不要把音乐平台分享的音乐网链直接赋值在该字段上, 否则点击播放按钮是无法播放的, 音乐网链是放在 webpageUrl 字段上的.\n\n表现:\n\n应用分享:\nJava:\n1RQqManager.getInstance().shareApp(context, appUrl, title, description, thumbImage, listener);\nKotlin:\n1RQqManager.instance.shareApp(context, appUrl, title, description, thumbImageUrl, callback)\n点击消息对话框会自动跳转到「应用宝」对应 App 主页.\n分享网页到空间:\nJava:\n1RQqManager.getInstance().shareWebpageToZone(context, webapgeUrl, title, description, imageUrlList, listener);\nKotlin:\n1RQqManager.instance.shareWebpageToZone(context, webpageUrl, title, description, imageUrlList, callback)\n\n⚠️ 1. 这里的缩略图数组里面是图片的网络链接.\n⚠️ 2. 缩略图图片是以数组包装的, 但是仅仅会显示第一张, 也就是说目前的 SDK (3.3.3 版本) 是不具备网络多图分享的, 但腾讯已说明多网络图后面会完善和补全.\n\n表现:\n\n分享图片到空间:\nJava:\n1RQqManager.getInstance().publishImagesToZone(context, targetImages, description, listener);\nKotlin:\n1RQqManager.instance.publishImagesToZone(context, targetImages, description, callback)\ndescription 字段实际是失效的.\n表现:\n\n分享本地视频到空间:\nJava:\n1RQqManager.getInstance().publishVideoToZone(context, localVideoUrl, description, listener);\nKotlin:\n1RQqManager.instance.publishVideoToZone(context, localVideoUrl, description, callback)\n表现:\n\n微信\n准备\n分享需要注册平台, 微信开放平台, SDK 下载, 微信 SDK 支持 compile 集成, 分享 &amp; 收藏 API 调用说明.\n集成\na.\n在 Application 级 build.gradle 中配置:\n123dependencies &#123;    compile com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+&#125;\n或者\n123dependencies &#123;    compile com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+&#125;\n前者包括统计功能.\nb. 添加以下权限:\n12345&lt;uses-permission android:name=android.permission.INTERNET&gt;&lt;uses-permission android:name=android.permission.ACCESS_NETWORK_STATE&gt;&lt;uses-permission android:name=android.permission.ACCESS_WIFI_STATE&gt;&lt;uses-permission android:name=android.permission.READ_PHONE_STATE&gt;&lt;uses-permission android:name=android.permission.WRITE_EXTERNAL_STORAGE&gt;\nc. 当需要在分享完毕后接受微信的传值需要在你的包名相应目录下新建一个 wxapi 目录，并在该 wxapi 目录下新增一个 WXEntryActivity 类，该类继承自 Activity, 在 AndroidManifest.xml 的 &lt;application&gt; 节点下增加:\n1234&lt;activity    android:name=.wxapi.WXEntryActivity    android:exported=true&gt;\n接口及内部实现\na. 内部初始化 SDK\nJava:\n12IWXAPI mIwxapi = WXAPIFactory.createWXAPI(context, appId);mIwxapi.registerApp(appId);\nKotlin:\n12val mIWXApi = WXAPIFactory.createWXAPI(context, appId)mIWXApi.registerApp(appId)\n\n仅做分享功能的话, secret 字段无用.\n\nb. 分享\n微信分享的内容包装同样通过一个 RWechatHelper 进行单独处理, 对于文字、网页、图片、视频网链、小程序、文件的分享内容处理都很简单, 特别注意的就是对于音乐链的分享, 同 QQ 一样, 需要区别两个参数, 一个是音频流链, 一个是音频网页, 播放的是音频流, 点击背景进入的是音频网页:\nJava:\n123WXMusicObject obj = new WXMusicObject();obj.musicUrl = webpageUrl;obj.musicDataUrl = streamUrl;\nKotlin:\n123val obj : WXMusicObject = WXMusicObject()obj.musicUrl = webpageUrlobj.musicDataUrl = streamUrl\n在程序需要接受微信发送的请求的时候, 需要在 WXEntryActivity 中实现 IWXAPIEventHandler 接口，微信发送的请求将回调到 onReq 方法，发送到微信请求的响应结果将回调到 onResp 方法, 在 WXEntryActivity 中将接收到的 intent 及实现了 IWXAPIEventHandler 接口的对象传递给 IWXAPI 接口的 handleIntent 方法. 为了让 RWechatManager 处理结果, 在 RWechatManager 中封装了 onResp 方法.\n文字分享:\nJava:\n1RWechatManager.getInstance().shareText(context, description, scene, listener);\nKotlin:\n1RWechatManager.instance.shareText(context, description, scene, callback)\n表现(分享到好友):\n\n图片分享:\nJava:\n1RWechatManager.getInstance().shareImage(context, targetImage, scene, listener);\nKotlin:\n1RWechatManager.instance.shareImage(context, targetImage, scene, callback)\n\n⚠️ 图片过大无法调起微信客户端分享.\n\n表现(分享到好友):\n\n网页分享:\nJava:\n1RWechatManager.getInstance().shareWebpage(context, webapgeUrl, title, description, thumbImage, scene, listener);\nKotlin:\n1RWechatManager.instance.shareWebpage(context, webpageUrl, title, description, thumbImage, scene, callback)\n\n⚠️ 1. thumbImage 字段的缩略图大小不能超过 32 Kb, 但实际测试 100 Kb 左右也是完全可行的, 但一定不能过大.\n⚠️ 2. Android  对于缩略图的处理相对友好很多, 对于 iOS 无法分享的过大的缩略图数据一般情况下 Android 都能成功启动微信客户端并且成功分享(亲测).\n⚠️ 3. 在缩略图没有符合规范的时候, 即使成功分享在 iOS 端也会出现缩略图不显示的情况, Android 几乎都会显示.\n\n表现(分享到好友):\n\n视频链分享:\n实质就是网页的分享, 在此不作代码示例.\n音频链分享:\nJava:\n1RWechatManager.getInstance().shareMusic(context, audioStreamUrl, title, description, thumbImage, musicWebapgeUrl, scene, listener);\nKotlin:\n1RWechatManager.instance.shareMusic(context, audioStreamUrl, title, description, thumbImage, musicWebapgeUrl, scene, callback)\n表现(分享到好友):\n\n小程序分享:\nJava:\n1RWechatManager.getInstance().shareMiniProgram(context, userName, path, MiniProgramType, webapgeUrl, title, description, thumbImage, scene, listener);\nKotlin:\n1RWechatManager.instance.shareMiniProgram(context, userName, path, MINIPROGRAM_TYPE, webpageUrl,title, description, thumbImage, scene, callback)\n\n⚠️ 1. demo 中笔者并没有编写小程序, 仅仅依照微信的 SDK 进行了参数的设置, 所以无法分享, 但具体的参数设置形式在 demo 中明确标明.\n⚠️ 2. 小程序分三种类型, type 字段分: 发布、预览以及体验三个版本.\n\n文件分享:\nJava:\n1RWechatManager.getInstance().shareFile(context, localFileUrl, title, thumbImage, scene, listener);\nKotlin:\n1RWechatManager.instance.shareFile(context, localFileUrl, title, thumbImage, scene, callback)\n\n⚠️ 1. 视频文件无法打开, 需要别的应用支持, 图片和普通文档可以打开.\n⚠️ 2. 文件分享不支持分享到朋友圈.\n⚠️ 3. 在设置缩略图的情况下, iOS 端的对话框是不显示缩略图的, 但是 Android 可以, 但也仅限于发送方能看见.\n\n表现(分享视频到微信好友):\n\n\n新浪\n准备\n分享需要注册平台, 新浪开放平台, SDK 下载, 新浪 SDK 支持 compile 集成, Android 接口调用文档.\n集成\na.\n在 Project 级 build.gradle 中配置:\n1234567allprojects &#123;    repositories &#123;        google()        jcenter()        maven &#123; url https:dl.bintray.comthelasterstarmaven &#125;    &#125;&#125;\n在 Application 级 build.gradle 中配置:\n123dependencies &#123;    compile com.sina.weibo.sdk:core:4.3.0:openDefaultRelease@aar&#125;\n接口及内部实现\na. 内部初始化 SDK\nJava:\n123WbSdk.install(context, new AuthInfo(context, key, redirectUrl, scope));WbShareHandler handler = new WbShareHandler((Activity) context);handler.registerApp();\nKotlin:\n123WbSdk.install(context, AuthInfo(context, key, redirectUrl, scope))val handler = WbShareHandler(context as Activity)handler.registerApp()\n\n仅做分享的话, secret 字段无用.\n\nb. 分享\n在 demo 中, 发布微博和发布照片视频到「微博故事」笔者拆分到 RSinaWeiboActivity 和RSinaWeiboStoryActivity 中分别处理, 避免稍微麻烦的判断.\n新浪分享内容模型都继承自 BaseMediaObject: TextObject、MultiImageObject、WebpageObject、VideoSourceObject、TextObject 设置对应属性然后通过 WeiboMultiMessage 发送分享请求消息体, 值得一提的是, 在分享网络链接时候, 赋值到消息体的属性为 mediaObject.\n⚠️ 在进行本地视频分享的时候一定一定要先对消息体进行文字分享模型赋值, 否则无论如何都无法分享.\n例 (Java):\n1234✅WeiboMultiMessage message = new WeiboMultiMessage();message.textObject = textObj; a TextObject instancemessage.videoSourceObject = localVideoObj;\n123❌WeiboMultiMessage message = new WeiboMultiMessage();message.videoSourceObject = localVideoObj;\n文字分享:\nJava:\n1RSinaWeiboManager.getInstance().shareText(context, text, listener);\nKotlin:\n1RSinaWeiboManager.instance.shareText(context, text, callback)\n表现:\n\n图片分享:\nJava:\n1RSinaWeiboManager.getInstance().sharePhoto(context, targetImages, description, isToStory(true or false), listener);\nKotlin:\n1RSinaWeiboManager.instance.sharePhoto(context, targetImages, description, isToStory(true or false), callback)\n为统一接口, 图片用数组包装; 分享到「微博故事」功能中 descripiton 字段会失效.\n\n⚠️ 1. 开启「分享到微博故事」功能图片只能传一张; 多张图片分享的情况下「分享到微博故事」的功能必须关闭!\n⚠️ 2. 图片单张不能超过 10 MB, 最多 9 张图片.\n⚠️ 3. 在分享图片的时候最好提前打开微博客户端, 否则会很慢, 或者压根不调起客户端.\n\n表现:\n分享到微博:\n\n分享到「微博故事」:\n\n本地视频分享:\nJava:\n1RSinaWeiboManager.getInstance().shareLocalVideo(context, localVideoUrl, description, isToStory(true or false), listener);\nKotlin:\n1RSinaWeiboManager.instance.shareLocalVideo(context, localVideoUrl, description, isToStory(true or false), callback)\n表现(分享到微博):\n\n表现(分享到「微博故事」):\n\n网页分享:\nJava:\n1RSinaWeiboManager.getInstance().shareWebpage(context, webapgeUrl, title, description, thumbImage, listener);\nKotlin:\n1RSinaWeiboManager.instance.shareWebpage(context, webpageUrl, title, description, thumbImage,callback)\n表现:\n\n\n⚠️ 1. 网页 thumbImage 字段的缩略图数据不能大于 550 Kb (新浪的 SDK 控制的很严格).\n⚠️ 2. 在这里表现和 iOS 略有不同.\n\nFacebook\n准备\n分享需要注册平台, Facebook 开发者主页, Facebook SDK 支持 compile 集成, 分享接口调用说明.\n集成\na.\n在 Project 级 build.gradle 中配置:\n1234567buildscript &#123;    repositories &#123;        google()        jcenter()        mavenCentral()    &#125;&#125;\n在 Application 级 build.gradle 中配置:\n123dependencies &#123;    implementation com.facebook.android:facebook-share:4.34.0&#125;\nb. 在 AndroidManifest.xml 的 &lt;application&gt; 节点下增加:\n1234567891011121314151617&lt;meta-data android:name=com.facebook.sdk.ApplicationId            android:value=@stringfacebook_app_id&gt;&lt;provider android:authorities=com.facebook.app.FacebookContentProviderYOURAPPID          android:name=com.facebook.FacebookContentProvider          android:exported=true &gt;&lt;activity android:name=com.facebook.CustomTabActivity    android:exported=true&gt;    &lt;intent-filter&gt;        &lt;action android:name=android.intent.action.VIEW &gt;        &lt;category android:name=android.intent.category.DEFAULT &gt;        &lt;category android:name=android.intent.category.BROWSABLE &gt;        &lt;data android:scheme=fbYOURAPPID &gt;    &lt;intent-filter&gt;&lt;activity&gt;\n接口调用及内部实现\na. 内部初始化 SDK\nFacebook 分享在配置 AndroidManifest.xml 后无需代码代码初始化.\nb. 分享\n参数的包装, 借助工具类 RFacebookHelper 来处理, Facebook 已经封装好了各个类型的分享内容载体 (SharePhotoContent、ShareVideoContent ...), 对应设置属性值就可以; 对于图片的分享, 和新浪的图片分享思路相同, 即: 无论是单张还是多图, 一概通过数组包装传递给 RFacebookHelper, 然后它自行处理.\n网页分享:\nJava:\n1RFacebookManager.getInstance().shareWebpage(context, webapgeUrl, description, hashTag, mode , listener);\nKotlin:\n1RFacebookManager.instance.shareWebpage(context, webpageUrl, description, hashTag, mode, callback)\nFacebook 的 SDK 在迭代的过程中, 舍弃了很多字段, 分享参数不如新浪那样多样, 但是其分享的表现形式却比国内的要友好很多, 特别是在网页分享这块体现的更加明显, 值得注意的是, 非网页形式的分享回调无效, 努力地在 Github、Stack Overflow 和 Facebook Developer 论坛找答案但都没有找到解决办法, 根据 postId 的判断分享结果状态的方法早已失效, 无论是 Android 还是 iOS 端, 目前都没办法.\n\n⚠️ hashTag (话题) 的表现形式不同于国内, 新浪的话题格式: #话题#, 两个 # 之间一切内容都能成为话题, 而 Twitter、Instagram、Facebook 的格式: #话题, 话题内容词组之间不能有任何符号且必须连在一起.\n\n表现:\n客户端形式的分享(无回调):\n\niOS 端是跳转到 Facebook 客户端分享, 且在通过客户端分享的过程中, quote 字段已经丢失; 且 Android 通过客户端分享需要提前打开 Facebook 客户端, 否则无法弹出分享对话框, 测试过美图秀秀的图片分享, 也是一样, 需要提前打开客户端.\n网页形式的分享(有回调):\n\n图片分享:\nJava:\n1RFacebookManager.getInstance().sharePhoto(context, targetImages);\nKotlin:\n1RFacebookManager.instance.sharePhoto(context, targetImages)\n表现:\n\n本地视频分享:\nJava:\n1RFacebookManager.getInstance().shareLocalVideo(context, localVideoUrl);\nKotlin:\n1RFacebookManager.instance.shareLocalVideo(context, localVideoUrl)\n表现:\n\nc. 获取散列\nRFacebookManager 提供了获取散列的方法.\nTwitter\n准备\n分享需要注册平台, Twitter 开发者主页, 注册应用主页, Twitter SDK 支持 compile 集成, 分享接口调用说明.\n⚠️: Twitter SDK 将于 20181031 后不再进行维护, 但是不影响后续使用, 需自行维护, Twitter 产品经理 Neil Shah 对 Twitter SDK 放弃维护迭代的声明博客.\n集成\na. 在 Project 级 build.gradle 中配置:\n123456allprojects &#123;    repositories &#123;        google()        jcenter()    &#125;&#125;\n在 Application 级 build.gradle 中配置:\n1234dependencies &#123;    implementation com.twitter.sdk.android:tweet-composer:3.1.1    implementation com.twitter.sdk.android:twitter-core:3.1.1&#125;\n接口调用及内部实现\na. 内部初始化 SDK\nJava:\n123456TwitterConfig config = new TwitterConfig.Builder(context)                .logger(new DefaultLogger(Log.DEBUG))                .twitterAuthConfig(new TwitterAuthConfig(key, secret))                .debug(true)                .build();Twitter.initialize(config);\nKotlin:\n123456val config = TwitterConfig.Builder(context)                .logger(DefaultLogger(Log.DEBUG))                .twitterAuthConfig(TwitterAuthConfig(key, secret))                .debug(true)                .build()Twitter.initialize(config)\nb. 授权 Twitter 客户端\n与其他平台分享不同的是, Twitter 在进行发推(分享)的时候会先进行检测本地的 activeSession 的标记判断是否登录(授权)过, 所以在进行发推的时候需要进行这一步的判断, 在未登录的情况下需进行授权, 在此使用 RTwitterAuthHelper 进行处理, 登录(授权监听接口以及 callback):\nJava:\n1234public interface RTwitterAuthCallback &#123;    public abstract void onComplete();    public abstract void onFail(String errorInfo);&#125;\nKotlin:\n1internal typealias RTwitterAuthCallback = ((state : Int) -&gt; Unit)\nKotlin 的 callback state 包括成功失败两种结果.\n判断是否登录过:\nJava:\n1RTwitterAuthHelper.getInstance().hasLogged()\nKotlin:\n1RTwitterAuthHelper.instance.hasLogged\n登录授权:\nJava:\n12345678910RTwitterAuthHelper.getInstance().authorizeTwitter(context, new RTwitterAuthCallback() &#123;    @Override    public void onComplete() &#123;         ...    &#125;    @Override    public void onFail(String errorInfo) &#123;        ...                    &#125;&#125;);\nKotlin:\n12345678910RTwitterAuthHelper.instance.authorizeTwitter(context) &#123; state -&gt;    when (state) &#123;        1 -&gt; &#123;             ...        &#125;        0 -&gt; &#123;             ...             &#125;    &#125;&#125;\n这一步目前的情况就是把 Twitter SDK 提供的授权方法重新包装写了遍, 但是考虑到未来可能用到 session 和 token 等信息并处理, 所以单独写了类讲授权和分享隔离.\nc. 分享\n在本人写的 demo 中, 分享和登录授权是衔接的, 即: 若未登录过 -&gt; 登录授权 -&gt; 分享.\nTwitter 能分享的内容相对较少, 所以关于文字、网页、图片的分享, 统一到一个分享接口里, 三者不能同时为空.\n另, Twitter Android 分享包括两种模式: 直接构建 Intent 分享和跳转 Twitter 客户端分享, 前者有回调(Demo 中注册 RTwitterTweetResultReciver 监听回调), 后者无回调且支持 hashTag.\nJava:\n1RTwitterManager.getInstance().share(context, webapgeUrl, description, targetImage, hashTag, mode, listener);\nKotlin:\n1RTwitterManager.instance.share(context, webpageUrl, description, targetImage, hashTag, mode, callback)\n\n⚠️ 测试多次发推内容不要重复, 否则会分享失败.\n\n表现:\n应用内分享(有回调):\n\n跳转 Twitter 客户端分享(无回调):\n\nInstagram\n准备\n分享无需注册平台无需 SDK, Instagram 开发者主页, 构建 Intent 方式分享.\n接口调用及内部实现\n分享\nIntent 构建(以 Java 为例):\n图片:\n12345Intent intent = new Intent(Intent.ACTION_SEND);intent.setType(image*);intent.putExtra(Intent.EXTRA_STREAM, targetImageUrl);intent.setPackage(com.instagram.android);context.startActivity(intent);\n图片分享:\nJava:\n1RInstagramManager.getInstance().shareImage(context, targetImage);\nKotlin:\n1RInstagramManager.instance.shareImage(context, targetImage)\n表现:\n\n本地视频:\n12345Intent intent = new Intent(Intent.ACTION_SEND);intent.setType(video*);intent.putExtra(Intent.EXTRA_STREAM, localVideoUrl);intent.setPackage(com.instagram.android);context.startActivity(intent);\n本地视频分享:\nJava:\n1RInstagramManager.getInstance().shareVideo(context, localVideoUrl);\nKotlin:\n1RInstagramManager.instance.shareVideo(context, localVideoUrl)\n表现:\n\nTumblr\n准备\n分享需要注册平台, Tumblr 开发者主页, 注册应用主页, Tumblr SDK 支持 compile 集成, 分享接口调用说明.\n集成\na. 此 Demo 中是手动集成的 6.1.0 版本的 SDK.\n⚠️: 一定是这个版本的, 最新版本的 SDK 我没有找到分享的接口.\n接口调用及内部实现\na. 内部初始化 SDK\n123FlurryAgent.setLogEnabled(true);FlurryAgent.init(context, flurryKey);TumblrShare.setOAuthConfig(key, secret);\n⚠️ 在 iOS 端初始化 SDK 仅需要 key 和 secret 两个参数.\nb. 分享\nTumblr 分享体只包括图片和文字两种, 并且图片还是网络图片的链接, 并不能分享本地图片, 所以 Tumblr 的局限性很大, 这两种分享体的模型通过 SDK 中 PhotoPost 和 TextPost 来构建;\nTumblr 分享是通过当前界面弹出对话框分享的, 和 Twitter 类似, 所以不需要判断 Tumblr 程序是否安装;\nTumblr 的分享流程是: 登录 -&gt; 分享, 但是登录的逻辑不需要在代码中实现, 他会自动呈现浏览器的登录界面.\n文字分享:\nJava:\n1RTumblrManager.getInstance().shareText(context, description, title, webapgeUrl, listener);\nKotlin:\n1RTumblrManager.instance.shareText(context, description, title, webpageUrl, callback)\n表现:\n\n图片链接分享:\nJava:\n1RTumblrManager.getInstance().shareImage(context, targetImageUrl, description, webapgeUrl, listener);\nKotlin:\n1RTumblrManager.instance.shareImage(context, targetImageUrl, description, webpageUrl, callback )\n表现:\n\nPinterest\n集成\nAndroid 端无需集成 SDK, 仅通过 Intent 方式就可以分享, 但是 iOS 需要.\nb. 分享\nPinterest 只能分享图片链接.\nIntent 构建(以 Java 为例):\n12345Intent intent = new Intent(Intent.ACTION_SEND);intent.setPackage(com.pinterest);intent.putExtra(Intent.EXTRA_STREAM, Uri.parse(targetImageUrl));intent.setType(**);context.startActivity(intent);\n图片链接分享:\nJava:\n1RPinterestManager.getInstance().shareImage(context, targetImageUrl);\nKotlin:\n1RPinterestManager.instance.shareImage(context, targetImageUrl)\n表现:\n\nLine\n集成\n无需集成 SDK, 仅通过 Intent 方式就可以分享.\nb. 分享\nIntent 构建(以 Java 为例):\n文字：\n123456Intent intent = new Intent();intent.setAction(Intent.ACTION_SEND);intent.putExtra(Intent.EXTRA_TEXT, text);intent.setType(text*);intent.setPackage(jp.naver.line.android);context.startActivity(intent);\n文字分享:\nJava:\n1RLineManager.getInstance().shareText(context, text);\nKotlin:\n1RLineManager.instance.share(context, text)\n表现:\n\n图片:\n12345Intent intent = new Intent(Intent.ACTION_SEND);intent.setType(image*);intent.putExtra(Intent.EXTRA_STREAM, targetImageUrl);intent.setPackage(jp.naver.line.android);context.startActivity(intent);\n图片分享:\nJava:\n1RLineManager.getInstance().shareImage(context, targetImage);\nKotlin:\n1RLineManager.instance.share(context, targetImage)\n表现:\n\nWhatsApp\n准备\n分享无需注册平台.\nAndroid 端无需集成 SDK, 仅通过 Intent 方式就可以分享, 但是 iOS 需要.\nb. 分享\nWhatsApp 支持同时分享文字和图片, iOS 端不可以.\nIntent 构建(以 Java 为例):\n12345678Intent intent = new Intent();intent.setAction(Intent.ACTION_SEND);intent.putExtra(Intent.EXTRA_TEXT, description);intent.setType(textplain);intent.putExtra(Intent.EXTRA_STREAM, targetImageUrl);intent.setType(imagejpeg);intent.setPackage(com.whatsapp);context.startActivity(intent);\n图文分享:\nJava:\n1RWhatsAppManager.getInstance().share(context, targetImage, description);\nKotlin:\n1RWhatsAppManager.instance.share(context, targetImage, description)\n表现:\n\nGooglePlus\n准备\n需要注册平台, Google Plus 开发者主页\n, 创建流程.\n集成\n需要 Google Service 的支持, 在 Application 级 build.gradle 中配置:\n123dependencies &#123;    implementation com.google.android.gms:play-services-plus:15.0.1&#125;\n接口调用及内部实现\nGoogle Plus 分享只支持分享网页,  通过 PlusShare.Builder 来构建网页分享模型, Java 为例:\n12345Intent shareIntent = new PlusShare.Builder(context)                .setType(textplain)                .setText(text)                .setContentUrl(Uri.parse(webpageUrl)                .getIntent();\n分享网页:\nJava:\n1RGooglePlusManager.getInstance().share(context, webapgeUrl, description);\nKotlin:\n1RGooglePlusManager.instance.share(context, webpageUrl, description)\n表现:\n\n统一分享接口\n缺陷\n缺陷说在前面, 其实本来不打算统一接口的.\n\n主分享 Manager 和子平台分享 Manager 存在耦和(没有参考 ShareSDK 的 jar 包方式去做);\n分享接口优化受限制, 由于前面的平台分享对比表格可知, 国外的平台分享很多都没有回调, 而国内的平台分享内容又存在多种形式, 无法实现高度统一;\n添加平台没有做去重处理, 造成不必要的开销;\n\n类图\n\n\nRShareManger: 主分享 Manager, 子平台 Manager 的初始化、分享、应用跳转和一些其他操作都在此进行;\nRImageContent、RVideoContent、RTextContent、RWebpageContent 为四种对应分享内容模型.\n\n详细设计\n分享频道\n以 Java 为例, 在 RShareManager 种定义了分享通道枚举:\n123456789101112131415161718192021enum class ShareChannel &#123;    QQSession,    QQFavorite,    QQDataLine,    QZone,    WechatSession,    WechatFavorite,    WechatTimeline,    FacebookClient,    FacebookBroswer,    TwitterInnerApp,    TwitterClient,    SinaWeibo,    SinaWeiboStory,    Line,    Instagram,    Tumblr,    Pinterest,    GooglePlus,    WhatsApp&#125;\n接口\n构建分享模型\n以 RImageContent 为例:\nJava:\n123RImageContent content = new RImageContent.Builder(targetImage, targetImageUrl)                  ...                .build();\nKotlin:\n123val content : RImageContent = RImageContent().apply &#123;              ...&#125;\n分享：\n以分享 RImageContent 为例:\nJava:\n12345678910111213141516RShareManager.getInstance().shareImage(context, content, channel, new RShareListener() &#123;            @Override            public void onComplete(RSharePlatform.Platform platform) &#123;             ...              &#125;            @Override            public void onFail(RSharePlatform.Platform platform, String errorInfo) &#123;             ...            &#125;            @Override            public void onCancel(RSharePlatform.Platform platform) &#123;             ...            &#125;        &#125;);\nKotlin:\n123 RShareManager.instance.shareImage(context, content, channel) &#123; platform, state, errorInfo -&gt;            ...&#125;\n源码\nJava 版本源码、 Kotlin 版本源码, 还在学习中, 请多指教.\n","tags":["share","social","Android","Java","Kotlin"],"path":"2018/08/29/2018-08-29/","external_link":""},{"title":"「RSHARE」 一键分享 iOS 版","date":"2018-08-28T09:05:43.000Z","content":"因为公司的项目里集成了一键分享的这个模块, 而在我设计的时候发现国内的官方文档和提供的 Sample 有混乱和容易混淆的地方, 而且除了普通的网页、图片、文字分享到各大 Social 平台以外, 对于视频、文件和其他内容的分享 Demo 在百度或者 Google 几乎搜不到. 自己也是踩了很多坑才把很多问题解决.\n测试设备\niPhone 7 Plus, iOS 11.4.1.\n支持平台\nRSHARE 这个 Demo 中支持: 微信、QQ、新浪微博、Facebook、GooglePlus(Google +)、Twitter、WhatsApp、Line、Tumblr、Instagram、Pinterest 11 个 Social 平台.\n平台差异\n主要罗列了常用的 5 个分享内容的对比菜单(网页、文字、图片、本地视频、文件).\n注意菜单内字母以及菜单后面对应字母的注释⚠️\n\n\n\n❤️\nQQ\n微信\n微博\nFacebook\nTwitter\nInstagram\nWhatsApp\nLine\nTumblr\nPinterest\nGoogle+\n\n\n\n\n网页\n✓a\n✓\n✓\n✓b\n✓\n✗\n✓\n✓\n✓\n✗\n✓\n\n\n文字\n✓c\n✓\n✓\n✗\n✓\n✗\n✓\n✓\n✓\n✗\n✗\n\n\n图片\n✓\n✓\n✓\n✓\n✓\n✓\n✓\n✓\n✓d\n✓d\n✗\n\n\n视频\n?e\n✗\n✓\n✓\n✗\n✓\n✗\n✗\n✗\n✗\n✗\n\n\n文件\n✓\n✓\n✗\n✗\n✗\n✗\n✗\n✗\n✗\n✗\n✗\n\n\n\na. QQ 虽支持网页分享, 但是不允许带着网页的 description 字段, 且分享到 QQ 空间只支持通过文字分享, 这和 Android 表现不同;\nb. Facebook 的网页分享支持 hashtag;\nc. iOS 端分享文字到 QQ 客户端是可行的, 但是 Android 端不允许, 其实 QQ 的分享目地就是让用户自行输入有价值、有意义的文字信息;\nd. Pinterest 和 Tumblr 虽支持图片分享, 但仅仅支持分享图片的 URL, 它会自行解析并显示;\ne. QQ 客户端分享分两类: 1 好友、收藏、数据线(我的电脑)分享; 2 QQ 空间分享. 本地视频的分享只支持 QQ 空间分享.\n\n\n对比列表得知, 国内的平台分享内容是最丰富的, 但是存在一个主要的问题(主要是 QQ), iOS 和 Android 双端的接口以及实现的功能也并不统一(后面的部分会具体说); 微信双端当分享的图片过大的时候的表现也有不统一的时候, 其余都很完善; 新浪的表现是最统一的, 且没有过多限制; 国内的平台分享最让人头疼的就是官方的 Sample 很混乱, 但是在实践代码的时候还是要以官方为主.\n国外的文档和 Sample 很明了且注释详细, 但也存在双端不统一的情况, Twitter 的双端表现就不一样(后面细说), 但是国外的平台分享几乎没有回调, Facebook 的回调只有 Feed 形式的分享才有效, Instagram、Line、Google+这些是没有 SDK 的, 仅仅是通过打开 Application URL scheme 来分享.\n\n\n分享总体设计\n大概的分享逻辑如下:\n\niOS 的分享是参照各大平台的分享逻辑得到比较统一思路, 即: 先判断是否安装对应应用, 然后初始化 SDK 与官方平台连接, 然后包装分享参数进行分享, 最后处理分享回调.\n\n\n有些平台不存在 SDK, 所以直接判断是否平台安装然后包装分享参数进行分享;\nTumblr 比较特殊, 有 SDK 但是不需要判断应用是否安装就可以分享, Twitter 也如此, 具体情况在 Twitter 的部分说明;\nSDK 的初始化, 统一函数名字为 sdkInitialize, Key、Secret以及AppID等信息在注释中有标明.\n\n\n详细逻辑\n关于各个平台的开发者主页和文档信息以这里为主, 代码注释的可能不准确.\n平台分享都是通过单例模式实现.\n在手动导入框架的时候尽量, 放在项目根目录下然后通过下图的方式导入:\n\n\n在项目级 Framework 目录下右键执行 Add Files to &quot;name&quot;.\n\n子平台分享完毕返回到本应用的接口再封装 Objective-C 版本用的是实例方法, Swift 版本使用的是类方法.\n基类\n子平台 Manager 都是继承自RShare, 这个类中定义了分享 Mode(代码注释中有标明, iOS 中使用范围较小)、分享结果 ShareResult (成功、取消、失败)以及最重要的回调.\n回调:\nObjective-C:\n1typedef void (^RShareCompletion)(RShareSDKPlatform platform, ShareResult result, NSString* _Nullable errorInfo);\nSwift:\n1typealias RShareCompletion = (_ paltform : RShareSDKPlatform,_ result : ShareResult,_ errorInfo : String?) -&gt; Void\nMode(仅对 Facebook、Twitter、Instagram 有效, Android 亦然):\nObjective-C:\n12345678910111213141516171819202122232425262728293031323334typedef NS_ENUM(NSInteger, Mode) &#123;    **     @Displays 优先选择原生应用分享, 原生应用未安装的情况可能跳转内置 WebView 或者 Safari 进行分享.     *    ShareModeAutomatic,    **     @Displays 原生应用分享.     *    ShareModeNative,    **     @Displays 应用内置 UIWebView 分享.     *    ShareModeWeb,    **     @Displays the dialog in the iOS integrated share sheet, 仅对 Facebook 分享有效.     *    ShareModeSheet,    **     @Displays 跳转至 Safari 分享, 仅对 Facebook 分享有效.     *    ShareModeBrowser,    **     @Displays 跳转至 Safari 进行 Feed 形式的分享, 仅对 Facebook 分享有效.     *    ShareModeFeedBrowser,    **     @Displays 应用内置 UIWebView 的 Feed 形式分享, 仅对 Facebook 分享有效.     *    ShareModeFeed,    **     @Displays iOS 的系统分享.     *    ShareModeSystem&#125;;\nQQ\n准备\n分享需要注册平台, 腾讯开发者主页, SDK 下载, QQ SDK 目前不支持 pod 安装, iOS API 调用说明文档.\n集成\na. TencentOpenAPI.framework导入项目中;\nb. 添加系统依赖Security.framework、SystemConfiguration.framework、CoreGraphic.framework、libsqilte3.0.tbd、CoreTelephony.framework、libz.tbd.\nc. 设置 The Other Flags 为 -ObjC.\nd. 在info.plist文件的CFBundleURLTypes中添加:\n1234&lt;key&gt;CFBundleURLSchemes&lt;key&gt;&lt;array&gt;    &lt;string&gt;tencentYOURAPPID&lt;string&gt;&lt;array&gt;\ne. 添加以下至白名单:\n12345678910111213141516171819202122&lt;string&gt;mqq&lt;string&gt;&lt;string&gt;mqqapi&lt;string&gt;&lt;string&gt;mqqwpa&lt;string&gt;&lt;string&gt;mqqbrowser&lt;string&gt;&lt;string&gt;mttbrowser&lt;string&gt;&lt;string&gt;mqqOpensdkSSoLogin&lt;string&gt;&lt;string&gt;mqqopensdkapiV2&lt;string&gt;&lt;string&gt;mqqopensdkapiV3&lt;string&gt;&lt;string&gt;mqqopensdkapiV4&lt;string&gt;&lt;string&gt;wtloginmqq2&lt;string&gt;&lt;string&gt;mqzone&lt;string&gt;&lt;string&gt;mqzoneopensdk&lt;string&gt;&lt;string&gt;mqzoneopensdkapi&lt;string&gt;&lt;string&gt;mqzoneopensdkapi19&lt;string&gt;&lt;string&gt;mqzoneopensdkapiV2&lt;string&gt;&lt;string&gt;mqqapiwallet&lt;string&gt;&lt;string&gt;mqqopensdkfriend&lt;string&gt;&lt;string&gt;mqqopensdkdataline&lt;string&gt;&lt;string&gt;mqqgamebindinggroup&lt;string&gt;&lt;string&gt;mqqopensdkgrouptribeshare&lt;string&gt;&lt;string&gt;tencentapi.qq.reqContent&lt;string&gt;&lt;string&gt;tencentapi.qzone.reqContent&lt;string&gt;\nf. Swift 语言集成需要 Objective-C - Swift 桥接文件.\n接口调用及内部实现\na. 初始化 SDK\nObjective-C:\n1[[RQqManager shared] sdkInitializeByAppID:yourAppId appKey:yourAppKey];\nSwift:\n1RQqManager.shared.sdkInitialize(appID: yourAppId, appKey: yourAppKey)\n内部实现 (Objective-C):\n1[[TencentOAuth alloc]initWithAppId:appID andDelegate:self];\n\n由此看出, 其实仅仅是用作分享功能的话, 是不需要 appKey 这个字段的.\n\nb. 分享\n对于分享内容的包装, 通过建立 RQqHelper 来实现分享内容的处理和平台 Manager 的分隔, 这样有利于逻辑的处理, 结构明显, 代码可控.\n关于参数包装的细节, 没什么好细说的, QQ 提供的接口简单明了(Android 不是这样).\n另, 除在 QQApiInterfaceDelegate 代理函数 - (void)onResp:(QQBaseResp *)resp 中处理分享回调外, 在发起手 Q 分享请求的接口 [QQApiInterface sendReq: request] 返回的 QQApiSendResultCode 做了分享失败的请求码处理, Objective-C 中单独建立的处理函数 - (void)handleResultCode:(QQApiSendResultCode)code, Swift 则直接在 resultCode 的 set 方法处理.\n分享到 QQ 的接口中 scene 字段细分到 QQ 好友、我的收藏、数据线(我的电脑), 但 Android 中不支持直接打开‘我的收藏’和‘数据线(我的电脑)’面板, 须自行选择.\n文字分享:\nObjective-C:\n1[[RQqManager shared] shareTextToQQ:text scene:scene completion:completion];\nSwift:\n1RQqManager.shared.share(text: text, scene: scene, completion: completion)\n表现(QQ 好友分享):\n\n图片分享:\nObjective-C:\n1[[RQqManager shared] shareImageToQQ:targetImage title:title description:description scene:scene completion:completion];\nSwift:\n1RQqManager.shared.share(image: targetImage, title: title, description: description, scene: scene, completion: completion)\n表现(QQ 好友分享且分享面板样式):\n\n网页分享:\nObjective-C:\n1[[RQqManager shared] shareWebpageToQQWithURL:webpageURL title:title description:description thumbImage:image scene:scene completion:completion];\nSwift:\n1RQqManager.shared.share(webpageURL: webpageURL, title: title, description: description, thumbImage: image, scene: scene, completion: completion)\n表现(QQ 好友分享):\n\n视频链分享:\n实质就是网页的分享, 在此不作代码示例.\n音频链分享:\n大致和网页的分享相同, 但是多了一个 streamURL 的字段.\nObjective-C:\n1[[RQqManager shared] shareAudioToQQWithStreamURL:audioStreamURL title:title description:description thumbImage:image webpageURL:webpageURL scene:scene completion: completion];\nSwift:\n1RQqManager.shared.share(audioStreamURL: audioStreamURL, title: title, description: description, thumbImage: image, webpageURL: webpageURL, scene: scene, completion: completion)\n\n⚠️ 1.Tencent.framework 中 QQApiVideoObject的flashURL 属性设置音频流.\n⚠️ 2. audioStreamURL 请设置音频的音频流链接, 不要把音乐平台分享的音乐网链直接赋值在该字段上, 否则点击播放按钮是无法播放的, 音乐网链是放在 webpageURL 字段上的.\n\n表现(QQ 好友分享):\n\n文件分享:\nObjective-C:\n1[[RQqManager shared] shareFileToQQWithFileData:fileData fileName:fileName title:title description:description thumbImage:image completion: completion];\nSwift:\n1RQqManager.shared.share(fileData: filedata, fileName: fileName, title: title, description: description, thumbImage: image, compeltion: completion)\n\n⚠️ 1. fileName 字段设置方式是: ‘文件名’+‘.扩展名’, 形如:HelloWorld.doc, 这样 QQ 系统内部能够解析并且可以友好的展示分享内容, 经测试大部分常规的文件都能友好的展示.\n⚠️ 2. 文件分享只支持 QQ 客户端数据线(我的电脑)分享, 并且 Android 端无法分享文件, 也或许其实是可以分享文件只不过本人技拙没发现实现方法罢.\n\n表现(以视频为例):\n\n\n分享文字到 QQ 空间:\nObjective-C:\n1[[RQqManager shared] shareTextToQZone:description completion: completion];\nSwift:\n1RQqManager.shared.share(text: description, completion: completion)\n\n⚠️ Android 端不支持纯文字分享到 QQ 空间, 且 iOS 端不支持网页分享到 QQ 空间, 除非把字符串形式的网链通过文字的方式分享, 这是可行的.\n\n表现:\n\n分享图片到 QQ 空间:\nObjective-C:\n1[[RQqManager shared] shareImagesToQZone: targetImageArray  description:description completion: completion];\nSwift:\n1RQqManager.shared.share(images: targetImageArray, description: description, completion: completion)\n\n⚠️ description 字段实际是失效的, 但不保证未来一定不用这个字段, 所以暂且保留这个字段.\n\n表现:\n\n分享本地视频到 QQ 空间:\nObjective-C:\n1[[RQqManager shared] shareVideoToQZoneWithAssetURL:videoAssetURL description:description completion: completion];\nSwift:\n1RQqManager.shared.share(videoAssetURL: videoAssetURL, description: description, completion: completion)\n\n⚠️ 1. description 字段实际是失效的.\n⚠️ 2. 本地视频 URL 为通过 UIImagePickerController 选择的媒体 info 的 UIImagePickerControllerReferenceURL 的值, 形如: assets-library:assetasset.MP4?id=8FF2F03F-DD84-41A5-A20C-B745E793C0DC&amp;ext=MP4\n\n表现:\n\nc. 返回本应用\nObjective-C:\n1[[RQqManager shared] application:app openURL:url options: options];\nSwift:\n1RQqManager.application(app, open: url, options : options)\n微信\n准备\n分享需要注册平台, 微信开放平台, SDK 下载, 微信 SDK 支持 pod 安装, 分享 &amp; 收藏 API 调用说明.\n集成\na. 手动: libWeChatSDK.a、WXApi.h、WXApiObject.h, 导入项目中;\npod 集成: pod WechatOpenSDK, 若出现:\n\nUse the $(inherited) flag, or\nRemove the build settings from the target.\n🔧解决方法(引自微信集成说明, 未亲自测试): 把工程 target 中的 build Setting 里面 PODS_ROOT 的值替换成 $(inherited), Other Linker Flags 中 -all_load 替换成 $(inherited).\n\nb. 添加系统依赖 SystemConfiguration.framework, libz.dylib, libsqlite3.0.dylib, libc++.dylib, Security.framework, CoreTelephony.framework, CFNetwork.framework.\nc. 手动集成的情况下, 需设置 The Other Flags 为 -ObjC.\nd. 在info.plist 文件的 CFBundleURLTypes 中添加:\n1234&lt;key&gt;CFBundleURLSchemes&lt;key&gt;&lt;array&gt;    &lt;string&gt;wxYOURAPPID&lt;string&gt;&lt;array&gt;\ne. 添加以下至白名单:\n12&lt;string&gt;weixin&lt;string&gt;&lt;string&gt;wechat&lt;string&gt;\nf. Swift 语言集成需要 Objective-C - Swift 桥接文件.\n接口调用及内部实现\na. 初始化 SDK\nObjective-C:\n1[[RWechatManager shared] sdkInitializeByAppID:appID appSecret:secret];\nSwift:\n1RWechatManager.shared.sdkInitialize(appID: appID, appSecret: secret)\n\n仅做分享功能的话, secret 字段无用.\n\n初始化内部实现略微有区别:\nObjective-C:\n123UInt64 typeFlag = MMAPP_SUPPORT_TEXT | MMAPP_SUPPORT_PICTURE | MMAPP_SUPPORT_VIDEO | MMAPP_SUPPORT_LOCATION | MMAPP_SUPPORT_AUDIO | MMAPP_SUPPORT_WEBPAGE; [WXApi registerAppSupportContentFlag:typeFlag];[WXApi registerApp:appID];\n\nObjective-C 中同时设置多个枚举值可以通过 | 来实现 option 的设置.\n\nSwift:\n123let typeFlag : TypeFlag = [.Text, .Picture, .Video, .Audio, .Webpage]WXApi.registerAppSupportContentFlag(typeFlag.rawValue)WXApi.registerApp(appID)\n\nSwift 中设置多个枚举值不可用 | 来实现, 想要达到这样的效果, 必须新建结构体并且实现 OptionSetType 协议, OptionSetType 改变了 Objective-C 中 NS_ENUM  NS_OPTIONS 的行为方式赋予可多选的能力.\n\nTypeFlag 的声明(没有写全, 但实际测试并不影响文件的分享):\n12345678910private struct TypeFlag : OptionSet &#123;        let rawValue: UInt64        static let Text = TypeFlag(rawValue: enAppSupportContentFlag.MMAPP_SUPPORT_TEXT.rawValue)    static let Picture = TypeFlag(rawValue: enAppSupportContentFlag.MMAPP_SUPPORT_PICTURE.rawValue)    static let Video = TypeFlag(rawValue: enAppSupportContentFlag.MMAPP_SUPPORT_VIDEO.rawValue)    static let Audio = TypeFlag(rawValue: enAppSupportContentFlag.MMAPP_SUPPORT_AUDIO.rawValue)    static let Webpage = TypeFlag(rawValue: enAppSupportContentFlag.MMAPP_SUPPORT_WEBPAGE.rawValue)     &#125;\nb. 分享\n微信分享的内容包装同样通过一个 RWechatHelper 进行单独处理, 对于文字、网页、图片、视频网链、小程序、文件的分享内容处理都很简单, 特别注意的就是对于音乐链的分享, 同 QQ 一样, 需要区别两个参数, 一个是音频流链, 一个是音频网页, 播放的是音频流, 点击背景进入的是音频网页.\nObjective-C:\n123WXMusicObject* obj = [WXMusicObject object];obj.musicDataUrl = musicURL;obj.musicUrl = webpageURL;\nSwift:\n123let obj = WXMusicObject()obj.musicUrl = audioStreamURLobj.musicUrl = webpageURL\n文字分享:\nObjective-C:\n1[[RWechatManager shared] shareText:text scene: scene completion: completion];\nSwift:\n1RWechatManager.shared.share(text: shareDescription, scene: scene, completion: shareCompletion)\n表现(分享到好友):\n\n图片分享:\nObjective-C:\n1[[RWechatManager shared] shareImage:targetImage scene: scene completion: completion];\nSwift:\n1RWechatManager.shared.share(image: targetImage, scene: scene, completion: completion)\n表现(分享到好友列表):\n\n网页分享:\nObjective-C:\n1[[RWechatManager shared] shareWebpageWithURL:webpageURL title:title description:description thumbImage:thumbImage scene: scene completion: completion];\nSwift:\n1RWechatManager.shared.share(webpageURL: webpageURL, title: title, description: description, thumbImage: thumbImage, scene: scene, completion: completion)\n\n⚠️ 1. thumbImage 字段的缩略图大小不能超过 32 Kb, 但实际测试 100 Kb 左右也是完全可行的, 但一定不能过大, 否则会出现:分享 N 次才能成功一次, 或者干脆无法调起微信的客户端进行分享.\n⚠️ 2. Android  对于缩略图的处理相对友好很多, 对于 iOS 无法分享的过大的缩略图数据一般情况下 Android 都能成功启动微信客户端并且成功分享(亲测).\n⚠️ 3. 在缩略图没有符合规范的时候, 即使成功分享在 iOS 端也会出现缩略图不显示的情况, Android 几乎都会显示.\n\n表现(分享到好友):\n\n视频链分享:\n实质就是网页的分享, 在此不作代码示例.\n音频链分享:\nObjective-C:\n1[[RWechatManager shared] shareMusicWithStreamURL: audioStreamURL webpageURL:audioWebpageURL title: title description: description thumbImage:image scene:scene completion: completion];\nSwift:\n1RWechatManager.shared.share(audioStreamURL: audioStreamURL, webpageURL: audioWebpageURL, title: title, description: description, thumbImage: thumbImage, scene: scene, completion: completion)\n\n⚠️ 注意 audioStreamURL 和 webpageURL 的区别, 前面有提及.\n\n表现(分享到微信好友):\n\n小程序分享:\nObjective-C:\n1[[RWechatManager shared] shareMiniProgramWithUserName:userName path:path type:type webpageURL:webpageURL title:title description:description thumbImage:image scene: scene completion: completion];\nSwift:\n1RWechatManager.shared.shareMiniProgram(userName: userName, path: path, type: type, webpageURL: webpageURL, title: title, description: description, thumbImage: thumbImage, scene: scene, completion: completion)\n\n⚠️ 1. demo 中笔者并没有编写小程序, 仅仅依照微信的 SDK 进行了参数的设置, 所以无法分享, 但具体的参数设置形式在 demo 中明确标明.\n⚠️ 2. 小程序分三种类型, type 字段分: 发布、预览以及体验三个版本.\n\n文件分享:\nObjective-C:\n1[[RWechatManager shared] shareFileWithData:fileData extension:fileExtensionName title:title thumbImage:image scene:scene completion: completion];\nSwift:\n1RWechatManager.shared.share(fileData: fileData, extensionName: fileExtensionName, title: title, thumbImage: thumbImage, scene: scene, completion: completion)\n对于体积稍大的图片、小体积视频、doc 文本、PDF 文件 都测试过, 可以正常分享, 且通过微信内部的解析可以显示.\n\n⚠️ 1. 必须设置文件的扩展名.\n⚠️ 2. 文件分享不支持分享到朋友圈.\n⚠️ 3. 在设置缩略图的情况下, iOS 端的对话框是不显示缩略图的, 但是 Android 可以, 但也仅限于发送方能看见.\n\n表现(分享视频到微信好友):\n\n\nc. 返回本应用\nObjective-C:\n1[[RWechatManager shared] application:app openURL:url options:options];\nSwift:\n1RWechatManager.application(app, open: url, options : options)\n新浪\n准备\n分享需要注册平台, 新浪开放平台, SDK 下载, 新浪 SDK 支持 pod 安装, iOS 接口调用文档.\n集成\na. 手动导入 WeiboSDK.h、 WBHttpRequest.h、libWeiboSDK.a 和 WeiboSDK.bundle 到项目中.\npod 集成: pod &quot;Weibo_SDK&quot;, :git =&gt; &quot;https:github.comsinaweibosdkweibo_ios_sdk.git&quot; (未实际测试过).\nb. 添加系统依赖QuartzCore.framework、SystemConfiguration.framework、ImageIO.framework、CoreGraphic.framework、Security.framework、libsqilte3.0.tbd、CoreTelephony.framework、CoreText.framework、libz.tbd.\nc. 设置 The Other Flags 为 -ObjC.\nd. 在 info.plist 文件的 CFBundleURLTypes 中添加:\n1234&lt;key&gt;CFBundleURLSchemes&lt;key&gt;&lt;array&gt;    &lt;string&gt;wbYOURAPPKEY&lt;string&gt;&lt;array&gt;\ne.对传输安全的支持, 在当下的 iOS 系统中，默认需要为每次网络传输建立 SSL, 所以需在 plist 中设置 NSAppTransportSecurity 的 NSAllowsArbitraryLoads 为 YES.\nf. 解除原有 ATS设置在 iOS 10+ 的网络限制:\n1234567891011&lt;key&gt;sina.com.cn&lt;key&gt;  \t&lt;dict&gt;  \t\t&lt;key&gt;NSIncludesSubdomains&lt;key&gt;  \t\t&lt;true&gt;  \t\t&lt;key&gt;NSThirdPartyExceptionAllowsInsecureHTTPLoads&lt;key&gt;  \t\t&lt;true&gt;  \t\t&lt;key&gt;NSExceptionMinimumTLSVersion&lt;key&gt;  \t\t&lt;string&gt;TLSv1.0&lt;string&gt;  \t\t&lt;key&gt;NSThirdPartyExceptionRequiresForwardSecrecy&lt;key&gt;  \t\t&lt;false&gt;  \t&lt;dict&gt;\ng. 添加以下至白名单:\n1234&lt;string&gt;sinaweibohd&lt;string&gt;&lt;string&gt;sinaweibo&lt;string&gt;&lt;string&gt;weibosdk&lt;string&gt;&lt;string&gt;weibosdk2.5&lt;string&gt;\nh. Swift 语言集成需要 Objective-C - Swift 桥接文件.\n接口调用及内部实现\na. 初始化 SDK\nObjective-C:\n1[[RSinaWeiboManager shared] sdkInitializeByAppKey:YourAppKey appSecret:YourAppSecret];\nSwift:\n1RSinaWeiboManager.shared.sdkInitialize(appKey: YourAppKey, appSecret: YourAppSecret)\n\n仅做分享的话, secret 字段无用.\n\nb. 分享\n对于分享内容的包装新浪处理的比 QQ 简练, 所以无需借助新的类去处理分享内容, 文字是最简单的, 不需要对文字内容进行二次包装, 直接对 WBMessageObject 进行文字设置然后发送分享请求即可;\n图片和视频(包括到「微博故事」)的分享需要 WBImageObject 和 WBNewVideoObject 的包装, 执行 addImages 和 addVideo 方法将要分享的图片视频处理, 在此需要注意的是:实例化 WBImageObject 和 WBNewVideoObject 的时候必须设置 delegate, 并实现 WBMediaTransferProtocol 协议, 由于 addImages 和 addVideo 是异步操作, 所以 wbsdk_TransferDidReceiveObject 回调中发送分享请求!\n另, 经测试, 在参数准备失败的回调函数 wbsdk_TransferDidFailWithErrorCode 中, 出现的错误场景总结:\n\n\n图片、视频体积过大;\n图片数量不在 1 ~ 9 范围内;\n倘若分享到「微博故事」, 照片只能分享一张, 而传了多张图片;\nWBImageObject 多参数并存: 单张的 Data 格式的图片和图片数组共存;\n视频 URL 错误.\n\n\n文字分享:\nObjective-C:\n1[[RSinaWeiboManager shared] shareText: text completion: completion];\nSwift:\n1RSinaWeiboManager.shared.share(text: text, completion: completion)\n表现:\n\n图片分享:\nObjective-C:\n1[[RSinaWeiboManager shared] shareImage:images text: text toStory: yesOrNo completion: completion];\nSwift:\n1RSinaWeiboManager.shared.share(images: images, text: text, isToStory: trueOrFalse, completion: completion)\n为统一接口, 图片用数组包装; 分享到「微博故事」功能中 text 字段会失效.\n\n⚠️ 1. 开启「分享到微博故事」功能图片只能传一张; 多张图片分享的情况下「分享到微博故事」的功能必须关闭!\n⚠️ 2. 图片单张不能超过 10 MB, 最多 9 张图片.\n\n表现:\n分享到微博:\n\n分享到「微博故事」:\n\n本地视频分享:\nObjective-C:\n1[[RSinaWeiboManager shared] shareVideoWithLocalURL:videoFileURL text:text toStory:YesOrNo completion: completion];\nSwift:\n1RSinaWeiboManager.shared.share(localVideoURL: videoFileURL, text: text, isToStory: trueOrFalse, completion: completion)\n分享到「微博故事」功能中 text 字段会失效.\n\n⚠️ 本地视频 URL 为通过 UIImagePickerController 选择的媒体 info 的 UIImagePickerControllerMediaURL 的值,形如: file:privatevarmobileContainersDataApplication3B368706-001D-4018-901B-284D64FA50E2tmp17BD98B4-A498-46E7-9715-6F39E73DFD75.MOV\n\n表现:\n分享到微博:\n\n分享到「微博故事」:\n\n网页分享:\nObjective-C:\n1[[RSinaWeiboManager shared] shareWebpageWithURL: webpageURL objectID: @id title: title description: description thumbImage:thumbImage completion: completion];\nSwift:\n1RSinaWeiboManager.shared.share(webpageURL: webpageURL, objectID: id, title: title, description: description, thumbImage: thumbImage, completion: completion)\nobjectID 字段用于表示一个多媒体内容; 网页的消息体设置无需设置 delegate, 因为不涉及异步操作, 而且 thumbImage 字段应该是失效的, 即不显示缩略图.\n\n⚠️ 1. 网页 thumbImage 字段的缩略图数据不能大于 32 Kb (新浪的 SDK 控制的很严格).\n⚠️ 2. WBWebpageObject 的 description 设置无效, 想要显示网页的相关描述, 只能设置 WBMessageObject 的 text 字段.\n\n表现:\n\nc. 返回本应用\nObjective-C:\n1[[RSinaWeiboManager shared] application:app openURL:url options:options];\nSwift:\n1RSinaWeiboManager.application(app, open: url, options : options)\nFacebook\n准备\n分享需要注册平台, Facebook 开发者主页, Facebook SDK 支持 pod 集成, 分享接口调用说明.\n集成\na. pod 集成: pod FBSDKLoginKit\nb. 在info.plist文件的CFBundleURLTypes中添加:\n12345678&lt;key&gt;CFBundleURLSchemes&lt;key&gt;&lt;array&gt;    &lt;string&gt;fbYOURAPPID&lt;string&gt;&lt;array&gt;&lt;key&gt;FacebookAppID&lt;key&gt;&lt;string&gt;YOURAPPID&lt;string&gt;&lt;key&gt;FacebookDisplayName&lt;key&gt;&lt;string&gt;SOMENAME&lt;string&gt;\nc. 添加以下至白名单:\n1234&lt;string&gt;fbapi&lt;string&gt;&lt;string&gt;fb-messenger-share-api&lt;string&gt;&lt;string&gt;fbauth2&lt;string&gt;&lt;string&gt;fbshareextension&lt;string&gt;\nd. Swift 语言集成需要 Objective-C - Swift 桥接文件.\n接口调用及内部实现\na. 初始化 SDK\nObjective-C:\n1[[RFacebookManager shared] sdkInitializeByID:appID secret:secret];\nSwift:\n1RFacebookManager.shared.sdkInitialize(appID: appID, secret: secret)\n\n仅做分享功能的话, secret 字段无用.\n\nb. 分享\n参数的包装, 借助工具类 RFacebookHelper 来处理, Facebook 已经封装好了各个类型的分享内容载体 (FBSDKSharePhotoContent、FBSDKShareVideoContent ...), 对应设置属性值就可以; 对于图片的分享, 和新浪的图片分享思路相同, 即: 无论是单张还是多图, 一概通过数组包装传递给 RFacebookHelper, 然后它自行处理.\n网页分享:\nObjective-C:\n123456[[RFacebookManager shared] shareWebpageWithURL: webpageURL                           quote: quote                         hashTag: hashTag                            from: context                            mode: mode                      completion: completion];\nSwift:\n1RFacebookManager.shared.share(webpageURL: webpageURL, quote: quote, hashTag: hashTag, from: context, mode: mode, completion: completion)\nFacebook 的 SDK 在迭代的过程中, 舍弃了很多字段, 分享参数不如新浪那样多样, 但是其分享的表现形式却比国内的要友好很多, 特别是在网页分享这块体现的更加明显, 值得注意的是, 非网页形式的分享回调无效, 努力地在 Github、Stack Overflow 和 Facebook Developer 论坛找答案但都没有找到解决办法, 根据 postId 的判断分享结果状态的方法早已失效, 无论是 Android 还是 iOS 端, 目前都没办法.\n\n⚠️ hashTag (话题) 的表现形式不同于国内, 新浪的话题格式: #话题#, 两个 # 之间一切内容都能成为话题, 而 Twitter、Instagram、Facebook 的格式: #话题, 话题内容词组之间不能有任何符号且必须连在一起.\n\n表现:\n客户端形式的分享(无回调):\n\n由上图可见, 在通过客户端分享的过程中, quote 字段已经丢失, Android 表现不同, quote 保留, 其次, iOS 是跳转到 Facebook 客户端分享, Android 是在本应用内弹出对话框分享, 且 Android 通过客户端分享需要提前打开 Facebook 客户端, 否则无法弹出分享对话框, 测试过美图秀秀的图片分享, 也是一样, 需要提前打开客户端.\n网页形式的分享(有回调):\n\n图片分享:\nObjective-C:\n123[[RFacebookManager shared] sharePhotos: targetImageArray                    from:context              completion: completion];\nSwift:\n1RFacebookManager.shared.share(photos: targetImageArray, from: context, completion: completion)\n\n⚠️ 1. 照片大小必须小于 12MB.\n⚠️ 2. 用户需要安装版本 7.0 或以上的原生 iOS 版 Facebook 应用.\n\n表现:\n\n本地视频分享:\nObjective-C:\n1[[RFacebookManager shared] shareVideoWithLocalURL: videoURL from: context];\nSwift:\n1RFacebookManager.shared.share(localVideoURL: videoURL, from: context)\n\n⚠️  本地视频 URL 为通过 UIImagePickerController 选择的媒体 info 的 UIImagePickerControllerReferenceURL 的值, 形如: assets-library:assetasset.MP4?id=8FF2F03F-DD84-41A5-A20C-B745E793C0DC&amp;ext=MP4\n\n倘若通过 Facebook 的 SDK 自行构建本地视频分享模型, 需注意 iOS 11 前后的模型属性设置不同:\nObjective-C:\n1234567891011- (void)imagePickerController:(UIImagePickerController *)pickerdidFinishPickingMediaWithInfo:(NSDictionary *)info&#123;  FBSDKShareVideo *video = [[FBSDKShareVideo alloc] init];  if (@available(iOS 11, *)) &#123;    video.videoAsset = [info objectForKey:UIImagePickerControllerPHAsset];  &#125; else &#123;    video.videoURL = [info objectForKey:UIImagePickerControllerReferenceURL];  &#125;  ...&#125;\nSwift:\n123456789func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123;    let video = FBSDKShareVideo()    if #available(iOS 11, *) &#123;        video.videoAsset = info[UIImagePickerControllerPHAsset]         &#125; else &#123;        video.videoURL = info[UIImagePickerControllerReferenceURL]    &#125;    ...&#125;\n为了统一使用 URL 分享本地视频, 所以笔者并没有考虑使用上述的写法.\n表现:\n\nC. 返回本应用\nObjective-C：\n1[[RFacebookManager shared]application:app openURL:url options:options];\nSwift:\n1RFacebookManager.application(app, open: url, options : options)\nd. 其他设置\n在完成 Facebook 登录、分享等操作的时候还需要连接本应用的 AppDelegate , 故在 didFinishLaunchingWithOptions 函数中添加:\nObjective-C:\n1[[RFacebookManager shared] application:application didFinishLaunchingWithOptions:launchOptions];\nSwift:\n1RFacebookManager.shared.application(application, didFinishLaunchingWithOptions: launchOptions)\n当需要记录有多少用户激活的时候需要在 applicationDidBecomeActive 方法中添加:\nObjective-C:\n1[[RFacebookManager shared]applicationDidBecomeActive:application];\nSwift:\n1RFacebookManager.shared.applicationDidBecomeActive(application)\nTwitter\n准备\n分享需要注册平台, Twitter 开发者主页, 注册应用主页, Twitter SDK 支持 pod 集成, 分享接口调用说明.\n⚠️: Twitter SDK 将于 20181031 后不再进行维护, 但是不影响后续使用, 需自行维护, Twitter 产品经理 Neil Shah 对 Twitter SDK 放弃维护迭代的声明博客.\n集成\na. pod 集成: pod TwitterKit\nb. 在 info.plist 文件的CFBundleURLTypes中添加:\n1234&lt;key&gt;CFBundleURLSchemes&lt;key&gt;&lt;array&gt;    &lt;string&gt;twitterkit-YOURCONSUMERKEY&lt;string&gt;&lt;array&gt;\nc. 添加以下至白名单:\n12&lt;string&gt;twitter&lt;string&gt;&lt;string&gt;twitterauth&lt;string&gt;\nd. Swift 语言集成需要 Objective-C - Swift 桥接文件.\n接口调用及内部实现\na. 初始化 SDK\nObjective-C:\n1[[RTwitterManager shared] sdkInitializeByConsumerKey:yourConsumerKey consumerSecret:yourConsumerSecret];\nSwift:\n1RTwitterManager.shared.sdkInitialize(consumerKey: consumerKey, consumerSecret: secret)\n\n仅做分享的话, secret 字段无用.\n\nb. 授权 Twitter 客户端\n与其他平台分享不同的是, Twitter 在进行发推(分享)的时候会先进行检测本地的 SessionStore 的标记判断是否登录(授权)过, 所以在进行发推的时候需要进行这一步的判断, 在未登录的情况下需进行授权, 在此使用 RTwitterAuthHelper 进行处理, 登录(授权回调):\nObjective-C:\n1typedef void (^auth)(RTWAuthState state, NSString* _Nullable errorInfo);\nSwift:\n1typealias RTWAuthCompletion = (_ state : RTWAuthState,_ errorInfo : String?) -&gt; Void\nstate 包括成功和失败两种结果.\n判断是否登录过:\nObjective-C:\n1BOOL flag = [[RTwitterAuthHepler shared] hasLogged];\nSwift:\n1let _ = RTwitterAuthHepler.shared.hasLogged\n登录授权:\nObjective-C:\n123[[RTwitterAuthHelper shared]authorizeTwitter:^(RTWAuthState state, NSString * _Nullable errorInfo) &#123;     some code ...&#125;];\nSwift:\n123RTwitterAuthHepler.shared.authorizeTwitter &#123; (state, errorInfo) in     some code ...&#125;\n这一步目前的情况就是把 Twitter SDK 提供的授权方法重新包装写了遍, 但是考虑到未来可能用到 session 和 token 等信息并处理, 所以单独写了类讲授权和分享隔离.\n返回本应用:\nTwitter 分享是不需要进行程序跳转的, 只有在登录授权的时候才会需要下述方法, 所以当你成功授权了以后卸载掉 Twitter 的客户端依然可以进行分享.\nObjective-C:\n1[[RTwitterManager shared] application:app openURL:url options:options];\nSwift:\n1RTwitterManager.application(app, open: url, options : options)\n\n⚠️ Twitter 最新 SDK 要求项目的  Deloyment Target 至少为 9.0.\n\nc. 分享\n在本人写的 demo 中, 分享和登录授权是衔接的, 即: 若未登录过 -&gt; 登录授权 -&gt; 分享.\n另, Twitter 能分享的内容相对较少, 所以关于文字、网页、图片的分享, 统一到一个分享接口里, 三者不能同时为空.\nObjective-C:\n1[[RTwitterManager shared]shareWithWebpageURL: webpageURL text: text image: image from: context completion: completion];\nSwift:\n1RTwitterManager.shared.share(webpageURL: webpageURL, text: text, image: image, from: context, completion: completion)\n表现:\n\nTwitter 分享是在本应用内弹出分享框进行分享.\nInstagram\n准备\n分享无需注册平台无需 SDK, Instagram 开发者主页, Custom URL Scheme 方式分享.\n配置\n在1234添加以下至白名单:```objc&lt;string&gt;instagram&lt;string&gt;\n接口调用及内部实现\n分享\n无论照片还是视频都是通过 Custom URL Scheme 来打开 Instagram 客户端, 但 demo 中实际的方法和 Instagram 提供的 Custom URL不同.\nObjective-C:\n1234static NSURL* instagramLibraryURL() &#123;    NSString *str = [NSString stringWithFormat:@instagram:library?AssetPath=%@, @];    return [NSURL URLWithString:str];&#125;\nSwift:\n1fileprivate let instagramURL = URL(string: String(format: instagram:library?AssetPath=%@,  as CVarArg))\n分享流程是先保存照片视频再分享.\n保存照片:\nObjective-C\n1UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), (__bridge void *)self);\n123456- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo&#123;    if ([[UIApplication sharedApplication] canOpenURL:instagramLibraryURL()]) &#123;        [[UIApplication sharedApplication] openURL:instagramLibraryURL()];    &#125;&#125;\nSwift:\n1UISaveVideoAtPathToSavedPhotosAlbum(localVideoURL.path, self, #selector(video(path:didFinishSavingWithError:contextInfo:)), nil)\n123456@objc fileprivate func image(image: UIImage!, didFinishSavingWithError error: NSError!, contextInfo: AnyObject!) &#123;        if UIApplication.shared.canOpenURL(instagramURL!) &#123;            UIApplication.shared.openURL(instagramURL!)        &#125;        &#125;\n保存视频:\nObjective-C:\n1UISaveVideoAtPathToSavedPhotosAlbum(localeVideoURL.path, self, @selector(video:didFinishSavingWithError:contextInfo:), nil);\n123456- (void)video:(NSString *)path didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo &#123;        if ([[UIApplication sharedApplication] canOpenURL:instagramLibraryURL()]) &#123;        [[UIApplication sharedApplication] openURL:instagramLibraryURL()];    &#125;&#125;\nSwift:\n1UISaveVideoAtPathToSavedPhotosAlbum(localVideoURL.path, self, #selector(video(path:didFinishSavingWithError:contextInfo:)), nil)\n12345@objc fileprivate func video(path: String!, didFinishSavingWithError error: NSError!, contextInfo: AnyObject!) &#123;    if UIApplication.shared.canOpenURL(instagramURL!) &#123;        UIApplication.shared.openURL(instagramURL!)    &#125;&#125;\n分享图片:\nObjective-C:\n1[[RInstagramManager shared] share: targetImage];\nSwift:\n1RInstagramManager.shared.share(image: targetImage)\n表现:\n\n分享本地视频:\nObjective-C:\n1[[RInstagramManager shared]shareVideoWithLocalURL: videoURL description: description]\nSwift:\n1RInstagramManager.shared.share(localVideoURL: videoFileURL!, description: description)\ndescription 字段在实际传递过程中是失效的.\n\n⚠️ 本地视频 URL 为通过 UIImagePickerController 选择的媒体 info 的 UIImagePickerControllerMediaURL 的值,形如: file:privatevarmobileContainersDataApplication3B368706-001D-4018-901B-284D64FA50E2tmp17BD98B4-A498-46E7-9715-6F39E73DFD75.MOV\n\n表现:\n\nTumblr\n准备\n分享需要注册平台, Tumblr 开发者主页, 注册应用主页, Tumblr SDK 支持 pod 集成, 分享接口调用说明.\n集成\na. pod 集成: pod Flurry-iOS-SDKTumblrAPI\n⚠️: 一定是这个, 最新版本的 SDK 我没有找到分享的接口.\nb. Swift 语言集成需要 Objective-C - Swift 桥接文件.\n接口调用及内部实现\na. 初始化 SDK\nObjective-C:\n1[[RTumblrManager shared] sdkInitializeByConsumerKey:yourConsumerKey consumerSecret: yourConsumerSecret];\nSwift:\n1RTumblrManager.shared.sdkInitialize(consumerKey: yourConsumerKey, consumerSecret: yourConsumerSecret)\n\n⚠️ 在 iOS 端初始化 SDK 需要 consumerKey 和 consumerSecret 两个参数, Android 端还需要 flurryKey 这个参数才能完成分享.\n\nb. 分享\nTumblr 分享体只包括图片和文字两种, 并且图片还是网络图片的链接, 并不能分享本地图片, 所以 Tumblr 的局限性很大, 这两种分享体的模型通过 SDK 中 FlurryImageShareParameters 和 FlurryTextShareParameters 来构建;\nTumblr 分享是通过当前界面弹出对话框分享的, 和 Twitter 类似, 所以不需要判断 Tumblr 程序是否安装;\nTumblr 的分享流程是: 登录 -&gt; 分享, 但是登录的逻辑不需要在代码中实现, 他会自动呈现浏览器的登录界面.\n文字分享:\nObjective-C:\n1[[RTumblrManager shared] shareText: text title: title webpageURL: webpageURL from: context completion: completion];\nSwift:\n1RTumblrManager.shared.share(text: text, title: title, webpageURL: webpageURL, from: context, completion: completion)\n表现:\n\n图片链接分享:\nObjective-C:\n1[[RTumblrManager shared] shareImageWithURL: targetImageURL description: description webpageURL: webpageURL from: context completion: completion];\nSwift:\n1RTumblrManager.shared.share(imageURL: targetImageURL, description: description, webpageURL: webpageURL, from: context, completion: completion)\n表现:\n\nPinterest\n准备\n分享需要注册平台, Pinterest 开发者主页, 注册应用主页, Pinterest SDK 支持 pod 集成, 接口调用说明.\n集成\na. pod 集成: pod “PinterestSDK”, :git =&gt; “git@github.com:pinterestios-pdk.git”\nd. 在 info.plist 文件的 CFBundleURLTypes 中添加:\n1234567891011&lt;key&gt;CFBundleURLTypes&lt;key&gt;  &lt;array&gt;    &lt;dict&gt;      &lt;key&gt;CFBundleURLName&lt;key&gt;      &lt;string&gt;&lt;string&gt;      &lt;key&gt;CFBundleURLSchemes&lt;key&gt;      &lt;array&gt;        &lt;string&gt;pdkYOURAPPID&lt;string&gt;      &lt;array&gt;    &lt;dict&gt;  &lt;array&gt;\ne. 添加以下至白名单:\n1&lt;string&gt;pinterestsdk.v1&lt;string&gt;\nb. Swift 语言集成需要 Objective-C - Swift 桥接文件.\n接口调用及内部实现\na. 初始化 SDK\nObjective-C:\n1[[RPinterestManager shared] sdkInitializeByAppID: yourAppID appSecret:yourAppSecret];\nSwift:\n1RPinterestManager.shared.sdkInitialize(appID: yourAppID, appSecret: yourAppSecret)\n\n仅做分享功能的话, secret 字段无用.\n\nb. 分享\n⚠️: Pinterest 分享要求项目的 CFBundleDisplayName 一定不能为空!!!\n图片链接分享:\nObjective-C:\n1[[RPinterestManager shared] shareImageWithURL: targetImageURL webpageURL: webpageURL onBoard:boardName description: description  from: context completion:completion];\nSwift:\n1RPinterestManager.shared.share(imageURL: targetImageURL, webpageURL: webpageURL, boardName: boardName, description: description, from: context, completion: completion)\nboardName 字段即使随便设置也不影响, 考虑到有可能对 Pinterest 功能细化的时候会用到这个字段就保留下来了.\n表现:\n\nc. 返回本应用\nObjective-C:\n1[[RPinterestManager shared] application:app openURL:url options:nil];\nSwift:\n1RPinterestManager.application(app, open: url, options : options)\nLine\n准备\n分享无需注册平台.\n配置\n在info.plist文件中:\n添加以下至白名单:\n1&lt;string&gt;line&lt;string&gt;\n接口调用及内部实现\n分享\nLine 分享是通过 Custom URL Scheme 来打开 Line 客户端进行分享, 但 demo 中实际的方法和 Line 提供的 Custom URL.\n文本分享的 URL 为 line:msgtext?targetText, 要对 targetText 中的中文、特殊字符等进行处理:\nObject-C:\n1[targetText stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];\nSwift:\n1targetText.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)\n图片分享的 URL 为 line:msgimage, URL 后面的部分可通过 UIPasteboard 实例的 name 属性拼接:\nObjective-C:\n123UIPasteboard* p = [UIPasteboard generalPasteboard];[p setData:(UIImageJPEGRepresentation(image, 1)) forPasteboardType:@public.jpeg];NSURL* lineURL = [NSURL URLWithString:[NSString stringWithFormat:@line:msgimage%@,p.name]];\nSwift:\n123let p = UIPasteboard.generalp.setData(UIImageJPEGRepresentation(image, 0.1)!, forPasteboardType:public.jpeg)let lineURL = URL(string: String(format: lineURLPrefix + line:msgimage%@, p.name as CVarArg))\n文字分享:\nObjective-C:\n1[[RLineManager shared] shareText: text];\nSwift:\n1RLineManager.shared.share(text: text)\n表现:\n\n图片分享:\nObjective-C:\n1[[RLineManager shared] shareImage: targetImage];\nSwift:\n1RLineManager.shared.share(image: targetImage)\n表现:\n\nWhatsApp\n准备\n分享无需注册平台.\n配置\n在info.plist文件中:\n添加以下至白名单:\n1&lt;string&gt;whatsapp&lt;string\n接口调用及内部实现\n分享\n通过 Custom URL Scheme 分享文字, 图片是通过 UIDocumentInteractionController 来实现应用间数据共享, 构建文字的 URL 为 whatsapp:send?text=targetText\n文字分享:\nObjective-C:\n1[[RWhatsAppManager shared]shareText: text]\nSwift:\n1RWhatsAppManager.shared.share(text: text)\n表现:\n\n图片分享:\nObjective-C:\n1[[RWhatsAppManager shared]shareImage: targetImage from: context];\nSwift:\n1RWhatsAppManager.shared.share(image: targetImage , from: context)\n表现:\n\nGooglePlus\n准备\n分享无需注册平台, Google Plus 开发者主页已经把 iOS 相关移除了.\n接口调用及内部实现\n分享\nGoogle Plus 只支持通过 Custom URL Scheme 分享网页, 构建 URL 为 https:plus.google.comshare\n内部构建:\nObjective-C:\n12345678910111213NSURLComponents* urlComponents = [[NSURLComponents alloc]                                      initWithString:@https:plus.google.comshare];urlComponents.queryItems = @[[[NSURLQueryItem alloc]                                  initWithName:@url                                  value:[shareURL absoluteString]]];NSURL* url = [urlComponents URL];    if ([SFSafariViewController class]) &#123;    SFSafariViewController* controller = [[SFSafariViewController alloc] initWithURL:url];    controller.delegate = self;    [from presentViewController:controller animated:YES completion:nil];&#125; else &#123;    [[UIApplication sharedApplication] openURL:url];&#125;\nSwift:\n12345678910var components = URLComponents(string: https:plus.google.comshare)components?.queryItems = [URLQueryItem(name: url, value: webpageURL.absoluteString)]let url = components?.urlif #available(iOS 9, *) &#123;    let vc = SFSafariViewController(url: url!)    vc.delegate = self    from.present(vc, animated: true, completion: nil)&#125; else &#123;    UIApplication.shared.openURL(url!)&#125;\n网页分享:\nObjective-C:\n1[[RGooglePlusManager shared]shareURL:[NSURL URLWithString: targetURL] from: context];\nSwift:\n1RGooglePlusManager.shared.share(webpageURL: URL(string: targetURL)!, from: context)\n表现:\n\n统一分享接口\n缺陷\n缺陷说在前面, 其实本来不打算统一接口的.\n\n假如只想分享某五个平台, 其余的六个平台仍然不可以删掉, 主分享 Manager 和子平台分享 Manager 存在耦和;\n分享接口优化受限制, 由于前面的平台分享对比表格可知, 国外的平台分享很多都没有回调, 而国内的平台分享内容又存在多种形式, 无法实现高度统一;\n添加平台没有做去重处理, 造成不必要的开销;\n分享完毕返回到本应用的统一处理中子平台分享 Manager 和主分享 Manager 存在代码污染.\n\n类图\n\n\nRShareManger: 主分享 Manager, 子平台 Manager 的初始化、分享、应用跳转和一些其他操作都在此进行;\nRPlatform: 主要进行应用是否安装、添加目标应用的操作;\nRRegister: 主要进行 RShareManager 和子平台分享 Manager 的 SDK 初始化衔接;\nRImageContent、RVideoContent、RTextContent、RWebpageContent 为四种对应分享内容模型.\n\n详细设计\n**a. 平台添加 **\n平台相关都交给 RPlatform 去处理, 平台的添加借鉴了 Java 中的 Builder 模式思路去处理, RPlatform 的成员属性 targets 在 Objective-C 中为:\n1@property (strong, nonatomic, readonly) NSArray&lt;Class&gt;* targets;\nSwift 中为:\n1var targets : Array&lt;RShare.Type&gt; = []  多态的体现\nadd 函数为添加平台的操作, 参数为平台枚举 RShareSDKPlatform, RPlatform 的私有成员属性 info 为字典类型, key 为平台的字符串形式,  value 平台类型 , 通过 add 操作的平台枚举去取出 info 中对应的平台类型添加到 targets 中.\nb. 分享频道\n以 Objective-C 为例, 在 RShareManager 定义了分享通道枚举:\n1234567891011121314151617181920typedef NS_ENUM(NSInteger, RShareChannel) &#123;    RShareChannelQQSession,  QQ 好友    RShareChannelQQFavorite,  QQ 收藏    RShareChannelQQDataLine,  QQ 我的电脑(数据传输)    RShareChannelQZone,  QQ 空间    RShareChannelWechatSession,  微信好友    RShareChannelWechatFavorite,  微信收藏    RShareChannelWechatTimeline,  微信朋友圈    RShareChannelFacebookClient,  Facebook 客户端    RShareChannelFacebookBroswer,  Facebook Feed 形式网页    RShareChannelTwitter, 推特    RShareChannelSinaWeibo,  新浪微博    RShareChannelSinaWeiboStory,  新浪微博 - 我的故事    RShareChannelLine,  Line    RShareChannelInstagram,  Instagram    RShareChannelTumblr,  Tumblr    RShareChannelPinterest,  Pinterest    RShareChannelGooglePlus,  GooglePlus    RShareChannelWhatsApp  WhatsApp&#125;;\nc. 初始化以及注册平台\n由 ShareSDK iOS 版激发灵感进行构建.\nRShareManager 通过单例创建, 实例函数 registerPlatforms: 为注册实例化子平台 Manager 的过程, Objective-C 中通过 runtime 实现:\n1234567 code snippet ...@autoreleasepool &#123;    Class cls = p.targets[i];    id obj = objc_msgSend(objc_msgSend(cls, @selector(alloc)), @selector(init));    SEL sel = @selector(connect:);    ((void(*)(id,SEL, RConfiguration))objc_msgSend)(obj, sel, c);&#125;\nSwift 中暂时没找到类似的方法, 采用了原始的 switch-case 逐个判断并初始化.\n其中 RConfiguration 为:\nObjective-C:\n12 定义在 RShare.h 中typedef void (^RConfiguration)(RShareSDKPlatform platform, RRegister* obj);\nSwift:\n12 定义在 RShareManager 中typealias RConfiguration = (_ paltform : RShareSDKPlatform,_ obj : RRegister) -&gt; Void\n每个子平台 Manager 都有 connect 函数, 参数是 RConfiguration 类型, 返回平台信息是因为不是所有的平台都需要初始化 SDK, 返回 RRegister 实例的目的是把实例化的工作交给 RRegister 去做.\nRRegister 内部逻辑很简单, 只有初始化三方平台 SDK 的工作.\nd. 返回本应用\nObjective-C 中通过 runtime 实现:\n12345- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options &#123;     SEL sel = @selector(application:openURL:options:);    id obj = objc_msgSend(objc_msgSend(_cls, @selector(alloc)), @selector(init));    return ((BOOL(*)(id,SEL,id,id,id))objc_msgSend)(obj, sel, application,url,options);&#125;\n其中 _cls 是在分享的时候通过分享接口中 channel 字段通过 -(Class)getCls:(RShareChannel)channel 确定, objCls 在 Swift 中通过同样的方法获得: func getSubCls(channel : RShareChannel) -&gt; RShare.Type.\n123func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -&gt; Bool &#123;    return objCls.application(app, open: url, options : options)     &#125;\n接口\n添加平台及初始化需要注册的平台:\nObjective-C:\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;        RPlatform* p = [RPlatform make:^(PlatformBuilder *builder) &#123;        [builder add:RShareSDKPinterest];        [builder add:RShareSDKWhatsApp];        [builder add:RShareSDKWechat];        [builder add:RShareSDKSina];        [builder add:RShareSDKQQ];        [builder add:RShareSDKTumblr];        [builder add:RShareSDKFacebook];        [builder add:RShareSDKTwitter];        [builder add:RShareSDKLine];        [builder add:RShareSDKGooglePlus];        [builder add:RShareSDKInstagram];    &#125;];        [[RShareManager shared] registerPlatforms:p onConfiguration:^(RShareSDKPlatform platform, RRegister *obj) &#123;        switch (platform) &#123;            case RShareSDKPinterest:                [obj connectPinterestByAppID: yourAppID appSecret: nil];                break;            case RShareSDKQQ:                [obj connectQQByAppID:yourAppID appKey: yourKey];                break;                            case RShareSDKSina:                [obj connectSinaWeiboByAppKey: yourKey  appSecret:yourSecret];                break;            case RShareSDKWechat:                [obj connectWechatByAppID: yourAppID appSecret:yourSecret];                break;            case RShareSDKTumblr:                [obj conncetTumblrByConsumerKey: yourKey  consumerSecret: yourSecret];                break;            case RShareSDKFacebook:                [obj connectFacebookByID:yourAppID secret:nil];                break;            case RShareSDKTwitter:                [obj connectTwitterByConsumerKey:yourKey consumerSecret:yourSecret];                            default:                break;        &#125;    &#125;];        return YES;&#125;\nSwift:\n1234567891011121314151617181920212223242526272829303132333435363738func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123;        let platform = RPlatform.make &#123; (builder) in        builder.add(p: .Facebook)        builder.add(p: .Twitter)        builder.add(p: .QQ)        builder.add(p: .Wechat)        builder.add(p: .Instagram)        builder.add(p: .Tumblr)        builder.add(p: .Pinterest)        builder.add(p: .Sina)        builder.add(p: .GooglePlus)        builder.add(p: .Line)        builder.add(p: .WhatsApp)                       &#125;    RShareManager.shared.registerPlatform(platform: platform) &#123; (p, obj) in        switch p &#123;            case .Facebook:                obj.connectFacebook(appID: yourAppID, secret: nil)            case .Pinterest:                obj.connectPinterest(appID: yourAppID, secret: nil)            case .QQ:                obj.connectQQ(appID: yourAppID, key: yourKey)            case .Sina:                obj.connectSinaWeibo(appKey: yourKey, secret: yourSecret)            case .Wechat:                obj.connectWechat(appID: yourAppID, secret: yourSecret)            case .Tumblr:                obj.connectTumblr(consumerKey: yourKey, secret: yourSecret)            case .Twitter:                obj.connectTwitter(consumerKey: yourKey, secret: yourSecret)            default : break        &#125;    &#125;        return true&#125;\n构建分享模型:\n以 RImageContent 为例:\nObjective-C:\n123RImageContent* content = RImageContent make:^(RImageContentBuilder *builder) &#123;      ...   &#125;\nSwift:\n123RImageContent.make &#123; (builder) in     ...    &#125;\n分享：\n以分享 RImageContent 为例:\nObjective-C:\n123[RShareManager shared] shareImageWithContent:content channel: channel from: context completion:^(RShareSDKPlatform platform, ShareResult result, NSString * _Nullable errorInfo) &#123;      ...   &#125;\nSwift:\n123RShareManager.shared.shareImage(content: content, channel: channel, from: context) &#123; (platform, result, errorInfo in     ...    &#125;\n返回本应用:\nObjective-C:\n1[[RShareManager shared]application:app openURL:url options:options];\nSwift:\n1RShareManager.shared.application(app, open: url, options : options)\n源码\nObjective-C 版本源码、 Swift 版本源码, 还在学习中, 请多指教.\n","tags":["share","social","iOS","Objective-C","Swift"],"path":"2018/08/28/2018-08-28/","external_link":""}]';

	s = s.replace(/\\n/g, "\\n")
               .replace(/\\'/g, "\\'")
               .replace(/\\"/g, '\\"')
               .replace(/\\&/g, "\\&")
               .replace(/\\r/g, "\\r")
               .replace(/\\t/g, "\\t")
               .replace(/\\b/g, "\\b")
               .replace(/\\f/g, "\\f")

// remove non-printable and other non-valid JSON chars
	s = s.replace(/[\u0000-\u0019]+/g,"");
	var list = JSON.parse(s);
	var fuse = new Fuse(list, options);
	var el = document.getElementById('search-form');
	var newBox = $('.Card-archive').first().clone();
	el.oninput = function(event){
		var searchText = el.value;
		var result = fuse.search(searchText);
		$('.archive-cards .Card-archive').remove();
		for(var i in result){
			var anotherBox = newBox.clone();
			var dateStr = new Date(result[i].date);
			anotherBox.css('display','flex');
			var url = "";
			if(result[i].external_link !== ""){
				url = result[i].external_link;
			}else{
				url = '/' + result[i].path;
			}

			anotherBox.find('.Card-title a').text(result[i].title).attr('href', url);
			anotherBox.find('.Card-date').text(dateStr.toDateString());
			anotherBox.appendTo('.archive-cards');
		}
	}
</script>

<div class='tagcloud-container'>
<div class='tag-cloud'>
	<a href="/tags/Android/" style="font-size: 0.8em; color: #488baf">Android</a> <a href="/tags/HTTP/" style="font-size: 2em; color: #d63e0a">HTTP</a> <a href="/tags/Java/" style="font-size: 0.8em; color: #488baf">Java</a> <a href="/tags/Kotlin/" style="font-size: 0.8em; color: #488baf">Kotlin</a> <a href="/tags/Objective-C/" style="font-size: 0.8em; color: #488baf">Objective-C</a> <a href="/tags/Swift/" style="font-size: 0.8em; color: #488baf">Swift</a> <a href="/tags/TCP/" style="font-size: 0.8em; color: #488baf">TCP</a> <a href="/tags/hls/" style="font-size: 0.8em; color: #488baf">hls</a> <a href="/tags/iOS/" style="font-size: 0.8em; color: #488baf">iOS</a> <a href="/tags/rtmp/" style="font-size: 0.8em; color: #488baf">rtmp</a> <a href="/tags/share/" style="font-size: 1.4em; color: #8f655d">share</a> <a href="/tags/social/" style="font-size: 1.4em; color: #8f655d">social</a> <a href="/tags/拉流/" style="font-size: 0.8em; color: #488baf">拉流</a> <a href="/tags/推流/" style="font-size: 0.8em; color: #488baf">推流</a>
</div>
</div>

  </div>

  

<footer id='footer'>
    <div class='footer-copyright'>
        <div>
            <p> Copyright by <a href=""> </a> @ 2019</p>
            <p>Designed by: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> and <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; Theme: <a href="https://qutang.github.io/cutie/">Cutie 2.1.3-Taurus</a> &bull; Powered by <a href="http://hexo.io">Hexo.</a></p>
        </div>
    </div>
    
    <div class='footer-social'>
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='Archives'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='Search'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
		
	</div>
	</div>
</nav>

	</div>

  



    







    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type='text/javascript'>
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type='text/javascript'>

  
</script>



<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant type='text/javascript'>

initHeadroom();

changeLayoutOnTouchScreen();

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
