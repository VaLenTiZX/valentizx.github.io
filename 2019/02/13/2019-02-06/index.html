<!DOCTYPE html>
<html lang="en">




<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>HTTP 原理和工作机制（三） - I'M VALENTI</title>
  

  
  
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>

<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script
src="https://code.jquery.com/jquery-3.3.1.min.js"
integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


<link rel="stylesheet" href="/.css">

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  

  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class='header'>
	<div class="header-title">
		
		<div class='header-logo'>
			<a href='/'>
				<img src='/images/theme-icon.svg' />
			</a>
		</div>
		<div class='header-text'>
			<h1>
				<a href="/">I'M VALENTI</a>
			</h1>
			<subtitle>
				
			</subtitle>
		</div>
		
	</div>
	<div id='header-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-toc'>
		


<div class='toc-container'>
<i class="far fa-times-circle" id='toc-close' onclick='closeTOC(event);' ontouchstart='closeTOC(event);'></i>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">登录和授权</span></a></li></ol>
</div>
<div class="toc-button" onclick='toggleTOC(event);' ontouchstart='toggleTOC(event);'>
    <img src="/images/icons/blue-shadow/toc.svg" alt="">
</div>

	</div>
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='Archives'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon'>
		
			<a href="/search/" title='Search'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
		
	</div>
	</div>
</nav>

	</div>
</header>

 

  




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>








    
    






    
    
        
    

    
        
    









<article class="article" id="/2019/02/13/2019-02-06/" data-name='HTTP 原理和工作机制（三）' data-version="">

    <!-- Title -->
    <div class='article-header'>
         
         <h1 class='article-title'>
            <a href="/2019/02/13/2019-02-06/">
                HTTP 原理和工作机制（三）
            </a>
        </h1>
        <!-- TODO: support nested categories,display them nicely -->
        
    </div>
    
    <!-- Date and Author -->
    <div class='article-meta'>
    <ul>
            <li><i class='fa fa-calendar'></i> 2019-02-13</li>
            
            <li><i class="fa fa-user"></i> </li>
            <li><i class="fas fa-copyright"></i>
            
                
                
            
            
                <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/>CC BY-NC-ND 4.0</a>
            
            </li>
    </ul>
    
<div class="tags">
	
		
			<label class='tag-1'><a href="/tags/HTTP/">Http</a></label>
		
	
		
			<label class='tag-2'><a href="/tags/TCP/">Tcp</a></label>
		
	
	</div>

    </div>
    <div class='article-cards'>
        <!-- Author Card -->
        <!---
        <div class='Card-article Card-author'>
            <div class='card-title'>
                <h3></h3>
            </div>
            <div class='card-content'>
                    <div class="author-meta">
                            <div class='author-figure'>
                                <img src="" alt="">
                            </div>
                            <div class='author-name'>
                                
                            </div>
                        </div>
                        <div class="author-ai">
                            <div class='author-intro'>
                                <!-- TODO: auto generating author description -->
                                <!-- 
                            </div>
                            <div class="author-articles">
                                <!-- TODO: auto generating author articles -->
                                <!-- <ul>
                                    <li>Article 1</li>
                                    <li>Article 2</li>
                                    <li>Article 3</li>
                                    <li>Article 4</li>
                                    <li>Article 5</li>
                                    <li>Article 6</li>
                                </ul>
                            </div>
                        </div>
            </div>
            
        </div> -->

        <!-- Visit Card -->
        <!-- <div class="Card-article Card-visit"> -->
            <!-- <div class="card-title">
  <h3>Post Visit</h3>
</div>
<div class="card-chart">
  <div id='chart-post-visit'></div>
</div> -->
        <!-- </div> -->
        
        <!-- Auto Excerpt Card -->
        <!-- <div class="Card-article Card-excerpt">
            <div class="card-title">
  <h3>Quick Read</h3>
</div>
<div class="card-text">
  <p id='text-post-summary'>登录和授权
登录
身份认证的过程，在输入账号和密码以及点击登录按钮这一操作流程，就是将「你本人」和所输入的「账号」建立联系的过程。
Cookie
起源：购物车，当时的「购物车」不存在服务器，电商网站的开发商觉得用户在没有真正决定购买的情况下不需要将购物车的信息放进服务器里，只存在本地就好，于是电商网站开发商决定做一个浏览器来实现这一功能，也就是说，电商网站——浏览器是一体的，并实现了 Cookie 的功能满足购物车的需求，这就是最早的 Cookie。
Cookie...</p>
</div>
        </div> -->
    </div>
    
    <!-- Gallery -->
    <!-- TODO: add a slider to gallery -->
    

    <!-- Content -->
    <!-- TODO: support table of content -->
    <div class="article-toc" id='article-toc'>
    
        


<div class='toc-container'>
<i class="far fa-times-circle" id='toc-close' onclick='closeTOC(event);' ontouchstart='closeTOC(event);'></i>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">登录和授权</span></a></li></ol>
</div>
<div class="toc-button" onclick='toggleTOC(event);' ontouchstart='toggleTOC(event);'>
    <img src="/images/icons/blue-shadow/toc.svg" alt="">
</div>

    </div>
    <div class='article-content'>
    <h2>登录和授权</h2>
<h3>登录</h3>
<p>身份认证的过程，在输入<strong>账号</strong>和<strong>密码</strong>以及点击登录按钮这一操作流程，就是将「你本人」和所输入的「账号」建立联系的过程。</p>
<h4>Cookie</h4>
<p>起源：购物车，当时的「购物车」不存在服务器，电商网站的开发商觉得用户在没有真正决定购买的情况下不需要将购物车的信息放进服务器里，只存在本地就好，于是电商网站开发商决定做一个浏览器来实现这一功能，也就是说，电商网站——浏览器是一体的，并实现了 Cookie 的功能满足购物车的需求，这就是最早的 Cookie。</p>
<h5>Cookie 的工作机制</h5>
<p>由于是客户端保存信息，所以保存的信息由服务器决定，服务器返回的信息客户端保存就行了。</p>
<p>如，在购物车里添加一个苹果，客户端访问服务端 /cart 这个 path，并附带苹果的数量这个参数，表示「我要放进购物车里 1 个苹果」，服务器处理完返回 200，并附带 Set-Cookie 的 Header 表示让客户端存起来。
<img src="http://pmud0ogk6.bkt.clouddn.com/15496865022950.jpg" alt="-w695"></p>
<p>下次客户端再访问 shop.com 的时候会附带 cart=&quot;apple=1&quot;，这是一个<strong>自动的过程，并由浏览器实现</strong>。
如下次购物车再添加一个香蕉，浏览器会自动附带 cart=&quot;apple=1&quot; 的信息去请求，服务端会知道客户端已经「存储」了一个苹果，处理后返回 200 更新 Set-Cookie 的 Header，此时客户端更新 Cookie。
<img src="http://pmud0ogk6.bkt.clouddn.com/15496869070604.jpg" alt="-w631"></p>
<p>该过程服务端什么都没记，全都由客户端存储，Cookie 谁来修改？是服务端，每次都是服务端来修改 Cookie 信息，客户端被动的更新、存储。这就是早期的 Cookie 的工作机制。</p>
<blockquote>
<p>现在逐渐抛弃用 Cookie 机制来做登录和认证。</p>
</blockquote>
<h6>使用 Cookie 管理登录状态</h6>
<p>客户端使用账号密码访问服务端，服务端确认后，会创建一个<strong>会话（Session）</strong>，会话记录了客户端可能是什么状态、用户代理等信息。然后服务端将 Session 返回给客户端。
<img src="http://pmud0ogk6.bkt.clouddn.com/15496880132476.jpg" alt="-w614"></p>
<p>客户端下次访问服务端的时候会附带 sessionid，假如客户端想要请求用户信息，服务端凭借 sessionid 会得知，该客户端在登录状态，可以返回给他要的用户信息。
<img src="http://pmud0ogk6.bkt.clouddn.com/15496882798085.jpg" alt="-w633"></p>
<p>关于登录状态的管理，服务端是需要插手干预的。</p>
<h5>Cookie 的作用</h5>
<ul>
<li>会话管理：登录状态、购物车等；</li>
<li>个性化：用户偏好、主题；</li>
<li>Tracking：分析用户行为（能够得知用户访问哪些网站）。</li>
</ul>
<h5>XSS（Cross-site scripting）</h5>
<p>跨站脚本攻击，假如网站的 javascript 是坏人写的，有可能会将本地的 Cookie 转发出去，这是看不见摸不着的，Cookie 的泄漏也就代表某些敏感信息的泄漏。
应对策略就是在 Cookie 的 Header 后加 HttpOnly 的限制，这样本地脚本看不到该 Cookie，该 Cookie 只用于 HTTP 的信息交换。</p>
<h5>XSRF（Cross-site request forgery）</h5>
<p>跨站请求伪造，由于 Cookie 是一个<strong>自动</strong>的过程，攻击者可以利用 Cookie 访问授信网站伪装成授信用户进行一些操作。其中一个防范措施就是带上 Referer 的 Header 告诉服务器我是从哪个页面来的，假如来源的这个页面不授信，则服务器拒绝处理。</p>
<h3>授权</h3>
<p>赋予某个人具有某个<strong>权限</strong>，能执行什么操作，在计算机世界里，这个特殊的权限叫做<strong>令牌</strong>，就像古代的刽子手本身不具备权限杀人，但是皇上赋予了刽子手行刑的权力，那么刽子手便可以杀人了，皇上就是<strong>授权方</strong>。</p>
<h4>Basic</h4>
<p>基本的授权方式，用得较少但是实用，格式如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authortization: Basic&lt;username:password(Base64ed)&gt;</span><br></pre></td></tr></table></figure></p>
<h4>Bearer</h4>
<p>需带着令牌的授权方式，格式如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Authortization: Basic&lt;bearer token&gt;</span><br><span class="line">token 需要找授权方获得。</span><br></pre></td></tr></table></figure></p>
<h5>OAuth2</h5>
<p>提供第三方认证的机制，是一个授权框架，它可以使第三方的应用程序或者客户端获得对应 HTTP 服务器上用户账号信息的访问权限。</p>
<p>如，在登录<a href="https://juejin.im" target="_blank" rel="noopener">掘金</a>的时候，除了从正常的账号密码登录以外还可以选择三方登录，如 GitHub，在点击 GitHub 登录的时候就会弹出下面的小窗口进行授权。
<img src="http://pmud0ogk6.bkt.clouddn.com/15495362819577.jpg" alt="-w800"></p>
<h6>OAuth2 认证流程</h6>
<p>认证流程如下图：
<img src="http://pmud0ogk6.bkt.clouddn.com/15495378750304.jpg" alt="-w625"></p>
<p>a. 在这个过程中，本人和 GitHub 是第一、二方，<strong>而掘金是第三方</strong>，所以这个流程的意义就是：GitHub 授权掘金，赋予掘金可以访问 GitHub 账号信息的权限，从而登录掘金的网站。</p>
<blockquote>
<p>在该流程中，有一个重要的角色：<strong>client_id</strong>，它是三方网站开发者在开发登录模块是去 Github 申请下来的。相当于标记或者身份证的作用。凭借 client_id 与 Github 沟通，Github 会返回如头像、账号名字、URL 等信息。</p>
</blockquote>
<p>b. 当点击上图的 <code>Authorize Xitu</code> 后，少顷，便跳回掘金主页，账号会显示来自 GitHub 的账号。在跳回掘金主页的时候 GitHub 会返回 <strong>Authorization code</strong> 如下图：</p>
<p><img src="http://pmud0ogk6.bkt.clouddn.com/15495385406485.jpg" alt="-w609"></p>
<p>Q: 为什么返回的不是 token 而是 Authorization code？
A: 因为 OAuth2.0 整个过程不是强制基于 HTTPS 的，那么在返回的过程可能被拦截，假如返回的是真正有意义的信息，那么该有意义的信息可能被窃取；还有一个原因就是<strong>浏览器是不可靠的</strong>，用户用什么浏览器以及操作系统都是未知的，所以在返回的过程中依然存在风险，所以 GitHub 返回的仅仅是一个授权码，仅仅是一个证明，表示用户同意了 GitHub的授权而已。</p>
<p>c. 接下来在看不见摸不着的背后，掘金带着 Authorization code 和掘金的 Server 端沟通，掘金的 Server 端带着 Authorization code 和 <strong>client_id</strong> 和 GitHub 请求, client_secret 是三方在向 GitHub 申请应用的时候一起申请下来的。client_secret 是绝对保密的，一直存在 Server 端，而 Server 端和 GitHub 的连接也是 HTTPS 连接保证安全。当 Server 端同时具备：身份证明（client_secret）以及用户证明（Authorization code）后，GitHub 便可确认三方的请求连接足够安全，对方足够可靠，<strong>便可放心的将 token 返回给 Server 端</strong>，至此，整个 OAuth2.0 的认证流程结束，第三阶段流程如下图：
<img src="http://pmud0ogk6.bkt.clouddn.com/15495399940073.jpg" alt="-w613"></p>
<p>d. 当认证流程结束返回到掘金的主页时，此时掘金账号的头像亦是 GitHub 请求下来的，此时的请求流程便是：Server 端带着 token 请求 GitHub 的头像信息，然后进行显示，如下：
<img src="http://pmud0ogk6.bkt.clouddn.com/15495513143219.jpg" alt="-w624"></p>
<blockquote>
<p>在某些安全意识不强的情况下，Server 端会把 token 返还给客户端，这种做法就不再具备 OAuth2.0 认证的安全性。</p>
</blockquote>
<h6>微信登录</h6>
<p>微信登录，是一种第三方登录，亦是一个标准的 OAuth2.0 的认证过程，正确的微信登录流程是：</p>
<p>调用微信的 API 后打开微信的授权界面进行授权，此时是微信在对「你」进行第三方授权，确认返回后，微信会返回一个 <figure class="highlight plain"><figcaption><span>code```，**此时将 Authorization code 交给服务器**，此时，客户端的任务结束，服务端的任务便遵循 OAuth2.0 的流程去和微信的服务器打交道（同上节 OAuth2.0 认证流程一样）。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### 自家产品中使用 Bearer token</span><br><span class="line"></span><br><span class="line">在多数情况下， 调用登录接口并且登录成功的情况下，Server 端会返回 access_token / token，然后请求其他接口的时候 Client 端直接拿着这个 token 请求，这种做法是**模仿了 OAuth2.0 中 access_token 的使用方法**，但并不是 OAuth2.0 的过程。</span><br><span class="line"></span><br><span class="line">###### refresh token</span><br><span class="line"></span><br><span class="line">刷新 token 从 Server 端返回的格式大概是：</span><br></pre></td></tr></table></figure></p>
<p>{
&quot;token_type&quot;: &quot;Bearer&quot;,
&quot;access_token&quot;: &quot;xxxx&quot;,
&quot;refresh_token&quot;: &quot;xxxx&quot;,
&quot;expires_time&quot;: &quot;xxxx&quot;
}</p>
<pre><code>
refresh_token 的作用是，以此请求一个新的 access_token 和一个新的 refresh_token，那么旧的 token 会失效，refresh_token 存在的意义就是保证安全，因为 access_token 还是有概率会丢失，如果是授权登录，丢失 access_token 会导致用户再次认证、登录，这样的操作极不友好，所以需要借助 refresh_token 来获取新的 access_token 并且将旧的“作废”。**这个过程还是尽量保证在 Server 端。**

## TCP/IP 协议族

**TCP/IP 协议族并不是单指 TCP 和 IP 的构成，而是一系列协议组成的一个网络模型分层。**

在很多有关网络的文章亦或是大学的计算机网络课程中，「分层」这个词出现的频率极高，如物理链路层、表示层、会话层等等。

Q: 那么为什么要分层？

A: Client 和 Server 进行通信的时候途中会经历很多**中间节点**，如下图：
![-w739](http://pmud0ogk6.bkt.clouddn.com/15495540524424.jpg)

报文经过的节点的路径并无规律可言，并且由于网络的不稳定性（如断电、中间节点的损坏）会导致某次数据传输失败，那么就需要重传数据，在传输过程中，**重传**是一定会发生的，假如数据很大的话，需进行**分块传输**，如下图（假如 ABC 是一个很大的数据）：
![-w756](http://pmud0ogk6.bkt.clouddn.com/15495549695700.jpg)

&gt; 上半部分是分块传输，下半部分是完整的数据传输，上半部分，假如 A、C 送达，但 B 未送达，也就是发送方未收到 B 的送达回应的时候会重传，直到成功送达，此过程中传输了 5 次，假如选择传送完整数据，可能会导致更多次的失败。

分块传输能保证数据完整且高效的送达，分块传输的出现也就导致整个网络需要分层。因为**应用层**并不只有 HTTP，还有 FTP、DNS、TELENET 等等。各个协议都有包分发的需求，所以按照编程的思想，公共的需求可以单独抽取，在网络里即是抽取一层专门处理包的分发，如下：
![-w760](http://pmud0ogk6.bkt.clouddn.com/15495915765603.jpg)

每次数据传输，HTTP 层将包给 TCP 层，TCP 进行分块然后传输，哪个部分丢失了，TCP 会对丢失的部分重传。该层即为**传输层**，TCP 能保证整个过程稳定传输。

但是并不是所有的数据都需要重传，如视频通话，在网络卡顿的时候，丢失的帧不需要重传直接显示最新的视频数据即可，对于语音、视频通话这种要求数据高速度传输和实时到达的需求，UDP 即可满足，UDP 的特点就是：尽最大可能传输，不保证到达，不重传也不需要验证。

UDP 和 TCP 共同的地方就是都需要将数据从一个主机找到另一个主机进行传输，UDP 和 TCP 这种公共的网络需求即可再单独抽取一层，该层即为**网络层**，如下：

![-w713](http://pmud0ogk6.bkt.clouddn.com/15495927038710.jpg)

传输层将数据分块传给网络层，网络层将分块的数据发往目标网络或主机，网络层只管传输，不参与数据的处理，也就是说，它并不知道各个数据块之间的联系，甚至失败、重传也不参与。确认数据的到达在传输层，假如 B 未到，传输层则需要“告知”发送方需要重传，直至 B 到达，传输层则将整包数据拼装好上传至应用层。

应用层、传输层、网络层并未提供实质的物理链路传输仅仅是定义了访问的接口，在整个网络传输的结构中，需要有一个实际的链路来支持传输，那么这个重任就交给**数据链路层**，以太网、路由器等等物理设备或网络就属于这一层，如下图：
![-w714](http://pmud0ogk6.bkt.clouddn.com/15495935578067.jpg)

以上就是传统四层。

因为应用层的各个协议/应用在传输数据的时候都需要对数据分块并且传输，所以传输层出现了，但是数据的传输不一定都要确认送达，只管尽最大可能传输就行（UDP），所以抽取只管负责寻址、寻找主机并且传输数据的一层，网络层也就出现了。


| 各个层级 | 协议/实现 |
| --- | --- |
| 应用层（Application Layer） | HTTP、FTP、DNS | 
| 传输层（Transport Layer） | TCP、UDP |
| 网络层（Internet Layer） | IP |
| 数据链路层（Link Layer） | 以太网、Wi-Fi |

&gt; 数据流向：发送方是自上到下，接收方是自下至上。


### TCP 连接

在计算机世界里，经常能听到「长链接」这个词，那么什么是长链接？在了解长链接之前，什么又是「连接」？

A：连接是 TCP 的连接，并且是有状态的连接，TCP 在发数据之前会将数据分成报文段，然后发向目标主机/网络，在此之前，需要和目标主机/网络**先建立一个互相沟通的确认方案**，接收方需要知道报文段如何拼装，当互相确认的时候，该过程就是 TCP 连接建立的过程，当确认被确定了，就可称作建立了一个连接。

#### TCP 连接建立与关闭

TCP 的建立过程如下图（三次握手）：
![-w449](http://pmud0ogk6.bkt.clouddn.com/15495952284047.jpg)

请求方与被请求方的 TCP 通信流程是：
1. 请求方「告知」被请求方：「我要给你发消息了」
2. 被请求方「回应」请求方：「我知道了，我也要给你发消息了」
3. 请求方「告知」被请求方：「我知道你也要给我发消息了」


当确认后双方都会互相等待发送消息，会占用网络资源，当不需要通信后，则需要 TCP 关闭，TCP 的关闭过程如下图（四次挥手）：
![-w445](http://pmud0ogk6.bkt.clouddn.com/15495954868765.jpg)

1. 请求方「告知」被请求方：「我不再发消息了」
2. 被请求方「回应」请求方：「好的我知道了」，但被请求方不会立即「回应」：「我也不给你发消息了」，此时有可能还有未发完的消息。若有未发送的消息，先发送消息。
3. 被请求方「告知」请求方：「我不再给你发消息了」
4. 请求方「回应」被请求方：「好的我知道了」，双方扔弃资源。

#### 长链接
什么是长链接？**长链接就是强制连接不要被关闭。**

Q: 为什么会出现长链接？

A: 因为并不是所有的设备（电脑、手机等）都在**公网**内，很多设备都在**内网**中，如：公司、小区的内网。**手机就处在运营商部署的内网当中，**内网内的设备想要和外界通信，需要运营商服务器分配的**端口**才能实现。内网内所有主机占用的端口**都是网关的端口**，服务器分配端口是相对耗费资源的，为了节省资源，服务器会检测长时间不发消息的设备会将其端口关闭，这就导致设备无法与外界通信，如手机软件不会收到推送、消息等。为了突破这个限制，需要用「欺骗」网关的方式 —— **心跳**来建立一个长连接，周期时间内设备都会发送一个无用的 TCP 消息，网关会认为该端口一直被占用，所以不会关闭该端口。

## HTTPS
### HTTP over SSL

HTTPS 并不是单独的协议，而是 HTTP 建立在 SSL 上，就称作 HTTPS。

&gt; SSL: Secure Socket Layer（早期），现在为 TLS: Transport Layer Secure。

**SSL 或 TLS 都是建立在 HTTP 之下增加的一个安全层，用于保障 HTTP 的加密传输。**

**HTTPS 的本质是在客户端和服务器之间协商出一个对称密钥，每次发送之前将内容加密，收到之后解密。**

Q: 为什么不直接用非对称加密？
A: 非对称加密很慢，计算过程复杂。

### HTTPS 连接

过程大概如下：
1. 客户端请求建立 TLS 连接；
2. 服务器发回证书；
3. 客户端验证服务器证书；
4. 客户端信任服务器后，和服务器协商对称密钥；
5. 使用对称密钥开始通信。

具体：
1. 客户端先请求和服务端建立连接，发送一个 Client Hello 的消息，表示「我要建立连接」，并附加 TLS 版本和客户端能接受的 Cipher Suite（加密套件，非对称以及对称加密以及哈希算法）信息和随机数；
2. 服务端根据客户端的附带信息选择能支持的 TLS 版本、对应算法，再加上服务器的随机数和客户端发过来的随机数一并打包，随着 Server Hello 返回给客户端；
3. 服务端向客户端发送一个证书，证书的核心是给客户端**公钥**，证书还包含服务器的地址、**证书签名**等信息；
4. 客户端首先验证证书中的服务器地址以及**证书签名**等信息，假如能证书签名验证通过，能够证明服务器的信息是真实的，那么如何验证证书签名？**在 3 中，证书中还会附带签名机构的信息，里面包含证书机构公钥、证书机构其他信息。**假如证书机构公钥能够对证书签名进行验证，那么说明服务器的证书信息是真实的。但是该「真实」是有前提的，仅仅能证明该证书确实是证书机构主人所签发的，无法证明该「主人」就是真实的那个主人，此时证书机构也要提供一个证书机构的签发方信息，也就是跟证书，像循环一样，但到这一步，已无需再附带其他信息，因为该根证书是有可靠来源的，来自操作系统内部，无论是 macOS 还是 Windows 还是 Android、iOS 等都有根证书列表，跟证书列表是被操作系统的研发官方所认证的，如微软、Apple、Google 或各浏览器的官方等，所以只要浏览器和操作系统不被破坏那么这个根证书就是可信赖的。整个嵌套关系如下：
![-w372](http://pmud0ogk6.bkt.clouddn.com/15496283593559.jpg)
在浏览器中，亦可看到该证书层级嵌套。
![-w641](http://pmud0ogk6.bkt.clouddn.com/15496274007388.jpg)
![-w484](http://pmud0ogk6.bkt.clouddn.com/15496274234747.jpg)
顶层为根证书，下一层为证书机构颁发证书，最下层为 Facebook 服务器的证书。

5. 客户端拿到服务器公钥后，会进行整个过程唯一一次非对称加密操作，客户端会对 **Pre-master Secret** 非对称加密（本质还是一个随机数），发给服务端。现在双方已经有足够信息「生产」对称密钥了，此时客户端、服务端会根据 Pre-master Secret、客户端随机数和服务端随机数生产出一个 **Master Secret（它本身并不是密钥）**，Master Secret 可以生产出一个密钥，但密钥实际包括：**客户端加密密钥、服务端加密密钥、客户端 MAC Secret 以及服务端 MAC Secret**，MAC 指 **HMAC（Hash-based Message Authenticate Code）改良版 hash**，MAC Secret    用来做验证身份和签名的操作。
&gt; 虽然两个随机数都是明文传的，但是通过数学原理依然可以达到安全保密的效果。

1. 开始加密通信，将前面的 Client Hello、Server Hello、服务器证书、Pre-master Secret 等使用加密密钥加密使用 MAC Secret 进行类似签名的操作发给服务端，并且会通知服务端「我要开始加密通信了」，同理服务器也会发「我要开始加密通信了」，也会将一系列信息（还包含客户端发来的加密信息和签名信息）打包加密签名发给客户端，客户端同样的验证方式进行验证。至此，验证过程结束，接下来客户端就可以进行正常的 HTTPS 请求了，此为第一个 HTTPS 请求。


Q: 在 5 中为什么生产两个加密密钥？
A: 出于安全考虑，客户端发消息用客户端加密密钥、服务端发消息用服务端加密密钥能勾搭到相对安全的效果。
</code></pre>

    
    </div>
    
    
        <div class="article-comment" id='article-comment'>
            

<h1>Comment</h1>

  
    <div id="comment-not-available">
      Not available
      <p><strong>For site maintainer: Please provide <code>appId</code> and <code>appKey</code> in your <code>_data/cutie.yml</code> file for <code>valine</code> comment system.</strong></p>
    </div>
  


        </div>
        
</article>
  </div>

  

<footer id='footer'>
    <div class='footer-copyright'>
        <div>
            <p> Copyright by <a href=""> </a> @ 2019</p>
            <p>Designed by: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> and <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; Theme: <a href="https://qutang.github.io/cutie/">Cutie 2.1.3-Taurus</a> &bull; Powered by <a href="http://hexo.io">Hexo.</a></p>
        </div>
    </div>
    
    <div class='footer-social'>
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-toc'>
		


<div class='toc-container'>
<i class="far fa-times-circle" id='toc-close' onclick='closeTOC(event);' ontouchstart='closeTOC(event);'></i>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">登录和授权</span></a></li></ol>
</div>
<div class="toc-button" onclick='toggleTOC(event);' ontouchstart='toggleTOC(event);'>
    <img src="/images/icons/blue-shadow/toc.svg" alt="">
</div>

	</div>
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='Archives'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon'>
		
			<a href="/search/" title='Search'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
		
	</div>
	</div>
</nav>

	</div>

  



    







    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type='text/javascript'>
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type='text/javascript'>

  
  // update cookie if this page is opened (directly)
  loadjs(['/libs/jshashes/hashes.min.js', '/libs/js-cookie/src/js.cookie.js', '/js/post.v2.js'], 'post-version');
  loadjs.ready('post-version', function(){
    
    new Postv2('hashit_5d661adf128196fd72b0174dd1459c34026fce19801a7c8b4a3053674288134b').update('hashit_92dff99fb9186bd40dc1bccdcfe3fe62452bf193f4f1111e13f572e884a23984', function(){});
  });
  
</script>



<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant type='text/javascript'>

initHeadroom();

changeLayoutOnTouchScreen();

// 
// var post = new Post('', '');
// post.getCommentCount(window.location.pathname, function(count){
//     $('#article-comment-count').text(count);
// });
// post.addVisitRecord(window.location.pathname, userip);
// post.getVisitCount(window.location.pathname, function(count){
//     $('#article-visit-count').text(count);
// });

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
