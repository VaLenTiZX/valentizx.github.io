<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I&#39;M VALENTI</title>
  
  <subtitle>當我跨過沈淪的一切, 向著永恆開戰的時候, 你是我的軍旗。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-28T14:44:07.901Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Valenti Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP 原理和工作机制（三）</title>
    <link href="http://yoursite.com/2019/02/13/2019-02-06/"/>
    <id>http://yoursite.com/2019/02/13/2019-02-06/</id>
    <published>2019-02-13T02:52:11.000Z</published>
    <updated>2019-03-28T14:44:07.901Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/03/28/5c9cddad5f532.png" alt=""></p><h2>登录和授权</h2><h3>登录</h3><p>身份认证的过程，在输入<strong>账号</strong>和<strong>密码</strong>以及点击登录按钮这一操作流程，就是将「你本人」和所输入的「账号」建立联系的过程。</p><h4>Cookie</h4><p>起源：购物车，当时的「购物车」不存在服务器，电商网站的开发商觉得用户在没有真正决定购买的情况下不需要将购物车的信息放进服务器里，只存在本地就好，于是电商网站开发商决定做一个浏览器来实现这一功能，也就是说，电商网站——浏览器是一体的，并实现了 Cookie 的功能满足购物车的需求，这就是最早的 Cookie。</p><h5>Cookie 的工作机制</h5><p>由于是客户端保存信息，所以保存的信息由服务器决定，服务器返回的信息客户端保存就行了。</p><p>如，在购物车里添加一个苹果，客户端访问服务端 /cart 这个 path，并附带苹果的数量这个参数，表示「我要放进购物车里 1 个苹果」，服务器处理完返回 200，并附带 Set-Cookie 的 Header 表示让客户端存起来。<img src="https://i.loli.net/2019/03/28/5c9cdc093f524.png" alt=""></p><p>下次客户端再访问 shop.com 的时候会附带 cart=&quot;apple=1&quot;，这是一个<strong>自动的过程，并由浏览器实现</strong>。如下次购物车再添加一个香蕉，浏览器会自动附带 cart=&quot;apple=1&quot; 的信息去请求，服务端会知道客户端已经「存储」了一个苹果，处理后返回 200 更新 Set-Cookie 的 Header，此时客户端更新 Cookie。</p><p><img src="https://i.loli.net/2019/03/28/5c9cdc24eb772.png" alt=""></p><p>该过程服务端什么都没记，全都由客户端存储，Cookie 谁来修改？是服务端，每次都是服务端来修改 Cookie 信息，客户端被动的更新、存储。这就是早期的 Cookie 的工作机制。</p><blockquote><p>现在逐渐抛弃用 Cookie 机制来做登录和认证。</p></blockquote><h6>使用 Cookie 管理登录状态</h6><p>客户端使用账号密码访问服务端，服务端确认后，会创建一个<strong>会话（Session）</strong>，会话记录了客户端可能是什么状态、用户代理等信息。然后服务端将 Session 返回给客户端。<img src="https://i.loli.net/2019/03/28/5c9cdc530152b.png" alt=""></p><p>客户端下次访问服务端的时候会附带 sessionid，假如客户端想要请求用户信息，服务端凭借 sessionid 会得知，该客户端在登录状态，可以返回给他要的用户信息。</p><p><img src="https://i.loli.net/2019/03/28/5c9cdc5f39799.png" alt=""></p><p>关于登录状态的管理，服务端是需要插手干预的。</p><h5>Cookie 的作用</h5><ul><li>会话管理：登录状态、购物车等；</li><li>个性化：用户偏好、主题；</li><li>Tracking：分析用户行为（能够得知用户访问哪些网站）。</li></ul><h5>XSS（Cross-site scripting）</h5><p>跨站脚本攻击，假如网站的 javascript 是坏人写的，有可能会将本地的 Cookie 转发出去，这是看不见摸不着的，Cookie 的泄漏也就代表某些敏感信息的泄漏。应对策略就是在 Cookie 的 Header 后加 HttpOnly 的限制，这样本地脚本看不到该 Cookie，该 Cookie 只用于 HTTP 的信息交换。</p><h5>XSRF（Cross-site request forgery）</h5><p>跨站请求伪造，由于 Cookie 是一个<strong>自动</strong>的过程，攻击者可以利用 Cookie 访问授信网站伪装成授信用户进行一些操作。其中一个防范措施就是带上 Referer 的 Header 告诉服务器我是从哪个页面来的，假如来源的这个页面不授信，则服务器拒绝处理。</p><h3>授权</h3><p>赋予某个人具有某个<strong>权限</strong>，能执行什么操作，在计算机世界里，这个特殊的权限叫做<strong>令牌</strong>，就像古代的刽子手本身不具备权限杀人，但是皇上赋予了刽子手行刑的权力，那么刽子手便可以杀人了，皇上就是<strong>授权方</strong>。</p><h4>Basic</h4><p>基本的授权方式，用得较少但是实用，格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authortization: Basic&lt;username:password(Base64ed)&gt;</span><br></pre></td></tr></table></figure></p><h4>Bearer</h4><p>需带着令牌的授权方式，格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Authortization: Basic&lt;bearer token&gt;</span><br><span class="line">token 需要找授权方获得。</span><br></pre></td></tr></table></figure></p><h5>OAuth2</h5><p>提供第三方认证的机制，是一个授权框架，它可以使第三方的应用程序或者客户端获得对应 HTTP 服务器上用户账号信息的访问权限。</p><p>如，在登录<a href="https://juejin.im" target="_blank" rel="noopener">掘金</a>的时候，除了从正常的账号密码登录以外还可以选择三方登录，如 GitHub，在点击 GitHub 登录的时候就会弹出下面的小窗口进行授权。<img src="https://i.loli.net/2019/03/28/5c9cdc7c2b6ea.png" alt=""></p><h6>OAuth2 认证流程</h6><p>认证流程如下图：<img src="https://i.loli.net/2019/03/28/5c9cdc8fc0bd7.png" alt=""></p><p>a. 在这个过程中，本人和 GitHub 是第一、二方，<strong>而掘金是第三方</strong>，所以这个流程的意义就是：GitHub 授权掘金，赋予掘金可以访问 GitHub 账号信息的权限，从而登录掘金的网站。</p><blockquote><p>在该流程中，有一个重要的角色：<strong>client_id</strong>，它是三方网站开发者在开发登录模块是去 Github 申请下来的。相当于标记或者身份证的作用。凭借 client_id 与 Github 沟通，Github 会返回如头像、账号名字、URL 等信息。</p></blockquote><p>b. 当点击上图的 <code>Authorize Xitu</code> 后，少顷，便跳回掘金主页，账号会显示来自 GitHub 的账号。在跳回掘金主页的时候 GitHub 会返回 <strong>Authorization code</strong> 如下图：</p><p><img src="https://i.loli.net/2019/03/28/5c9cdcaceb452.png" alt=""></p><p>Q: 为什么返回的不是 token 而是 Authorization code？A: 因为 OAuth2.0 整个过程不是强制基于 HTTPS 的，那么在返回的过程可能被拦截，假如返回的是真正有意义的信息，那么该有意义的信息可能被窃取；还有一个原因就是<strong>浏览器是不可靠的</strong>，用户用什么浏览器以及操作系统都是未知的，所以在返回的过程中依然存在风险，所以 GitHub 返回的仅仅是一个授权码，仅仅是一个证明，表示用户同意了 GitHub的授权而已。</p><p>c. 接下来在看不见摸不着的背后，掘金带着 Authorization code 和掘金的 Server 端沟通，掘金的 Server 端带着 Authorization code 和 <strong>client_id</strong> 和 GitHub 请求, client_secret 是三方在向 GitHub 申请应用的时候一起申请下来的。client_secret 是绝对保密的，一直存在 Server 端，而 Server 端和 GitHub 的连接也是 HTTPS 连接保证安全。当 Server 端同时具备：身份证明（client_secret）以及用户证明（Authorization code）后，GitHub 便可确认三方的请求连接足够安全，对方足够可靠，<strong>便可放心的将 token 返回给 Server 端</strong>，至此，整个 OAuth2.0 的认证流程结束，第三阶段流程如下图：</p><p><img src="https://i.loli.net/2019/03/28/5c9cdcbf43350.png" alt=""></p><p>d. 当认证流程结束返回到掘金的主页时，此时掘金账号的头像亦是 GitHub 请求下来的，此时的请求流程便是：Server 端带着 token 请求 GitHub 的头像信息，然后进行显示，如下：</p><p><img src="https://i.loli.net/2019/03/28/5c9cdcdae4065.png" alt=""></p><blockquote><p>在某些安全意识不强的情况下，Server 端会把 token 返还给客户端，这种做法就不再具备 OAuth2.0 认证的安全性。</p></blockquote><h6>微信登录</h6><p>微信登录，是一种第三方登录，亦是一个标准的 OAuth2.0 的认证过程，正确的微信登录流程是：</p><p>调用微信的 API 后打开微信的授权界面进行授权，此时是微信在对「你」进行第三方授权，确认返回后，微信会返回一个 <figure class="highlight plain"><figcaption><span>code```，**此时将 Authorization code 交给服务器**，此时，客户端的任务结束，服务端的任务便遵循 OAuth2.0 的流程去和微信的服务器打交道（同上节 OAuth2.0 认证流程一样）。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### 自家产品中使用 Bearer token</span><br><span class="line"></span><br><span class="line">在多数情况下， 调用登录接口并且登录成功的情况下，Server 端会返回 access_token / token，然后请求其他接口的时候 Client 端直接拿着这个 token 请求，这种做法是**模仿了 OAuth2.0 中 access_token 的使用方法**，但并不是 OAuth2.0 的过程。</span><br><span class="line"></span><br><span class="line">###### refresh token</span><br><span class="line"></span><br><span class="line">刷新 token 从 Server 端返回的格式大概是：</span><br></pre></td></tr></table></figure></p><p>{&quot;token_type&quot;: &quot;Bearer&quot;,&quot;access_token&quot;: &quot;xxxx&quot;,&quot;refresh_token&quot;: &quot;xxxx&quot;,&quot;expires_time&quot;: &quot;xxxx&quot;}</p><pre><code>refresh_token 的作用是，以此请求一个新的 access_token 和一个新的 refresh_token，那么旧的 token 会失效，refresh_token 存在的意义就是保证安全，因为 access_token 还是有概率会丢失，如果是授权登录，丢失 access_token 会导致用户再次认证、登录，这样的操作极不友好，所以需要借助 refresh_token 来获取新的 access_token 并且将旧的“作废”。**这个过程还是尽量保证在 Server 端。**## TCP/IP 协议族**TCP/IP 协议族并不是单指 TCP 和 IP 的构成，而是一系列协议组成的一个网络模型分层。**在很多有关网络的文章亦或是大学的计算机网络课程中，「分层」这个词出现的频率极高，如物理链路层、表示层、会话层等等。Q: 那么为什么要分层？A: Client 和 Server 进行通信的时候途中会经历很多**中间节点**，如下图：![](https://i.loli.net/2019/03/28/5c9cdcea0e39c.png)报文经过的节点的路径并无规律可言，并且由于网络的不稳定性（如断电、中间节点的损坏）会导致某次数据传输失败，那么就需要重传数据，在传输过程中，**重传**是一定会发生的，假如数据很大的话，需进行**分块传输**，如下图（假如 ABC 是一个很大的数据）：![](https://i.loli.net/2019/03/28/5c9cdcf972448.png)&gt; 上半部分是分块传输，下半部分是完整的数据传输，上半部分，假如 A、C 送达，但 B 未送达，也就是发送方未收到 B 的送达回应的时候会重传，直到成功送达，此过程中传输了 5 次，假如选择传送完整数据，可能会导致更多次的失败。分块传输能保证数据完整且高效的送达，分块传输的出现也就导致整个网络需要分层。因为**应用层**并不只有 HTTP，还有 FTP、DNS、TELENET 等等。各个协议都有包分发的需求，所以按照编程的思想，公共的需求可以单独抽取，在网络里即是抽取一层专门处理包的分发，如下：![](https://i.loli.net/2019/03/28/5c9cdd1bd767b.png)每次数据传输，HTTP 层将包给 TCP 层，TCP 进行分块然后传输，哪个部分丢失了，TCP 会对丢失的部分重传。该层即为**传输层**，TCP 能保证整个过程稳定传输。但是并不是所有的数据都需要重传，如视频通话，在网络卡顿的时候，丢失的帧不需要重传直接显示最新的视频数据即可，对于语音、视频通话这种要求数据高速度传输和实时到达的需求，UDP 即可满足，UDP 的特点就是：尽最大可能传输，不保证到达，不重传也不需要验证。UDP 和 TCP 共同的地方就是都需要将数据从一个主机找到另一个主机进行传输，UDP 和 TCP 这种公共的网络需求即可再单独抽取一层，该层即为**网络层**，如下：![](https://i.loli.net/2019/03/28/5c9cdd2c73fd8.png)传输层将数据分块传给网络层，网络层将分块的数据发往目标网络或主机，网络层只管传输，不参与数据的处理，也就是说，它并不知道各个数据块之间的联系，甚至失败、重传也不参与。确认数据的到达在传输层，假如 B 未到，传输层则需要“告知”发送方需要重传，直至 B 到达，传输层则将整包数据拼装好上传至应用层。应用层、传输层、网络层并未提供实质的物理链路传输仅仅是定义了访问的接口，在整个网络传输的结构中，需要有一个实际的链路来支持传输，那么这个重任就交给**数据链路层**，以太网、路由器等等物理设备或网络就属于这一层，如下图：![](https://i.loli.net/2019/03/28/5c9cdd3a9a436.png)以上就是传统四层。因为应用层的各个协议/应用在传输数据的时候都需要对数据分块并且传输，所以传输层出现了，但是数据的传输不一定都要确认送达，只管尽最大可能传输就行（UDP），所以抽取只管负责寻址、寻找主机并且传输数据的一层，网络层也就出现了。| 各个层级 | 协议/实现 || --- | --- || 应用层（Application Layer） | HTTP、FTP、DNS | | 传输层（Transport Layer） | TCP、UDP || 网络层（Internet Layer） | IP || 数据链路层（Link Layer） | 以太网、Wi-Fi |&gt; 数据流向：发送方是自上到下，接收方是自下至上。### TCP 连接在计算机世界里，经常能听到「长链接」这个词，那么什么是长链接？在了解长链接之前，什么又是「连接」？A：连接是 TCP 的连接，并且是有状态的连接，TCP 在发数据之前会将数据分成报文段，然后发向目标主机/网络，在此之前，需要和目标主机/网络**先建立一个互相沟通的确认方案**，接收方需要知道报文段如何拼装，当互相确认的时候，该过程就是 TCP 连接建立的过程，当确认被确定了，就可称作建立了一个连接。#### TCP 连接建立与关闭TCP 的建立过程如下图（三次握手）：![](https://i.loli.net/2019/03/28/5c9cdd55754e2.png)请求方与被请求方的 TCP 通信流程是：1. 请求方「告知」被请求方：「我要给你发消息了」2. 被请求方「回应」请求方：「我知道了，我也要给你发消息了」3. 请求方「告知」被请求方：「我知道你也要给我发消息了」当确认后双方都会互相等待发送消息，会占用网络资源，当不需要通信后，则需要 TCP 关闭，TCP 的关闭过程如下图（四次挥手）：![](https://i.loli.net/2019/03/28/5c9cdd5fd454d.png)1. 请求方「告知」被请求方：「我不再发消息了」2. 被请求方「回应」请求方：「好的我知道了」，但被请求方不会立即「回应」：「我也不给你发消息了」，此时有可能还有未发完的消息。若有未发送的消息，先发送消息。3. 被请求方「告知」请求方：「我不再给你发消息了」4. 请求方「回应」被请求方：「好的我知道了」，双方扔弃资源。#### 长链接什么是长链接？**长链接就是强制连接不要被关闭。**Q: 为什么会出现长链接？A: 因为并不是所有的设备（电脑、手机等）都在**公网**内，很多设备都在**内网**中，如：公司、小区的内网。**手机就处在运营商部署的内网当中，**内网内的设备想要和外界通信，需要运营商服务器分配的**端口**才能实现。内网内所有主机占用的端口**都是网关的端口**，服务器分配端口是相对耗费资源的，为了节省资源，服务器会检测长时间不发消息的设备会将其端口关闭，这就导致设备无法与外界通信，如手机软件不会收到推送、消息等。为了突破这个限制，需要用「欺骗」网关的方式 —— **心跳**来建立一个长连接，周期时间内设备都会发送一个无用的 TCP 消息，网关会认为该端口一直被占用，所以不会关闭该端口。## HTTPS### HTTP over SSLHTTPS 并不是单独的协议，而是 HTTP 建立在 SSL 上，就称作 HTTPS。&gt; SSL: Secure Socket Layer（早期），现在为 TLS: Transport Layer Secure。**SSL 或 TLS 都是建立在 HTTP 之下增加的一个安全层，用于保障 HTTP 的加密传输。****HTTPS 的本质是在客户端和服务器之间协商出一个对称密钥，每次发送之前将内容加密，收到之后解密。**Q: 为什么不直接用非对称加密？A: 非对称加密很慢，计算过程复杂。### HTTPS 连接过程大概如下：1. 客户端请求建立 TLS 连接；2. 服务器发回证书；3. 客户端验证服务器证书；4. 客户端信任服务器后，和服务器协商对称密钥；5. 使用对称密钥开始通信。具体：1. 客户端先请求和服务端建立连接，发送一个 Client Hello 的消息，表示「我要建立连接」，并附加 TLS 版本和客户端能接受的 Cipher Suite（加密套件，非对称以及对称加密以及哈希算法）信息和随机数；2. 服务端根据客户端的附带信息选择能支持的 TLS 版本、对应算法，再加上服务器的随机数和客户端发过来的随机数一并打包，随着 Server Hello 返回给客户端；3. 服务端向客户端发送一个证书，证书的核心是给客户端**公钥**，证书还包含服务器的地址、**证书签名**等信息；4. 客户端首先验证证书中的服务器地址以及**证书签名**等信息，假如能证书签名验证通过，能够证明服务器的信息是真实的，那么如何验证证书签名？**在 3 中，证书中还会附带签名机构的信息，里面包含证书机构公钥、证书机构其他信息。**假如证书机构公钥能够对证书签名进行验证，那么说明服务器的证书信息是真实的。但是该「真实」是有前提的，仅仅能证明该证书确实是证书机构主人所签发的，无法证明该「主人」就是真实的那个主人，此时证书机构也要提供一个证书机构的签发方信息，也就是跟证书，像循环一样，但到这一步，已无需再附带其他信息，因为该根证书是有可靠来源的，来自操作系统内部，无论是 macOS 还是 Windows 还是 Android、iOS 等都有根证书列表，跟证书列表是被操作系统的研发官方所认证的，如微软、Apple、Google 或各浏览器的官方等，所以只要浏览器和操作系统不被破坏那么这个根证书就是可信赖的。整个嵌套关系如下：![](https://i.loli.net/2019/03/28/5c9cdd79476d9.png)在浏览器中，亦可看到该证书层级嵌套。![](https://i.loli.net/2019/03/28/5c9cdd890c188.png)![](https://i.loli.net/2019/03/28/5c9cdd96b4ea9.png)顶层为根证书，下一层为证书机构颁发证书，最下层为 Facebook 服务器的证书。5. 客户端拿到服务器公钥后，会进行整个过程唯一一次非对称加密操作，客户端会对 **Pre-master Secret** 非对称加密（本质还是一个随机数），发给服务端。现在双方已经有足够信息「生产」对称密钥了，此时客户端、服务端会根据 Pre-master Secret、客户端随机数和服务端随机数生产出一个 **Master Secret（它本身并不是密钥）**，Master Secret 可以生产出一个密钥，但密钥实际包括：**客户端加密密钥、服务端加密密钥、客户端 MAC Secret 以及服务端 MAC Secret**，MAC 指 **HMAC（Hash-based Message Authenticate Code）改良版 hash**，MAC Secret    用来做验证身份和签名的操作。&gt; 虽然两个随机数都是明文传的，但是通过数学原理依然可以达到安全保密的效果。1. 开始加密通信，将前面的 Client Hello、Server Hello、服务器证书、Pre-master Secret 等使用加密密钥加密使用 MAC Secret 进行类似签名的操作发给服务端，并且会通知服务端「我要开始加密通信了」，同理服务器也会发「我要开始加密通信了」，也会将一系列信息（还包含客户端发来的加密信息和签名信息）打包加密签名发给客户端，客户端同样的验证方式进行验证。至此，验证过程结束，接下来客户端就可以进行正常的 HTTPS 请求了，此为第一个 HTTPS 请求。Q: 在 5 中为什么生产两个加密密钥？A: 出于安全考虑，客户端发消息用客户端加密密钥、服务端发消息用服务端加密密钥能勾搭到相对安全的效果。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/28/5c9cddad5f532.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;登录和授权&lt;/h2&gt;
&lt;h3&gt;登录&lt;/h3&gt;
&lt;p&gt;身份认证的过程，在输入&lt;strong&gt;账号&lt;/strong&gt;和&lt;stro
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 原理和工作机制（二）</title>
    <link href="http://yoursite.com/2019/01/24/2019-01-24/"/>
    <id>http://yoursite.com/2019/01/24/2019-01-24/</id>
    <published>2019-01-24T07:03:43.000Z</published>
    <updated>2019-01-24T07:04:37.324Z</updated>
    
    <content type="html"><![CDATA[<h2>加密与解密 Encryption &amp; Decryption</h2><h3>古典密码学</h3><p>起源：古代战争 - 古典密码学，为防止「信使」被敌方掳获获得我方情报，诞生了最初代的古典密码学，其代表加密工具就为 - <strong>密码棒</strong>，如下图：<img src="https://upload-images.jianshu.io/upload_images/453168-efb45ab1f54a5b21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>密码棒的规格是严格定制的，发情报的一方和收情报的一方是一一对应的，如上图中每一面都是对应的加密信息。</p><p><strong>加密的意义不在于信息不被侵犯，而在于被侵犯获取后不被破解。</strong></p><p>其实，密码棒中就已经包含了密码学最重要的两个因素：<strong>加密算法</strong>和<strong>密钥</strong>，在密码棒中，加密算法即为缠绕方式，密钥则是木棒的规格。</p><p>古典密码学加密方式分为：<strong>移位式加密</strong>和<strong>替换式加密</strong>，密码棒就属于典型的移位式加密，而替换式加密的代表就是替换文字加密，如：发送方需要发送的是 Christina Aguilera，加密规则为：<strong>每个字符都替换成它的下一位</strong>，于是密文就变成了：Disjtujob Bhvjmfsb在此过程，加密算法则为：替换文字，密钥为：码表（表示信息和加密后的密文一一对应的映射关系）。当双方都拿着一样的码表便可以进行通信了。</p><h3>现代密码学</h3><p>当计算机发展高速的时候，这些加密的思想便应用到计算机领域当中，一些高深复杂的数学知识可以完美的应用到加密算法中，这样得到的密文很难破解。于是，诞生了<strong>现代密码学</strong>，现代密码学不止用于文字，还可以用于二进制数据。</p><p>现代密码学的加密方式同样分为两种：<strong>对称加密</strong>和<strong>非对称加密</strong>，对称加密和移位式加密很像，但是要复杂得多。</p><h4>对称加密</h4><p><strong>对称加密的原理：使用密钥和加密算法对数据进行转换，得到的无意义数据即为密文；使用解密算法和密钥进行逆向转换，得到原数据。</strong></p><p><strong>经典算法：DES（密钥太短容易被破解被弃用）、AES。</strong></p><blockquote><p>一个优秀的加密算法是让破解方使用**穷举法（在此通俗理解就是破解方把可能性范围内所有的密钥去破解的这种暴力破解方法）**才能破解的算法，也就是指花费破解方时间成本最高、精力成本最高的算法。当破解时间达到一个很大的值如 1000 年、10000 年则可认为该密文不能破解，在计算机发展的今天 AES 可以满足对称加密需求，在未来的一段时间内，硬件的不断更新迭代，计算的速度越来越大，AES 的密钥必定不能满足对称加密需求。</p></blockquote><h4>非对称加密</h4><p><strong>非对称加密原理：使用公钥对数据进行加密得到密文；使用私钥数据即行解密得到原数据</strong></p><p>非对称加密相对对称加密的优点是：密钥可以放心的在网络之间传输。对称加密的传输过程中，一旦密钥被截取，那么本次传输也就不再安全。</p><p>非对称加密的通信过程如下图：<img src="https://upload-images.jianshu.io/upload_images/453168-04e7aafc06077b26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在传输前 A、B 双方会得到对方的公钥，当 A 给 B 发信息的时候，会先用 B 的公钥进行加密，B 收到 A 的密文拿着自己的私钥解密得到原始数据，B 给 A 发信息同样如此，加入通信过程中 C 截获了消息，并且截获了公钥 A 和公钥 B，他是没有办法破解原始数据的，因为解密的关键私钥 A 和私钥 B 在 A、B 双方安全的保存。</p><blockquote><p>私钥能解公钥，公钥亦能解私钥，但是公钥和私钥不能置换使用，因为很多时候公钥是根据私钥计算出来的，如应用在比特币身上的加密算法-椭圆曲线算法中公钥就是根据私钥计算的，假设公私钥置换使用，破解方截获了私钥，也就意味着破解方同时拥有了公钥和私钥。</p></blockquote><p>--** ⚠️上述过程中，同样有潜在的不安全问题在，当 C 截获了公钥 A 和公钥 B 的时候，C 是可以伪造 A 的身份（因为他有公钥 B）与 B 进行通信，那么这个问题该如何解决？签名就发挥作用了。**</p><h5>签名与验证</h5><p><strong>非对称加密一个很重要的延伸用途：数字签名。</strong></p><h6>签名与验证的过程</h6><p>签名和验证的意义就在于：要让别人知道，这则消息是「我」本人发出的。也就是说「我」用「我」的私钥加密了信息，别人拿着「我」的公钥能还原信息并能确认是「我」本人的信息。就好比一张欠条，别人一看就能知道，是我本人亲自签署的。这时候，「签署」和「签名」有着相同的意味。加密和验证的过程如下图：<img src="https://upload-images.jianshu.io/upload_images/453168-9870ed460e7066c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>与加密相反的是，<strong>签名是用私钥签名，然后对方通过公钥验证，而加密则是原数据通过对方公钥加密，对方通过手中的私钥解密得到原数据。</strong></p></blockquote><p>签名过程通常会携带原数据，方便验证方通过公钥得到的原数据和携带的原数据进行对比从而得到验证结果。</p><h6>签名 + 加密</h6><p>过程如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/453168-b4b55b6408c1060d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>原数据会使用对方公钥进行加密得到密文，同时需要身份验证，所以要使用私钥加密得到签名数据，最终得到<strong>密文+签名数据</strong>就是签了名的加密数据。</p><p>上一节 ⚠️ 部分中一个安全隐患，就可以通过加密+签名的机制来解决，当 B 拿到数据后通过解密和验证后可得知该消息是否真的来自 A。</p><p><strong>非对称加密的经典算法：RSA 和 DSA，DSA 专门用来签名，而 RSA 签名加密解密都可以。</strong></p><blockquote><p>DSA 设计方式特殊，它的签名和验证过程非常之快，所以只用来签名。椭圆曲线算法就属于 DSA。</p></blockquote><p>--</p><blockquote><p>同样的，一个优秀的非对称加密算法同样是破解方只能通过「穷举法」去破解。</p></blockquote><h6>密码学密钥和登录密码</h6><p>二者除了有个“密”字没有任何关系。</p><ul><li>密钥（Key）：用于加密和解密，属于数学的领域，目的是保证数据被盗时不被人看懂；</li><li>登录密码（Password）：用于用户的身份验证，不需要任何数学方面的计算和证明，目的是为了给服务方提供「你是你」的证明。</li></ul><h2>编码与解码 Encoding &amp; Decoding</h2><h3>Base64</h3><h4>Base64 是什么？</h4><p>它是将二进制数据转换成 64 个字符组成的字符串的编码算法。</p><h4>什么是二进制数据？</h4><p><strong>非文本数据就是二进制数据，广义的计算机数据都是二进制数据。</strong></p><h4>Base64 转换</h4><p>Base64 的码表：</p><table><thead><tr><th>Index</th><th>Char</th><th>Index</th><th>Char</th><th>Index</th><th>Char</th><th>Index</th><th>Char</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>16</td><td>Q</td><td>32</td><td>g</td><td>48</td><td>w</td></tr><tr><td>1</td><td>B</td><td>17</td><td>R</td><td>33</td><td>h</td><td>49</td><td>x</td></tr><tr><td>2</td><td>C</td><td>18</td><td>S</td><td>34</td><td>i</td><td>50</td><td>y</td></tr><tr><td>3</td><td>D</td><td>19</td><td>T</td><td>35</td><td>j</td><td>51</td><td>z</td></tr><tr><td>4</td><td>E</td><td>20</td><td>U</td><td>36</td><td>k</td><td>52</td><td>0</td></tr><tr><td>5</td><td>F</td><td>21</td><td>V</td><td>37</td><td>l</td><td>53</td><td>1</td></tr><tr><td>6</td><td>G</td><td>22</td><td>W</td><td>38</td><td>m</td><td>54</td><td>2</td></tr><tr><td>7</td><td>H</td><td>23</td><td>X</td><td>39</td><td>n</td><td>55</td><td>3</td></tr><tr><td>8</td><td>I</td><td>24</td><td>Y</td><td>40</td><td>o</td><td>56</td><td>4</td></tr><tr><td>9</td><td>J</td><td>25</td><td>Z</td><td>41</td><td>p</td><td>57</td><td>5</td></tr><tr><td>10</td><td>K</td><td>26</td><td>a</td><td>42</td><td>q</td><td>58</td><td>6</td></tr><tr><td>11</td><td>L</td><td>27</td><td>b</td><td>43</td><td>r</td><td>59</td><td>7</td></tr><tr><td>12</td><td>M</td><td>28</td><td>c</td><td>44</td><td>s</td><td>60</td><td>8</td></tr><tr><td>13</td><td>N</td><td>29</td><td>d</td><td>45</td><td>t</td><td>61</td><td>9</td></tr><tr><td>14</td><td>O</td><td>30</td><td>e</td><td>46</td><td>u</td><td>62</td><td>+</td></tr><tr><td>15</td><td>P</td><td>31</td><td>f</td><td>47</td><td>v</td><td>63</td><td>/</td></tr></tbody></table><p>Base64 有 64 个字符可表示内容，其中每一个字符都要对应上述码表中的一个数，2 的 6 次方是 64，如超出 6 位，该码表就无法表达内容，故划分 6 个 Bits 为一个单元。</p><p>下面的例子，「Man(ASCII 编码)」：</p><p>M 的二进制数据为：<strong>010011</strong>01；a 的二进制数据为：<strong>011000</strong>01；n 的二进制数据为：<strong>011011</strong>10。</p><p>每个字母的二进制数据 <strong>6 个为一组</strong>，得到M：010011 + 01；a：011000 + 01；n：011011 + 10。</p><p>M 的前六位的十进制为 19，19 对应上述码表 T，剩下两位和 a 的前四位组合转化成十进制为得到 22 对应 W，a 的后四位和 n 的前两位组合转换十进制为 5 对应 F，n  的后六位对应 u。</p><p>所以对「Man」进行 Base64 转码得到 TWFu，由此可见 Base64 转化后的数据明显「增大了」，由 3 个变成了 4 个，那么为什么不选用 Base256 也就是 2 的 8 次方表示呢？因为常见的字符合集不够 256 个，无法满足需求。</p><p>**Base64 的用途：</p><ol><li>让原数据具有字符串所具有的特性，如可以放在 URL 中传输、可以保存文本文件等；</li><li>人眼无法识别，降低头盔风险。**</li></ol><p><strong>Base64 加密传输图片，可以更高效更安全？</strong>安全只能靠加密保证，Base64 不具备加密效果，没有任何安全性可言；高效也是错的，通过 Base64 编过的数据已经变大了很多，延长了传输时间，反而降低了效率。</p><h5>Base58</h5><p>Base64 的变种，去掉了 Base64 种 0 和大写 O，小写 l 和小写 I 以及 + 和 /，Base58 主要用在比特币（或其他币）领域的地址上，该地址可能被<strong>手抄</strong>，那么 0 和 O以及 l 和 I 会造成混淆，至于去掉 + 和 / 是为了方便双击复制。</p><h4>Base64 的重要应用</h4><p>URL encoding：将 URL 中的保留字符使用 % 进行编码。</p><p><strong>为什么使用 % 的特定编码方式？原因在下。</strong></p><p>示例：当在地址栏中输入 https://facebook.com/张雷克斯 (这是一个不存在的网页)，浏览器会显示：<img src="https://upload-images.jianshu.io/upload_images/453168-29fcf3419da38e8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>当把地址栏的地址拷贝到一个文本编辑器中的时候会变成：https://www.facebook.com/%E5%BC%A0%E9%9B%B7%E5%85%8B%E6%96%AF 这样的结果。中文的部分变成了看不懂的字符，那是应为浏览器不支持显示中文，转换成其他字符，另，「/」和「+」在 URL 中有特定的含义，为了消除歧义选择了 % 编码，能避免分析错误。</p><h2>压缩与解压缩 Compression &amp; Decompression</h2><p><strong>压缩：把数据换一种方式来存储，以减小存储空间。</strong><strong>解压缩：将压缩后的数据还原。</strong></p><p><strong>常见的压缩算法：DEFLATE、JPEG、MP3</strong></p><blockquote><p>zip 的归档方式使用的压缩算法就是 DEFLATE，JPEG 就是对图片处理的压缩算法，MP3 则为对音频处理的压缩算法。</p></blockquote><p>压缩属于编码吗？</p><p>要弄清楚这个问题首先要明白编码到底是什么？<strong>其实，编码没有实际的定义，但通俗来理解，就是从一个格式转换成另一个格式并且可以转回来，在转换的过程中不丢失信息不增加信息，这个过程叫编码</strong>，所以压缩是完全属于编码。</p><h3>媒体数据的编码</h3><p><strong>图片的编码：把图像数据写成 JPG、PNG 等文件的编码格式。</strong><strong>图片的解码：把 JPG、PNG 等文件中的数据解析成标准的图像数据。</strong></p><p>音视频的编解码同理。</p><blockquote><p>媒体文件中还存在<strong>有损压缩</strong>，但不妨碍对媒体数据的解读。</p></blockquote><h2>序列化 Serialization</h2><p><strong>序列化：把数据对象（一般是内存中的，如 JVM 中的对象）转换成字节序列的过程。</strong></p><p><strong>反序列化：把字节序列重新转换成内存中的对象。</strong></p><blockquote><p>通俗点说，序列化的过程就是将内存中的数据转换成可以存储的线性的格式，如 JSON 格式、xml 格式。目的是让内存中的对象可以与外界通信（存储、传输）。</p></blockquote><p><strong>序列化属于编码吗？</strong></p><p>严格来说，编码是两个不同的格式互相转换，而序列化是内存中的数据转换成可通信的格式。但广义上来说也属于编码。</p><h2>哈希 Hash</h2><p><strong>定义：把任意数据转换成制定大小范围（通常很小）的数据。</strong></p><p><strong>作用：摘要、数字指纹。</strong></p><p>计算机领域当中的某个数据可能非常大，我们在描述它的时候不希望将整个的数据进行描述，而是通过一个指代它的很小的字节就可以描述。这就是 hash 值的作用。</p><p>经典算法：<strong>MD5</strong>、<strong>SHA1</strong>、<strong>SHA256</strong>等。</p><blockquote><p>优秀的 Hash 算法是计算出的结果之间不会碰撞，即碰撞率极低。</p></blockquote><p><strong>实际用途：</strong></p><ul><li>数据完整性验证；如下载某个开源包或者某个安装包时，发布方都会提供一个或多个 hash 值，下载后对下载文件计算 hash 值，如果和发布方的相同则表示是完整的。</li><li>快速查找：hashCode() 和 HashMap；</li><li>隐私保护。</li></ul><p><strong>Java 开发中通常在重写 equals() 方法的同时要重写 hashCode()，为什么？</strong></p><p>假如有 Singer 类：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Singer&#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">         return age == obj.age &amp;&amp; name.equals(obj.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public long hashCode() &#123;</span><br><span class="line">    return age + name.length()  // 简单的 hash code     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hashCode 是用来做身份验证和识别的，在 hashCode() 中有 N 多的方法可以提高该对象 hash 值的唯一性。hashCode 直接影响 HashMap、HashSet 等的内存地址定位。HashMap 的对象是根据 Key 的 hash code 来获取对应 Value。当 Singer 类的 hashCode() 方法重写的不严谨时，算出的 hash code 是一个非常简单的值会导致两对象的 Key 指向同一个 Value，修改 A 后再修改会 B 会把 A 的 Value 替换掉。</p><p>所以重写 hashCode() 后与 HashMap 等相关的操作才能<strong>正常使用</strong>，使用 hashCode() 性能会比较好。</p><p>为什么需要同时写呢？因为 hash code 只是简单的对对象进行比对，并不会比对两个对象属性的具体信息。假如没重写 hashCode() 方法，会调用其父类默认的 hashCode() 方法，这会导致调用 equals() 方法比对两对象不相等但比对 hashCode() 方法的结果的时候相等。</p><p>重写并严谨的重写两个方法可以大大提升开发效率。</p><blockquote><p>⚠️ Hash 不是编码，是单向的，不能够还原。⚠️ Hash 不是加密，MD5 亦不是加密。</p></blockquote><h3>Hash 和非对称加密</h3><p>在非对称加密传输过程中，一个文件的大小约在 10G 左右，那么通过加密算法签名后的签名数据也为 10G 左右，再加上需要验证的原数据则一共为 20G，数据太过臃肿，在实际生活中，签名的过程为：先对原数据进行哈希，再对哈希值签名。完整的过程为：</p><p><img src="https://upload-images.jianshu.io/upload_images/453168-0404f762e7f1ca28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2>字符集 Charset</h2><p><strong>含义：一个由整数向现实世界中符号的 Map。</strong></p><p><strong>分支：</strong></p><ul><li>ASCII: 128 个字符，1 字节；</li><li>ISO-9885-1: 对 ASCII 的扩充，1 字节；</li><li>Unicode: 13 万个字符，多字节，UTF-8/UTF-16 是他的编码分支；</li><li>GB 系列: 中国自研标准，多字节。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;加密与解密 Encryption &amp;amp; Decryption&lt;/h2&gt;
&lt;h3&gt;古典密码学&lt;/h3&gt;
&lt;p&gt;起源：古代战争 - 古典密码学，为防止「信使」被敌方掳获获得我方情报，诞生了最初代的古典密码学，其代表加密工具就为 - &lt;strong&gt;密码棒&lt;/strong
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 的原理和工作机制</title>
    <link href="http://yoursite.com/2019/01/20/2019-01-20/"/>
    <id>http://yoursite.com/2019/01/20/2019-01-20/</id>
    <published>2019-01-19T18:31:52.000Z</published>
    <updated>2019-01-24T07:02:30.053Z</updated>
    
    <content type="html"><![CDATA[<h2>HTTP 是什么？</h2><p><strong>Hyper Text Transfer Protocol</strong> 超文本传输协议，是一种 Client 和 Server 之间请求和应答的标准，目的是更高效的进行网络传输。</p><h2>HTTP 工作方式</h2><p>用户最直观的感受就是浏览器地址栏键人地址-&gt;回车-&gt;看到浏览器呈现的网页，这个过程简单的流程就是：浏览器发送请求到服务器，服务器响应请求，浏览器通过渲染引擎渲染网页结果，渲染引擎也就是浏览器的内核。</p><p><img src="https://upload-images.jianshu.io/upload_images/453168-f77d2d4e7129ec30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>示例地址：https://twitter.com/shaddeen_/followers</p><blockquote><p><a href="https://twitter.com/shaddeen_/followers" target="_blank" rel="noopener">shaddeen</a>，是小众音乐播放器 Loud 和 SmartPlayer 的作者。</p></blockquote><p>所以在这个从按下回车到直观看到界面的过程就简单的概括为 3 步：</p><ol><li>请求</li><li>响应</li><li>渲染</li></ol><p>在请求的过程中，浏览器地址栏的 <strong>URL 转化成 HTTP 报文</strong>进行发送，一个 URL 大致分为三个部分：<strong>https/http: 协议类型</strong>、<strong>twitter.com 服务器地址</strong>和<strong>shaddeen_/followers 路径(path)</strong>。</p><p>请求发送的形式就变成：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /shaddeen_/followers HTTP/1.1</span><br><span class="line">Host: twitter.com</span><br></pre></td></tr></table></figure></p><p>在这个过程中，两个极其重要的角色也就出现了：Request 和 Response。</p><h3>Request 报文格式</h3><p>简易的 Request 报文格式如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /shaddeen_/followers HTTP/1.1</span><br><span class="line">Host: twitter.com</span><br></pre></td></tr></table></figure></p><p><strong>GET /shaddeen_/followers HTTP/1.1</strong>为一个<strong>请求行</strong>，分三个部分：</p><ul><li><strong>GET</strong> 为 请求 method；</li><li><strong>/shaddeen_/followers</strong> 为 path，负责定位；</li><li><strong>HTTP/1.1</strong> 为 HTTP Version，现在绝大多数的浏览器的网页显示 HTTP 版本都是 1.1。</li></ul><p><strong>Host: twitter.com</strong> 为请求 Headers，可为多行**（包括更多的内容如 Content-Type: text/plain Content-Length: 240）**。另，请求可以加入 <strong>Body</strong>，可以加入实际的内容，该内容是服务器需要处理的。Body 和请求行中的 path 都是和服务器对接并需要服务器处理的，但是各自角色的定位并不一样。</p><h3>Response 报文格式</h3><p>Response 的报文同样也有 Headers 和 Body，相比 Request 无请求行，多了一个状态行，例：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">状态行⬇️</span><br><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Headers⬇️</span><br><span class="line">content-type: application/json; charset=utf-8</span><br><span class="line">cache-control: public, max-age=60, s-maxage=60</span><br><span class="line">vary: Accept, Accept-Encoding</span><br><span class="line">etag: W/&quot;02fjsdarwr080823f&quot;</span><br><span class="line">content-encoding: gzip</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Body⬇️</span><br><span class="line">[</span><br><span class="line">    name: &quot;shaddeen_&quot;,</span><br><span class="line">    id: &quot;2342242&quot;,</span><br><span class="line">    follow_list: [</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>HTTP/1.1 200 OK</strong> 亦分为三个部分：</p><ul><li><strong>HTTP/1.1</strong> HTTP 版本；</li><li><strong>200</strong> status code 状态码；</li><li><strong>OK</strong> status message 状态信息。</li></ul><p>这三部分的组合可以简单地描述一次请求。</p><h2>Request Method</h2><ul><li>GET <strong>获取资源，无 body</strong>，简单的来说就是从网上取东西；</li><li>POST <strong>增加或修改资源，有 body</strong>，要把修改的内容放进 body 里给服务器进行处理；</li><li>PUT <strong>修改资源， 有 body</strong>，它和 GET 有个共同的特点就是**幂等（一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同，在这里指多次操作对于服务器没有影响）**的；</li><li>DELETE <strong>删除资源，无 body</strong>，同样具有幂等性；</li><li>HEAD <strong>几乎和 GET 是一样的，区别在于服务器返回内容的时候不会返回 body</strong>，当做下载功能的时候通常需要预先知道该文件有多大或更多的信息，此时 HEAD 通过请求会得到这些信息，然后再进行一步处理。</li></ul><h2>Status Code</h2><p><strong>作用：对结果作出类型化描述（如「成功」、「未找到」）。</strong></p><p>通常规范化的状态码有 5 类，分类是为了方便调试：</p><ul><li>1xx: 临时性消息，通常为 100 和 101。100，表示初始的请求已经接受，客户端可以接着进行下面的请求，如上传一个大文件，在试探性请求服务器的过程中，会把一些描述信息放进 Header 中与服务器沟通试探服务器是否接受，如服务器返回 100 则客户端可以进行下面的操作。101 表示服务器回应客户端「支持 HTTP/2.0」，此时客户端下一次的请求就可以切换为为 HTTP/2.0，当不支持 HTTP/2.0 的时候会返回 200，那么客户端下一次请求则使用 HTTP/1.1 ；</li><li>2xx: 成功；</li><li>3xx: 重定向，如地址栏键入 http://www.google.com ，浏览器会重定向到 https://www.google.com ，该过程是一个自动的二次请求过程，就是通过返回的 301 (Moved Permanently 永久性迁移， 302 为临时迁移，304 表示内容没有改变，F5 重新刷新该网页）状态码来告诉客户端重新请求；</li><li>4xx: 客户端（浏览器、手机软件）错误，如参数错误，服务器无法识别该请求，是可以修正的；</li><li>5xx: 服务器错误，如资源不足、资源找不到。</li></ul><h2>Header</h2><p>作用：Header 描述了 HTTP 消息的<strong>元信息 (Meta Data)</strong>，通俗地说就是<strong>描述数据的数据</strong>，如：该消息有多长？是什么格式？数据有没有压缩？返回的数据是什么字符集等等。</p><h3>Host</h3><p>在前面的例子中，有一个 Host 的字段，它表示服务器主机地址，但是它不是用来寻址的，<strong>寻址的过程在发送请求之前就已经做好了</strong>。</p><blockquote><p>在发送请求前，浏览器会带着域名「询问」 <strong>DNS（Domain Name System 域名系统）</strong> 目标 <strong>IP 地址</strong>，然后 DNS 返回一个或多个 IP 地址，然后通过 IP 地址去寻址，然后发送报文给目标服务器。</p></blockquote><p><strong>那么为什么在请求 Header 中为什么还要带上 Host ？</strong></p><p>是因为一个服务器主机下可能有多个虚拟主机或多个子服务器（多个网站）存在，也就是同样一个 IP 地址下面会有多个服务器存在，由于它们对外的 IP 都是一样的，浏览器根据这个 IP 去请求服务器，服务器会无法识别该次请求访问具体哪个主机，最终得不到正确的响应，所以需要发送 Host 附加到 Header 到服务器。</p><blockquote><p>服务器地址一般的形式是：域名 + TCP 端口。</p></blockquote><h3>Content-Type/Content-Length</h3><p>描述 Body 的类型和长度。</p><ul><li>Content-Length：内容的长度（字节）</li></ul><p><strong>为什么会有 Content-Type 的存在？</strong></p><p>是因为请求报文中，可能会携带二进制非文本数据，二进制数据本身是不受限制的，它表示着各种各样的字节，那么如何表示内容字节结束？此时 Content-Type 的作用就是表示规定一个长度，长度范围内读取数据，长度过后的数据，直接扔弃。</p><ul><li>Content-Type：内容的类型</li></ul><p><strong>text/html</strong>: html 文本，用于浏览器页面响应。<strong>application/x-www-form-urlencoded</strong>: 普通表单，encode URL 格式，只作用于文本。</p><blockquote><p>表单，可以简单的理解为：一个要提交的表，是浏览器和服务器沟通的一个格式。通过表单，服务器会解析本次请求的 Body 内容，找对应参数。</p></blockquote><p><strong>multipart/form-data</strong>: 多部分形式，一般用于包含二进制内容的多项内容。后面会跟 <strong>boundary=----WebKitFormBoundaryxxxxxx</strong>，它的作用是用来分界 Body 和 Header 以及 Body 的各个属性。如修改人物信息的时候，通常会附带普通的「名字信息」和「头像图片」，那么请求格式如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /users HTTP/1.1</span><br><span class="line">Host: twitter.com</span><br><span class="line">Content-Type: multipart/form-data boundary=----WebKitFormBoundary247HFSSj7fgwj01</span><br><span class="line">Content-Length:2300</span><br><span class="line">------WebKitFormBoundary247HFSSj7fgwj01 // 分界 🏃</span><br><span class="line">Content-Disposition:form-data; name=&quot;user_name&quot;// user_name 属性</span><br><span class="line">valentizx</span><br><span class="line">------WebKitFormBoundary247HFSSj7fgwj01 // 分界 🏃</span><br><span class="line">Content-Dispostion: form-data; name=&quot;avatar&quot;;filename=&quot;valentizx.jpg&quot; // avatar 属性</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line">SFH72jfoa6GSKHGS....</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary247HFSSj7fgwj0-- // 分界 🕴🏻</span><br><span class="line"></span><br><span class="line">分界前面有 6 个 「-」，前两个「-」表示一个新的属性的开始，最后一个分界后面有两个「-」表示结束。</span><br></pre></td></tr></table></figure></p><p><strong>application/json</strong>: json 形式，多用于 Web Api 的响应或 PUT/POST 请求<strong>image/jpeg、application/zip ...</strong>: 但文件，用于 Web Api 响应或 POST/PUT 请求。</p><h4>Chunked Transfer Encoding 分块传输</h4><p>当一次请求的响应数据内容较大时，为不影响用户体验，服务器通常会返回一个 chunk 单位的数据给客户端，但是服务器不会告诉 Header 每一个 chunk 具体多长，也就是 Body 长度无法确定，此时 Content-Type 无法使用。于是，新的 Body 格式出现：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;length1&gt;</span><br><span class="line">&lt;data1&gt;</span><br><span class="line">&lt;length2&gt;</span><br><span class="line">&lt;data2&gt;</span><br><span class="line">0</span><br><span class="line"> // ⬅️此处有换行位⚠️</span><br></pre></td></tr></table></figure></p><p>明确每一小段（chunk）的长度放到 Header 中，先传输 data1，当 data2 准备就绪的时候传输 data2，<strong>直到传输 0 + 换行 表示内容结束。</strong></p><h3>Location</h3><p>重定向的目标 URL，一次请求返回 301 的时候，浏览器会进行重定向到 Location 字段后的地址再进行一次请求。</p><h3>User-Agent</h3><p>用户代理，就是指客户端（Client），网页会根据不同的设备进行适配，标识凭借就是 User-Agent。</p><h3>Range/Accept-Range</h3><p>指定 Body 的内容范围，当目标服务器支持分段取内容的时候，该字段发挥作用，其最主要的两个应用点就是：<strong>断点续传</strong>和<strong>分段下载</strong>。</p><h3>Cookie/Set-Cookie</h3><p>发送 Cookie，设置 Cookie</p><h3>Authorization</h3><p>授权信息</p><h3>部分其他 Header</h3><p><strong>Accept</strong>: 客户端能接受的数据类型。如 text/html<strong>Accept-Charset</strong>: 客户端度接受的字符集。如 utf-8<strong>Accept-Encoding</strong>: 客户端接受的压缩编码类型。如 gzip<strong>Content-Encoding</strong>: 压缩类型。如 gzip</p><h3>Cache</h3><h4>Cache 和 Buffer</h4><ul><li>Cache：缓存，表示一块内容可能多次使用，所以这部分内容<strong>暂时</strong>放在缓存区域中，当不用的时候会被回收掉，<strong>面向速度</strong>；</li><li>Buffer： 缓冲，工作过程中，上游生产快下游不能及时消费，或者下游暂时无消费，时间段过后会「猛」消费，则需要缓冲机制，提前生产一点存起来供下游使用，<strong>面向工作流</strong>；</li></ul><h4>Cache-Control</h4><p><strong>no-cache</strong>、<strong>no-store</strong>、<strong>max-age</strong>:</p><ul><li><strong>no-cache</strong>: 服务器告诉 Client 端，该内容可以缓存，但是再次请求的时候服务器需要知道缓存的内容是否失效；</li><li><strong>no-store</strong>: 不许缓存；</li><li><strong>max-age</strong>: 在失效日期内，Client 端随意访问；</li></ul><h4>Last-Modified</h4><p><strong>If-Modified-Since</strong>: 缓存界面最后的修改时间，请求过程中，服务器会对比缓存的最后修改时间和真实文件的最后修改时间，如果一致，说明文件没有改动过，返回 304，否则返回 200 和新的内容。</p><h4>Etag</h4><p><strong>If-None-Match</strong>: 相当于 Hash，或者说相当于一个指纹，Client 端也可凭借该字段与服务器「沟通」，对比这个标签，如果不是最新的，则请求最新的，返回 200 显示新内容，如果一致，则 返回 304。</p><h4>Cache-Control</h4><p><strong>private</strong> 和 <strong>public</strong>，一次请求的实际过程可能极其复杂，通过各个节点，各个网关，private 和 public 就是告诉路上经过的这些中间节点是否需要帮助缓存信息。</p><blockquote><p>⚠️ private 并不表示内容的私密性，私密性是通过加密机制来实现的，它表示「个性化定制信息」。</p></blockquote><h3>REST</h3><p>REST：对 HTTP 进行一种限制，属于一种<strong>架构风格。</strong></p><ul><li>Server-Client architecture</li><li>Statelessness</li><li>Cacheability</li><li>Layered system</li><li>Code on demand</li><li>Uniform interface<ul><li>Resource identification in requests</li><li>Resource manipulation through representations</li><li>Self-descriptive messages</li><li>Hypermedia as the engine of application state (HATEOAS)</li></ul></li></ul><h4>RESTful HTTP</h4><p>规范 HTTP 的使用方式，正确的使用 HTTP。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;HTTP 是什么？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Hyper Text Transfer Protocol&lt;/strong&gt; 超文本传输协议，是一种 Client 和 Server 之间请求和应答的标准，目的是更高效的进行网络传输。&lt;/p&gt;
&lt;h2&gt;HTTP 工作方式&lt;
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>macOS 系统 nginx + rtmp 流媒体传输实践</title>
    <link href="http://yoursite.com/2018/11/24/2018-11-24/"/>
    <id>http://yoursite.com/2018/11/24/2018-11-24/</id>
    <published>2018-11-24T05:18:11.000Z</published>
    <updated>2018-11-24T10:50:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>流媒体传输是“直播”中至关重要的环节，在网络传输媒体流的时候有着不同的<strong>流媒体传输协议</strong>。</p><p>做了一些小调查，在整个“直播”产品构建的过程中，应用最广的两个流媒体传输协议就是 <strong>RTMP</strong> 和 <strong>HLS</strong> 两个协议，其中 <strong>RTMP</strong> 在国内直播发展的长河中扮演着极其重要的角色，各个平台与 <strong>RTMP</strong> 的“结合”已变得很成熟。</p><h2>两种不同的流媒体传输协议</h2><h3>RTMP</h3><p>RTMP (Real Time Messaging Protocol) ：实时消息传输协议，属<strong>应用层协议</strong>，基于传输层 <strong>TCP 协议</strong>长链接来进行传输，有 N 多变种，最早由 Macromedia 公司开发，而后 Macromedia 被 Adobe 公司收购。</p><h4>RTMP 的主要特性</h4><ul><li>市场广阔，基本所有的编码器都支持 RTMP；</li><li>延迟低，RTMP 的实时性在 1～3 秒左右，即使经过 CDN (Content Delivery Network 内容分发网络)多层分发也能保证实时性在 3 秒左右，此特性已经完全满足现在的直播产业需求；</li><li>稳定性、可靠性高，基于 TCP 保证媒体流在传输的过程中不会丢失，但这也是缺点，在网络状态不好的时候，服务器会等待数据，这个过程会出现延迟，等包接受完整再将完整的包推给 Client 端；</li><li>HTML5 播放需要插件，并且跨平台较差</li></ul><h4>RTMP 原理</h4><p>RTMP 通过<strong>握手</strong>的方式建立 RTMP Connection，</p><p>若 Client 端要按序发送 C0、C1、C2，Server 端按序发送 S0、S1、S2，大致过程如下图：</p><p><img src="https://lh3.googleusercontent.com/-leVcMoCy_Ho/W_j6QUWNzsI/AAAAAAAAAcU/2YwbK5rIYw4Vr85ERW4PHliSXV_TwjtUgCHMYCw/I/15430436475817.png" alt=""></p><p>为保证数据的有效性，无论是 Client 端还是 Server 端都会等待一次 Chunk 接收完毕再进行下一次通信。</p><ul><li><strong>Chunk</strong> 是 RTMP 在进行数据流传输过程中的最小单位，每个 Chunk 由 Message 拆分，当然也可能每个独立的 Message 作为 Chunk 进行传输；</li><li><strong>Message</strong> 是满足 RTMP 并且经过「格式化」的数据，Message 有着自己的“数据结构”，标识每个 Message 的字段为 <strong>Message ID</strong>，该字段是拆分成 Chunk 和还原 Chunk 的凭借。</li></ul><h3>HLS</h3><p>HLS (HTTP Live Streaming)：是 Apple 公司基于 <strong>HTTP</strong> 实现的流媒体传输协议。</p><h4>HLS 的主要特性</h4><ul><li>对于 Apple 自家平台的硬件设备上最大化支持，不用自行开发特有播放器，在 Android 的设备上支持表现略差；</li><li>HLS 会将视频源分成索引文件和视频切片进行传输，所以可以实现<strong>平滑</strong>的切换码率，但这也是 HLS 一个致命的缺点，这种机制会导致 HLS 的实时性很差，延迟可达到数十秒；</li><li>基于 HTTP ，不存在防火墙和代理的问题，但需要和 Server 端不断进行连接通信；</li><li>HTML5 可以直接播放直播链接，不许任何独立的 Application支持。</li></ul><h4>HLS 主要原理</h4><p>HLS 传输内容包括：<strong>m3u8</strong> 索引文件以及 <strong>ts</strong> 视频切片。</p><p>无论是直播还是点播，HLS 协议都将视频源按策略分割成一个索引文件和若干 ts 视频切片，由索引文件管理视频切片，Server 则不断的将这些最视频切片推给 Client 端，所以对于直播而言，Client 会不断接受从 Server 端推过来的视频切片，以“点播”的方式达到直播的效果，但由于切片的过程会造成<strong>高延迟</strong>，所以在国内的直播产业中并不被看好，即使是将 ts 文件的切片设置最小，表现也仍旧不如 RTMP。</p><h3>RTMP Vs. HLS</h3><p>通过上面的介绍，对于<strong>视频采集 -&gt; 处理/编码 -&gt; 推流分发 -&gt; Client 端播放</strong>整个过程中 RTMP 和 HLS 的工作内容大致如下：</p><p><img src="https://lh3.googleusercontent.com/-5CPZkRTj12U/W_j5yubYj5I/AAAAAAAAAcM/EIp0Fvb_ByAE99WS3ut_pdxeVZrs7MamgCHMYCw/I/15430435174139.jpg" alt="RTMP"></p><p><img src="https://lh3.googleusercontent.com/-lnObWno95vE/W_jp_LdY8yI/AAAAAAAAAcA/1AaNtt-x-twOns5bWJMGhU9uE3NMIqh6QCHMYCw/I/15430394795180.png" alt="HLS"></p><p>与此同时，RTMP 既能<strong>推流</strong>也能<strong>拉流</strong>，而 HLS <strong>只能拉流</strong>。所以根据各自的特点，RTMP 更适用于实时性、互动性较高的直播，HLS 更适合 HTTP 点播。</p><h2>本地流媒体传输实践</h2><h3>准备</h3><p>a. 安装 <code>HomeBrew</code>，终端键入：</p><p><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p><blockquote><p>升级 <code>Homebrew</code>：<code>brew update</code></p></blockquote><p>b. 推流搭建本地服务器需 <strong>nginx</strong>，终端键入：<code>brew tap denji/nginx</code></p><blockquote><p>使用 <code>brew tap homebrew/nginx</code> 会报 <strong>Error: homebrew/nginx was deprecated. This tap is now empty as all its formulae were migrated.</strong></p></blockquote><p>c. 安装 <strong>rtmp</strong> 模块，终端键入：</p><p><code>brew install nginx-full --with-rtmp-module</code></p><p>d. 此时，<strong>nginx</strong> 和 <strong>rtmp</strong> 模块都已安装完成，终端键入：<code>nginx</code> (权限问题键入 <code>sudo nginx</code>)，启动 nginx 服务，浏览器键入 <code>http://localhost:8080</code> 出现 <strong>Welcome to nginx!</strong> 欢迎语表示安装成功。</p><blockquote><p>重启 nginx 服务命令：<code>nginx -s reload</code>停止 nginx 服务命令：<code>nginx -s stop</code>有序退出 nginx 服务命令：<code>nginx -s quit</code></p></blockquote><p>e. 配置 <strong>nginx.conf</strong> (HLS + RTMP)</p><blockquote><p>nginx.conf 路径为：<strong>/usr/local/etc/nginx/nginx.conf</strong></p></blockquote><p>文本打开该文件在 <strong>http</strong> 作用域内键入：</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /hls &#123;</span><br><span class="line">        #Serve HLS config</span><br><span class="line">        types &#123;</span><br><span class="line">            application/vnd.apple.mpegurl    m3u8;</span><br><span class="line">            video/mp2t ts;</span><br><span class="line">        &#125;</span><br><span class="line">        root /usr/local/var/www;</span><br><span class="line">        add_header Cache-Control    no-cache;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在最后键入：</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        application rtmplive &#123;</span><br><span class="line">            live on;</span><br><span class="line">            max_connections 1024;</span><br><span class="line">        &#125;</span><br><span class="line">        application hls&#123;</span><br><span class="line">            live on;</span><br><span class="line">            hls on;</span><br><span class="line">            hls_path /usr/local/var/www/hls;</span><br><span class="line">            hls_fragment 1s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>RTMP <strong>默认端口 1935</strong>，<strong>rtmp 配置信息不属于任何作用域</strong>，写在任何作用域里都会报错 <strong>nginx: [emerg] &quot;rtmp&quot; directive is not allowed here in /etc/nginx/nginx.conf:起始行数</strong></p></blockquote><p>配置完毕重启 nginx 服务。</p><p>f. 安装 <strong>ffmepg</strong> 工具，终端键入：</p><p><code>brew install ffmpeg</code></p><p>g. 安装支持 HLS 和 RTMP 的播放器，<a href="https://www.videolan.org/vlc/index.html" target="_blank" rel="noopener">VLC</a> 和 <a href="https://mpv.io/" target="_blank" rel="noopener">mpv</a> 都可，在此用的是 mpv。</p><h3>实践本地推流至 nginx</h3><p>一切都准备就绪后，即可实践推流服务，终端键入：</p><p><code>ffmpeg -re -i 目标视频.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp://localhost:1935/xx/xx</code></p><p><strong>推流命令具体参数：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-vcodec libx264</td><td>视频的编码器为 H.264</td></tr><tr><td>vprofile baseline</td><td>设置音视频编码器的类</td></tr><tr><td>-acodec aac</td><td>指定声音的编码器为AAC</td></tr><tr><td>-ar 44100</td><td>音频编解码器的采样率，单位为赫兹</td></tr><tr><td>-ac 1</td><td>设置音频编解码器的声道数目</td></tr><tr><td>-f flv</td><td>强制设定输入和输出文件格式为 flv 格式</td></tr><tr><td>-s 1280x720</td><td>分辨率</td></tr></tbody></table><p>推送过程会在终端显示如下：</p><p><img src="https://lh3.googleusercontent.com/-HKeUcGhPnNs/W_kW8_gvwVI/AAAAAAAAAcg/eFET15J0vAEP2dkpmjf1qRdjXIXutejGACHMYCw/I/Jietu20181124-171400%25402x.jpg" alt=""></p><p>推送完毕如下：<img src="https://lh3.googleusercontent.com/-D_bXkjNRNiU/W_kY6_wOgUI/AAAAAAAAAc0/_EQY1y-aObsRDWFMKSgtGSXxsX9-UMKDgCHMYCw/I/15430514948876.jpg" alt=""></p><h4>RTMP 拉流</h4><p>推流至 RTMP 服务器生成地址： <strong>rtmp://localhost:1935/xx/xx</strong></p><p>此时在 mpv 工具栏 <strong>File - Open URL - 键入 rtmp://localhost:1935/rtmplive/xx</strong></p><p>播放即可播放：</p><p><img src="https://lh3.googleusercontent.com/-TIlna7CEZ3A/W_kXeDvoNyI/AAAAAAAAAco/EiYxJONT10Y3YX5x6FoEhG3ULbJ9-8DHwCHMYCw/I/Jietu20181124-171439%25402x.jpg" alt="Jietu20181124-171439@2x"></p><h4>HLS 拉流</h4><p>推流至 HLS 服务器生成地址：<strong>http://localhost:8080/hls/xx.m3u8</strong></p><p>在浏览器或者 mpv 中播放表现如下：</p><p><img src="https://lh3.googleusercontent.com/-Ukd-6VJKbhY/W_kbakzT1JI/AAAAAAAAAdA/oMsdcComgYkNhJWp0Ws1BOE2y3232bWYACHMYCw/I/Jietu20181124-173220%25402x.jpg" alt="Safari 播放"></p><p><img src="https://lh3.googleusercontent.com/-ZdhM-lWEE7E/W_kbfIy0ztI/AAAAAAAAAdE/SHPCm-EqqHQJqOZGT0gJVg_AKDTjXMslQCHMYCw/I/Jietu20181124-173249%25402x.jpg" alt="mpv 播放器播放"></p><h2>实践远程推流</h2><p>手头刚好有个科学上网买的 VPS 正好可以当作远程服务器使用，新加坡节点，但应该也是绕到美国的线路，所以可想而知，播放过程异常的艰辛，十几秒播放一帧已经算是给面子了，但好在已经有成果。</p><p>我的服务器是 CentOS 系统，可能安装模块的命令和 Ubuntu 系统有细小的差别。</p><p>在此连接 VPS 的工具选择的是 <strong>ShellCraft</strong>，macOS 自带的终端工具也可以连接，可视化 CentOS 服务器的客户端为 <a href="https://filezilla-project.org/" target="_blank" rel="noopener">FileZilla</a>，添加 VPS 站点步骤在本文最后。</p><h3>准备</h3><p>a. 安装 git，CentOS 系统下安装 Git 的命令为：</p><p><code>yum install git</code></p><p>b. clone <strong>srs</strong>，键入：<code>git clone srs</code></p><blockquote><p>srs 的作者将它定义为直播服务器集群，更多的信息，请点 <a href="https://github.com/ossrs/srs" target="_blank" rel="noopener">srs Github 主页</a>。</p></blockquote><p>若 clone 过程中出现 <strong>Please make sure you have the correct access rights and the repository exists.</strong> 说明，SSH Key 出现了问题导致无法正常 git 操作，解决如下依次键入：</p><ul><li><code>git config --global user.name &quot;yourname&quot;</code></li><li><code>git config --global user.email &quot;your@email.com&quot;</code></li><li><code>ssh-keygen -t rsa -C &quot;your@email.com&quot;</code></li><li><code>vi /root/.ssh/id_rsa.pub</code></li><li>将该文件的一大串信息复制并添加到 Github 个人设置里新建的 SSH Key 中。</li></ul><p>c. cd 到 srs 目录，依次键入：</p><p><code>git checkout 2.0release</code><code>git pull</code><code>cd trunk</code></p><p>d. 配置远程服务器，该过程极其漫长，键入：<code>./configure --disable-all --with-ssl --with-nginx --with-hls --with-http-callback --with-http-server --with-http-api --with-ffmpeg --with-transcode --with-librtmp --with-dvr &amp;&amp; make</code></p><p>出现下图所示表示配置环境完成：<img src="https://lh3.googleusercontent.com/-m1LDECnVXs4/W_kiMVpYXTI/AAAAAAAAAdQ/idOv_6owTtMJCLNWDD0DCpIOMzGi-i7CgCHMYCw/I/15430538665743.jpg" alt=""></p><p>e. 执行配置，键入<code>./objs/srs -c conf/srs.conf</code></p><p><img src="https://lh3.googleusercontent.com/-GOodNe5Tl_A/W_ks6meGDpI/AAAAAAAAAeU/vzscHp8O4qMRRyWY9TKKfGxZriU3T64LQCHMYCw/I/15430566121492.jpg" alt=""></p><h3>实践远程推流与拉流</h3><p>推流拉流过程和本地推流命令一样，只不过服务器地址的 <strong>localhost:接口</strong> 要换成<strong>服务器地址</strong>，倘若出现如下错误信息则说明需要关闭 CentOS 的防火墙：</p><p><img src="https://lh3.googleusercontent.com/-K7Ti2qPpqY0/W_kkSGtvRCI/AAAAAAAAAdk/5VT_n3m1Jho-ENKPWdO4PGZeTNXZ7KDXQCHMYCw/I/Jietu20181124-181217%25402x.jpg" alt=""></p><blockquote><p>错误信息：[tcp @ 0x7fd255c02b80] Connection to tcp://207.148.66.232:1935 failed: Connection refused[rtmp @ 0x7fd255d0b100] Cannot open connection tcp://207.148.66.232:1935rtmp://207.148.66.232/live/demo: Connection refused</p></blockquote><p><strong>关闭防火墙的命令为：<code>systemctl stop firewalld.service</code></strong>。</p><h2>FileZilla 添加站点</h2><p>File -&gt; Site Manager 弹出如下界面：</p><p><img src="https://lh3.googleusercontent.com/-lQGsi8EPCEQ/W_kl5cSJDKI/AAAAAAAAAd8/1MU3SqJulLcDWLH8QDKkEUbJRE3Sk_jjwCHMYCw/I/15430548184358.jpg" alt=""></p><p>New Site -&gt; General -&gt; Protocol 选择如图所示的 <strong>SFTP</strong>，Logon Type 为 <strong>Normal</strong>，Host、User 以及 Password 自行填写，Connect。</p><p>界面如下：<img src="https://lh3.googleusercontent.com/-a346KYF4T-Q/W_kmflf2FRI/AAAAAAAAAeI/aCD8fe4AoqQGrv9V2o8XBjB0PYN-b12oQCHMYCw/I/15430549672565.jpg" alt=""></p><p>👏done!🎉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;流媒体传输是“直播”中至关重要的环节，在网络传输媒体流的时候有着不同的&lt;strong&gt;流媒体传输协议&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;做了一些小调查，在整个“直播”产品构建的过程中，应用最广的两个流媒体传输协议就是 &lt;strong&gt;RTMP&lt;/strong&gt; 和 &lt;str
      
    
    </summary>
    
    
      <category term="rtmp" scheme="http://yoursite.com/tags/rtmp/"/>
    
      <category term="hls" scheme="http://yoursite.com/tags/hls/"/>
    
      <category term="推流" scheme="http://yoursite.com/tags/%E6%8E%A8%E6%B5%81/"/>
    
      <category term="拉流" scheme="http://yoursite.com/tags/%E6%8B%89%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>「RSHARE」 一键分享 Android 版</title>
    <link href="http://yoursite.com/2018/08/29/2018-08-29/"/>
    <id>http://yoursite.com/2018/08/29/2018-08-29/</id>
    <published>2018-08-29T09:03:59.000Z</published>
    <updated>2018-09-12T01:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为公司的项目里集成了一键分享的这个模块, 而在我设计的时候发现国内的官方文档和提供的 Sample 有混乱和容易混淆的地方, 而且除了普通的网页、图片、文字分享到各大 Social 平台以外, 对于视频、文件和其他内容的分享 Demo 在百度或者 Google 几乎搜不到. 自己也是踩了很多坑才把很多问题解决.</p><h2>测试设备</h2><p>Samsung S9 Plus, Android 8.0.0.</p><h2>支持平台</h2><p><strong>RSHARE</strong> 这个 Demo 中支持: 微信、QQ、新浪微博、Facebook、GooglePlus(Google +)、Twitter、WhatsApp、Line、Tumblr、Instagram、Pinterest 11 个 Social 平台.</p><h3>平台差异</h3><p>主要罗列了常用的 5 个分享内容的对比菜单(网页、文字、图片、本地视频、文件).<strong>注意菜单内字母以及菜单后面对应字母的注释⚠️</strong></p><table><thead><tr><th>❤️</th><th>QQ</th><th>微信</th><th>微博</th><th>Facebook</th><th>Twitter</th><th>Instagram</th><th>WhatsApp</th><th>Line</th><th>Tumblr</th><th>Pinterest</th><th>Google+</th></tr></thead><tbody><tr><td>网页</td><td>✓a</td><td>✓</td><td>✓</td><td>✓b</td><td>✓</td><td>✗</td><td>✓</td><td>✓</td><td>✓</td><td>✗</td><td>✓</td></tr><tr><td>文字</td><td>✗c</td><td>✓</td><td>✓</td><td>✗</td><td>✓</td><td>✗</td><td>✓</td><td>✓</td><td>✓</td><td>✗</td><td>✗</td></tr><tr><td>图片</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓d</td><td>✓d</td><td>✗</td></tr><tr><td>视频</td><td>?e</td><td>✗</td><td>✓</td><td>✓</td><td>✗</td><td>✓</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td></tr><tr><td>文件</td><td>✗</td><td>✓</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td></tr></tbody></table><p>a. QQ 虽支持网页分享, 但是不允许带着网页的 <code>description</code> 字段, 这和 iOS 表现不同;b. Facebook 的网页分享支持 <strong>hashtag</strong>;c. iOS 端分享文字到 QQ 客户端是可行的, 但是 Android 端不允许, 其实 QQ 的分享目地就是<strong>让用户自行输入有价值、有意义的文字信息</strong>;d. Pinterest 和 Tumblr 虽支持图片分享, 但仅仅支持分享图片的 URL, 它会自行解析并显示;e. 只支持分享到 QQ 空间.</p><p>⚠️ 1. 对于 <strong>QQ 分享 Android 端</strong>, <strong>不支持通过 SDK 直接分享到数据线(我的电脑)和我的收藏.</strong>⚠️ 2. 对于 <strong>WhatsApp 分享 Android 端</strong>, <strong>支持图文并存.</strong></p><blockquote><ol><li>对比列表得知, 国内的平台分享内容是最丰富的, 但是存在一个主要的问题(主要是 QQ), iOS 和 Android 双端的接口以及实现的功能也并不统一(后面的部分会具体说); 微信双端当分享的图片过大的时候的表现也有不统一的时候, 其余都很完善; 新浪的表现是最统一的, 且没有过多限制; 国内的平台分享最让人头疼的就是官方的 Sample 很混乱, 但是在实践代码的时候还是要以官方为主.</li><li>国外的文档和 Sample 很明了且注释详细, 但也存在双端不统一的情况, Twitter 的双端表现就不一样(后面细说), 但是国外的平台分享几乎没有回调, Facebook 的回调只有 Feed 形式的分享才有效, Instagram、Line、Google+这些是没有 SDK 的, 仅仅是通过打开 Application URL scheme 来分享.</li></ol></blockquote><h2>分享总体设计</h2><p>大概的分享逻辑如下:</p><p><img src="https://lh3.googleusercontent.com/-9k6SFlwycnU/W4dQ67__G3I/AAAAAAAAAUg/Qd5u_D4WwjodH_gUDzD5N1T7KR_fWP7qwCHMYCw/I/Android%2B" alt="Android 分享逻辑"></p><p>Android 的分享是参照各大平台的分享逻辑得到比较统一思路, 即: 先判断是否安装对应应用, 然后初始化 SDK 与官方平台连接, 然后包装分享参数进行分享, 最后处理分享回调, 只不过与 iOS 端不同的是, 初始化 SDK 的工作是在分享逻辑内完成的, 并不对外开放(灵感来自 ShareSDK 的 Android 版), <strong><code>AppID</code>、<code>Key</code> 以及 <code>Secret</code> 信息在 <code>RShare.xml</code> 文件中配置.</strong></p><blockquote><ol><li>有些平台不存在 SDK, 所以直接判断是否平台安装然后包装分享参数进行分享;</li><li>Tumblr 比较特殊, 有 SDK 但是不需要判断应用是否安装就可以分享, Twitter 也如此, 具体情况在 Twitter 的部分说明;</li><li>SDK 的初始化, 统一函数名字为 <code>sdkInitialize</code>(<strong>但并未对外开放</strong>), <code>Key</code>、<code>Secret</code> 以及 <code>AppID</code> 等信息在注释中有标明.</li></ol></blockquote><h2>详细逻辑</h2><p><strong>关于各个平台的开发者主页和文档信息以这里为主, 代码注释的可能不准确.</strong></p><p>平台分享都是通过<strong>单例模式</strong>实现.</p><h3>基类</h3><p>子平台 Manager 都是继承自 <strong>RShare</strong>, 这个类中定义了分享 <strong>Mode (代码注释中有标明)</strong>、分享内容类型枚举(内部使用) <strong>ShareContentType</strong> 以及<strong>分享回调</strong>.Java 中创建监听器来监听分享结果:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RShareListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(RSharePlatform.Platform platform)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(RSharePlatform.Platform platform, String errorInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">(RSharePlatform.Platform platform)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Kotlin 中通过 callback 来监听分享结果:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typealias RShareCallback = ((platform : RSharePlatform, state : ShareState, errorInfo : String?) -&gt;</span><br><span class="line"><span class="built_in">Unit</span>)</span><br></pre></td></tr></table></figure></p><p><strong>Mode(仅对 Facebook、Twitter、Instagram 有效, iOS 亦然):</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Mode &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的分享方式</span></span><br><span class="line"><span class="comment">     * Facebook: 优先客户端分享, 客户端无法分享会转由网页形式分享.</span></span><br><span class="line"><span class="comment">     * Twitter: 优先应用内分享.</span></span><br><span class="line"><span class="comment">     * Instagram: 默认客户端分享.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    Automatic,</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 原生应用分享.</span></span><br><span class="line"><span class="comment">      * Facebook、Twitter: 无回调.</span></span><br><span class="line"><span class="comment">      ** */</span></span><br><span class="line">    Native,</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 网页分享, 有回调, 仅对Facebook生效.</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line">    Web,</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 反馈网页形式分享, 有回调, 仅对Facebook生效.</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">    Feed,</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 调用 Android 系统分享.</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">    System,</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ShareContentType:</p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ShareContentType &#123;</span><br><span class="line">    Webpage,</span><br><span class="line">    Photo,</span><br><span class="line">    Video,</span><br><span class="line">    Text,</span><br><span class="line">    Media,</span><br><span class="line">    File,</span><br><span class="line">    Music,</span><br><span class="line">    App</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>配置文件</h3><p>在 <code>src/main</code> 目录下新建资源文件夹 <code>assets</code>, 并创建 <strong>RShare.xml</strong> 配置文件, 文件内容如下:</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Platform</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Twitter</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ConsumerKey</span>= <span class="string">yourKey</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ConsumerSecret</span>= <span class="string">yourAppSecret</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Facebook</span></span></span><br><span class="line"><span class="tag">        <span class="attr">AppID</span>= <span class="string">yourAppID</span></span></span><br><span class="line"><span class="tag">        <span class="attr">AppSecret</span>= <span class="string">yourAppSecret</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">WeChat</span></span></span><br><span class="line"><span class="tag">        <span class="attr">AppId</span>= <span class="string">yourAppID</span></span></span><br><span class="line"><span class="tag">        <span class="attr">AppSecret</span>= <span class="string">yourAppSecret</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Sina</span></span></span><br><span class="line"><span class="tag">        <span class="attr">AppKey</span>= <span class="string">yourAppKey</span></span></span><br><span class="line"><span class="tag">        <span class="attr">AppSecret</span>= <span class="string">yourAppSecret</span></span></span><br><span class="line"><span class="tag">        <span class="attr">RedirectUrl</span>= <span class="string">yourRedirectUrl</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Scope</span>=<span class="string">"all"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">QQ</span></span></span><br><span class="line"><span class="tag">        <span class="attr">AppID</span>= <span class="string">yourAppID</span></span></span><br><span class="line"><span class="tag">        <span class="attr">AppSecret</span>= <span class="string">yourAppSecret</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Tumblr</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ConsumerKey</span>= <span class="string">yourKey</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ConsumerSecret</span>= <span class="string">yourAppSecret</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">FlurryKey</span>= <span class="string">yourFlurryKey</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Pinterest</span></span></span><br><span class="line"><span class="tag">        <span class="attr">AppId</span>= <span class="string">yourAppID</span></span></span><br><span class="line"><span class="tag">        <span class="attr">AppSecret</span>= <span class="string">yourAppSecret</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Platform</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>关于哪些字段不需要, 在后面会讲明.</strong></p><p>工具类 <code>RPlatformHelper</code> 中封装了解析 <strong>RShare.xml</strong> 并获取各个平台 <code>Id</code>、<code>key</code> 以及 <code>secret</code> 信息的方法.</p><h3>图片的处理</h3><p>与 iOS 不同的是, Android 端平台分享图片的通过<strong>图片的 Url</strong> 来进行参数的包装到分享. 在此, 我封装的接口传图片参数是以 Bitmap 形式传值的, 然后保存图片数据到一个文件夹, 获取数据的 Url 包装到平台 SDK 或者包装到 Intent 中分享.</p><p><strong>⚠️ 假如这个图片是网络请求下来的, 那么完整的分享步骤就是:</strong><img src="https://lh3.googleusercontent.com/-MXlzlURYzn4/W4yX50h8eXI/AAAAAAAAAU4/6NxMqPrEnvsSscJwcEPxPN4sjYB2Z8XDgCHMYCw/I/15359405805597.jpg" alt=""></p><p><strong>多出一步再保存, 造成不必要的开销.</strong></p><p>Java 版本中, 保存图片的接口封装到工具类 <code>RFileHelper</code> 中; Kotlin 版本中, 用<strong>顶层函数</strong>替代了工具类, 整合到了 <code>RFileHelper.kt</code> 文件中:</p><p>保存图片:</p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RFileHelper.saveBitmapToExternalSharePath(context, targetImage);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saveBitmapToExternalSharePath(context, targetImage)</span><br></pre></td></tr></table></figure></p><p>删除图片:</p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RFileHelper.deleteExternalShareDirectory(context);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteExternalShareDir(context)</span><br></pre></td></tr></table></figure></p><h4>文件共享</h4><p>从 Android 7.0 开始, 其他应用使用本应用的某文件 <code>file://</code> 格式的 <strong>URI</strong> 会抛 <strong>FileUriExposedException</strong> 的异常(新浪 SDK 就存在这个问题), 所以在 <code>RFileHelper</code> 中封装好了对应方法:</p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RFileHelper.detectFileUriExposure();</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">Kotlin:</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line">detectFileUriExposure()</span><br></pre></td></tr></table></figure></p><h3>QQ</h3><h4>准备</h4><p>分享需要注册平台, <a href="http://open.qq.com/" target="_blank" rel="noopener">腾讯开发者主页</a>, <a href="http://wiki.open.qq.com/wiki/mobile/SDK%E4%B8%8B%E8%BD%BD" target="_blank" rel="noopener">SDK 下载</a>, QQ SDK 目前<strong>不支持 compile 集成</strong>, Android API 调用说明<a href="http://wiki.open.qq.com/wiki/mobile/API%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">文档</a>.</p><h4>集成</h4><p>a. 手动添加 SDK 到 <code>libs</code> 文件夹, 并:</p><p><img src="https://lh3.googleusercontent.com/-7DCJppBupJA/W4eaDI_LncI/AAAAAAAAAUs/hpVlStBvt_celCw2za386XN9rVRPD932ACHMYCw/I/Snip20180830_7.png" alt="Snip20180830_7"></p><p>b. 在 <strong>AndroidManifest.xml</strong> 的 <code>&lt;application&gt;</code> 节点下增加:</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:name</span>=<span class="string">"com.tencent.tauth.AuthActivity"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:noHistory</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"tencentYOURAPPID"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>c. 添加以下权限:</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_PHONE_STATE"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h4>接口及内部实现</h4><p><strong>a. 内部初始化 SDK</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Tencent mTencent;</span><br><span class="line">mTencent = Tencent.createInstance(appId, context);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mTencent : Tencent</span><br><span class="line">mTencent = Tencent.createInstance(appId, context)</span><br></pre></td></tr></table></figure></p><blockquote><p>仅做<em>分享</em>功能的话, <code>secret</code> 字段无用.</p></blockquote><p><strong>b. 分享</strong></p><p>QQ Android SDK 分享是通过 <strong>Bundle</strong> 进行数据包装传输, 在这里分享音乐、网页、应用等等的键值对都封装在 <code>QQShare.class</code> 中, 很容易混淆和误会, 完善内容分享的时候<strong>一定要参照官方的示例程序!</strong></p><p>QQ 客户端和 QQ 空间的分享模型都封装在 <code>RQqHelper</code> 中, 但是分享启动的 Activity 将 QQ 客户端和 QQ 空间的分开, 分别是 <code>RQqActivity</code> 和 <code>RQZoneActivity</code> 在分享 Activity 中实现接口 <code>IUiListener</code> 用来监听分享结果.</p><p>另, Android 端<strong>不支持直接打开‘我的收藏’和‘数据线(我的电脑)’分享</strong>, 需自行选择, 并且<strong>不支持纯文字分享</strong>.</p><p>⚠️最后, <strong>QQ 分享一定要在主线程里完成!!!</strong> 获取 <code>mainHandler</code> 已封装到了 <code>RThreadManager</code> 中(写法有误或者写法有不足请严厉指出):</p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">内部:</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object mMainHandlerLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handler <span class="title">getMainHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mManinHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mMainHandlerLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mManinHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mManinHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> mManinHandler;</span><br><span class="line">&#125;</span><br><span class="line">调用:</span><br><span class="line">RThreadManager.getMainHandler().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">内部:</span><br><span class="line">private var mMainHandlerLock = Any()</span><br><span class="line">internal val mainHandler : Handler = Handler()</span><br><span class="line">    get() &#123;</span><br><span class="line">        if (field == null) &#123;</span><br><span class="line">            synchronized(mMainHandlerLock) &#123;</span><br><span class="line">                if (field == null) &#123;</span><br><span class="line">                    field = Handler(Looper.getMainLooper())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return field</span><br><span class="line">    &#125;</span><br><span class="line">调用:</span><br><span class="line">mainHandler.post(</span><br><span class="line">    Runnable &#123;</span><br><span class="line">        kotlin.run &#123;</span><br><span class="line">            /// ...</span><br><span class="line">       &#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure></p><p><strong>网页分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.getInstance().shareWebpage(context, webapgeUrl, title, description, thumbImage, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.instance.shareWebpage(context, webpageUrl, title, description, thumbImageUrl, callback)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-lQNWh_xUCIM/W43gU-RtgNI/AAAAAAAAAVE/avOZBakVVpgtmw8RW4qf2ZDzmtpkC21PwCHMYCw/I/15360246543930.jpg" alt=""></p><p><strong>图片分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.getInstance().shareImage( context, targetImage, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.instance.shareImage(context, targetImage, callback)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-aherZ9UNyxE/W43jH4GEkBI/AAAAAAAAAVQ/QaPWBeRGtHEW6C-IZ7KbubjKqqRSm3UCgCHMYCw/I/15360253735120.jpg" alt=""></p><p><strong>音频链分享:</strong></p><p>大致和网页的分享相同, 但是多了一个 <code>audioStreamUrl</code> 的字段.</p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.getInstance().shareMusic(context, audioStreamUrl, musicWebapgeUrl, title, description, thumbImage, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.instance.shareMusic(context, audioStreamUrl, musicWebpageUrl, title, description, thumbImageUrl, callback)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 1. 在自定义 Bundle 包装分享音频参数的时候, <code>QQShare.SHARE_TO_QQ_TARGET_URL</code> 设置音频网页链接, <code>QQShare.SHARE_TO_QQ_AUDIO_URL</code> 设置音频流链.⚠️ 2. <code>audioStreamUrl</code> 请设置音频的音频流链接, 不要把音乐平台分享的音乐网链直接赋值在该字段上, 否则点击播放按钮是无法播放的, 音乐网链是放在 <code>webpageUrl</code> 字段上的.</p></blockquote><p>表现:<img src="https://lh3.googleusercontent.com/-D-jkZ9akfE8/W43mzu-YkvI/AAAAAAAAAVc/9qmI6Sc2HK8Uc2TaIZAvPdyLtF2z-jMuwCHMYCw/I/15360263169688.jpg" alt=""></p><p><strong>应用分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.getInstance().shareApp(context, appUrl, title, description, thumbImage, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.instance.shareApp(context, appUrl, title, description, thumbImageUrl, callback)</span><br></pre></td></tr></table></figure></p><p>点击消息对话框会自动跳转到「应用宝」对应 App 主页.</p><p><strong>分享网页到空间:</strong></p><p>Java:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.getInstance().shareWebpageToZone(context, webapgeUrl, title, description, imageUrlList, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.instance.shareWebpageToZone(context, webpageUrl, title, description, imageUrlList, callback)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 1. 这里的缩略图数组里面是<strong>图片的网络链接</strong>.⚠️ 2. 缩略图图片是以数组包装的, 但是仅仅会显示第一张, 也就是说目前的 SDK (3.3.3 版本) 是不具备网络多图分享的, 但腾讯已说明多网络图后面会完善和补全.</p></blockquote><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-vOtMU3GUtQs/W43poY1ypPI/AAAAAAAAAVo/HN7T-g7TL8IoRid3cHW9JC-XnmOX3oR6ACHMYCw/I/15360270395528.jpg" alt=""></p><p><strong>分享图片到空间:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.getInstance().publishImagesToZone(context, targetImages, description, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.instance.publishImagesToZone(context, targetImages, description, callback)</span><br></pre></td></tr></table></figure></p><p><code>description</code> 字段实际是失效的.</p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-jewSxMbq3kA/W43ra0e7vTI/AAAAAAAAAV0/WZshp4eAaM4RYNSJz1FtGBsbH-TjYNSmQCHMYCw/I/15360274983078.jpg" alt=""></p><p><strong>分享本地视频到空间:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.getInstance().publishVideoToZone(context, localVideoUrl, description, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RQqManager.instance.publishVideoToZone(context, localVideoUrl, description, callback)</span><br></pre></td></tr></table></figure></p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-6j1kjXWbnKo/W43ss4tVYpI/AAAAAAAAAWA/OTdMUq3hRZAK2kBIOT9WdMltMKQ_d_ySwCHMYCw/I/15360278242935.jpg" alt=""></p><h3>微信</h3><h4>准备</h4><p>分享需要注册平台, <a href="https://open.weixin.qq.com/" target="_blank" rel="noopener">微信开放平台</a>, <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319167&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">SDK 下载</a>, 微信 SDK <strong>支持 compile 集成</strong>, <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317340&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">分享 &amp; 收藏 API 调用说明</a>.</p><h4>集成</h4><p>a.在 <strong>Application 级 <code>build.gradle</code> 中配置:</strong></p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile 'com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile 'com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前者包括统计功能.</p><p>b. 添加以下权限:</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_PHONE_STATE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>c. 当需要在分享完毕后接受微信的传值需要<strong>在你的包名相应目录下新建一个 wxapi 目录，并在该 wxapi 目录下新增一个 <code>WXEntryActivity</code> 类，该类继承自 <code>Activity</code></strong>, 在 <strong>AndroidManifest.xml</strong> 的 <code>&lt;application&gt;</code> 节点下增加:</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".wxapi.WXEntryActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></p><h4>接口及内部实现</h4><p><strong>a. 内部初始化 SDK</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IWXAPI mIwxapi = WXAPIFactory.createWXAPI(context, appId);</span><br><span class="line">mIwxapi.registerApp(appId);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mIWXApi = WXAPIFactory.createWXAPI(context, appId)</span><br><span class="line">mIWXApi.registerApp(appId)</span><br></pre></td></tr></table></figure></p><blockquote><p>仅做<em>分享</em>功能的话, <code>secret</code> 字段无用.</p></blockquote><p><strong>b. 分享</strong></p><p>微信分享的内容包装同样通过一个 <code>RWechatHelper</code> 进行单独处理, 对于文字、网页、图片、视频网链、小程序、文件的分享内容处理都很简单, 特别注意的就是对于音乐链的分享, 同 QQ 一样, 需要区别两个参数, 一个是<strong>音频流</strong>链, 一个是<strong>音频网页</strong>, 播放的是音频流, 点击背景进入的是音频网页:</p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WXMusicObject obj = <span class="keyword">new</span> WXMusicObject();</span><br><span class="line">obj.musicUrl = webpageUrl;</span><br><span class="line">obj.musicDataUrl = streamUrl;</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> obj : WXMusicObject = WXMusicObject()</span><br><span class="line">obj.musicUrl = webpageUrl</span><br><span class="line">obj.musicDataUrl = streamUrl</span><br></pre></td></tr></table></figure></p><p>在程序需要接受微信发送的请求的时候, 需要在 <code>WXEntryActivity</code> 中实现 <code>IWXAPIEventHandler</code> 接口，微信发送的请求将回调到 <code>onReq</code> 方法，发送到微信请求的响应结果将回调到 <code>onResp</code> 方法, 在 <code>WXEntryActivity</code> 中将接收到的 <code>intent</code> 及实现了 <code>IWXAPIEventHandler</code> 接口的对象传递给 <code>IWXAPI</code> 接口的 <code>handleIntent</code> 方法. 为了让 <code>RWechatManager</code> 处理结果, 在 <code>RWechatManager</code> 中封装了 <code>onResp</code> 方法.</p><p><strong>文字分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.getInstance().shareText(context, description, scene, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.instance.shareText(context, description, scene, callback)</span><br></pre></td></tr></table></figure></p><p>表现(分享到好友):</p><p><img src="https://lh3.googleusercontent.com/-zlfWRC10SJI/W44xTp6FUUI/AAAAAAAAAWM/j3UlQcde5LgRDxALeJUlOJqdBj2wVVyLwCHMYCw/I/15360453876894.jpg" alt=""></p><p><strong>图片分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.getInstance().shareImage(context, targetImage, scene, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.instance.shareImage(context, targetImage, scene, callback)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 图片过大无法调起微信客户端分享.</p></blockquote><p>表现(分享到好友):</p><p><img src="https://lh3.googleusercontent.com/-BFFGh29k4RY/W44y4BgsUMI/AAAAAAAAAWY/7lFoyibp1WUW-np_HEDCKo_GbH1p6SGjwCHMYCw/I/15360457905870.jpg" alt=""></p><p><strong>网页分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.getInstance().shareWebpage(context, webapgeUrl, title, description, thumbImage, scene, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.instance.shareWebpage(context, webpageUrl, title, description, thumbImage, scene, callback)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 1. <code>thumbImage</code> 字段的缩略图大小不能超过 32 Kb, 但实际测试 100 Kb 左右也是完全可行的, 但一定不能过大.⚠️ 2. Android  对于缩略图的处理相对友好很多, 对于 iOS 无法分享的过大的缩略图数据一般情况下 Android 都能成功启动微信客户端并且成功分享(亲测).⚠️ 3. 在缩略图没有符合规范的时候, 即使成功分享在 iOS 端也会出现<strong>缩略图不显示</strong>的情况, Android 几乎都会显示.</p></blockquote><p>表现(分享到好友):<img src="https://lh3.googleusercontent.com/-7oN-sXKGMQ8/W440TO936mI/AAAAAAAAAWk/6vI9YPJVUWMcl9DpFXEW1PjP9VElZIvJgCHMYCw/I/15360461549519.jpg" alt=""></p><p><strong>视频链分享:</strong>实质就是网页的分享, 在此不作代码示例.</p><p><strong>音频链分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.getInstance().shareMusic(context, audioStreamUrl, title, description, thumbImage, musicWebapgeUrl, scene, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.instance.shareMusic(context, audioStreamUrl, title, description, thumbImage, musicWebapgeUrl, scene, callback)</span><br></pre></td></tr></table></figure></p><p>表现(分享到好友):</p><p><img src="https://lh3.googleusercontent.com/-CcKR16KLjD4/W441by2jDAI/AAAAAAAAAWw/DFJRiBzve28k3tf6lwfdr5CshnZWiBejwCHMYCw/I/15360464461727.jpg" alt=""></p><p><strong>小程序分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.getInstance().shareMiniProgram(context, userName, path, MiniProgramType, webapgeUrl, title, description, thumbImage, scene, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.instance.shareMiniProgram(context, userName, path, MINIPROGRAM_TYPE, webpageUrl,title, description, thumbImage, scene, callback)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 1. demo 中笔者并没有编写小程序, 仅仅依照微信的 SDK 进行了参数的设置, 所以无法分享, 但具体的参数设置形式在 demo 中明确标明.⚠️ 2. 小程序分三种类型, <code>type</code> 字段分: <strong>发布</strong>、<strong>预览</strong>以及<strong>体验</strong>三个版本.</p></blockquote><p><strong>文件分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.getInstance().shareFile(context, localFileUrl, title, thumbImage, scene, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWechatManager.instance.shareFile(context, localFileUrl, title, thumbImage, scene, callback)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 1. 视频文件无法打开, 需要别的应用支持, 图片和普通文档可以打开.⚠️ 2. 文件分享<strong>不支持分享到朋友圈</strong>.⚠️ 3. 在设置<strong>缩略图</strong>的情况下, iOS 端的对话框是不显示缩略图的, 但是 Android 可以, 但也仅限于发送方能看见.</p></blockquote><p>表现(分享视频到微信好友):<img src="https://lh3.googleusercontent.com/-OrqFKygZa6k/W45JKvdpI-I/AAAAAAAAAW8/d4Y4Z3t2LVMwQDs55fpwoOyUPfq23eouQCHMYCw/I/15360514953939.jpg" alt=""><img src="https://lh3.googleusercontent.com/-_d5Fmi8rENk/W45JMexbPEI/AAAAAAAAAXA/NkL3Wlo_45wRAotYADgDMaK3-UplPvn2QCHMYCw/I/15360515040489.jpg" alt=""></p><h3>新浪</h3><h4>准备</h4><p>分享需要注册平台, <a href="http://open.weibo.com/" target="_blank" rel="noopener">新浪开放平台</a>, <a href="http://open.weibo.com/wiki/SDK#android_SDK" target="_blank" rel="noopener">SDK 下载</a>, 新浪 SDK <strong>支持 compile 集成</strong>, <a href="https://github.com/sinaweibosdk/weibo_android_sdk" target="_blank" rel="noopener">Android 接口调用文档</a>.</p><h4>集成</h4><p>a.在 <strong>Project 级 <code>build.gradle</code> 中配置:</strong></p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url "https://dl.bintray.com/thelasterstar/maven/" &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <strong>Application 级 <code>build.gradle</code> 中配置:</strong></p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile 'com.sina.weibo.sdk:core:4.3.0:openDefaultRelease@aar'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>接口及内部实现</h4><p><strong>a. 内部初始化 SDK</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WbSdk.install(context, <span class="keyword">new</span> AuthInfo(context, key, redirectUrl, scope));</span><br><span class="line">WbShareHandler handler = <span class="keyword">new</span> WbShareHandler((Activity) context);</span><br><span class="line">handler.registerApp();</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WbSdk.install(context, AuthInfo(context, key, redirectUrl, scope))</span><br><span class="line"><span class="keyword">val</span> handler = WbShareHandler(context <span class="keyword">as</span> Activity)</span><br><span class="line">handler.registerApp()</span><br></pre></td></tr></table></figure></p><blockquote><p>仅做<em>分享</em>的话, <code>secret</code> 字段无用.</p></blockquote><p><strong>b. 分享</strong></p><p>在 demo 中, 发布微博和发布照片/视频到「微博故事」笔者拆分到 <code>RSinaWeiboActivity</code> 和<code>RSinaWeiboStoryActivity</code> 中分别处理, 避免稍微麻烦的判断.</p><p>新浪分享内容模型都继承自 <code>BaseMediaObject</code>: <strong>TextObject</strong>、<strong>MultiImageObject</strong>、<strong>WebpageObject</strong>、<strong>VideoSourceObject</strong>、<strong>TextObject</strong> 设置对应属性然后通过 <code>WeiboMultiMessage</code> 发送分享请求消息体, 值得一提的是, 在分享网络链接时候, <strong>赋值到消息体的属性为 <code>mediaObject</code></strong>.</p><p>⚠️ <strong>在进行本地视频分享的时候一定一定要先对消息体进行文字分享模型赋值, 否则无论如何都无法分享.</strong></p><p>例 (Java):</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">✅</span><br><span class="line">WeiboMultiMessage message = <span class="keyword">new</span> WeiboMultiMessage();</span><br><span class="line">message.textObject = textObj;<span class="comment">// a TextObject instance</span></span><br><span class="line">message.videoSourceObject = localVideoObj;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❌</span><br><span class="line">WeiboMultiMessage message = <span class="keyword">new</span> WeiboMultiMessage();</span><br><span class="line">message.videoSourceObject = localVideoObj;</span><br></pre></td></tr></table></figure></p><p><strong>文字分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSinaWeiboManager.getInstance().shareText(context, text, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSinaWeiboManager.instance.shareText(context, text, callback)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-GSsYGRe_qeg/W45RXUDPbhI/AAAAAAAAAXQ/Gz9oC33gt4YqU4S5WlFy42gZH8fUfh-zQCHMYCw/I/15360535953706.jpg" alt=""></p><p><strong>图片分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSinaWeiboManager.getInstance().sharePhoto(context, targetImages, description, isToStory(<span class="keyword">true</span> or <span class="keyword">false</span>), listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSinaWeiboManager.instance.sharePhoto(context, targetImages, description, isToStory(<span class="literal">true</span> or <span class="literal">false</span>), callback)</span><br></pre></td></tr></table></figure></p><p>为统一接口, 图片用数组包装; 分享到「微博故事」功能中 <code>descripiton</code> 字段会失效.</p><blockquote><p>⚠️ 1. 开启「分享到微博故事」功能图片只能传一张; 多张图片分享的情况下「分享到微博故事」的功能必须关闭!⚠️ 2. 图片单张不能超过 10 MB, 最多 9 张图片.⚠️ 3. 在分享图片的时候最好提前打开微博客户端, 否则会很慢, 或者压根不调起客户端.</p></blockquote><p>表现:分享到微博:<img src="https://lh3.googleusercontent.com/-N5QLcImNntc/W45TR4j7hZI/AAAAAAAAAXo/aKyWZLFkzOYBhhzW2kDgbHgFPJUy5Qz2ACHMYCw/I/15360540872534.jpg" alt=""></p><p>分享到「微博故事」:<img src="https://lh3.googleusercontent.com/-4RLl_LN0sac/W45TD5-fRRI/AAAAAAAAAXk/zhXMgiy7LOkW4UlZG2Da699UK2BTq6QTwCHMYCw/I/15360540282306.jpg" alt=""></p><p><strong>本地视频分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSinaWeiboManager.getInstance().shareLocalVideo(context, localVideoUrl, description, isToStory(<span class="keyword">true</span> or <span class="keyword">false</span>), listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSinaWeiboManager.instance.shareLocalVideo(context, localVideoUrl, description, isToStory(<span class="literal">true</span> or <span class="literal">false</span>), callback)</span><br></pre></td></tr></table></figure></p><p>表现(分享到微博):</p><p><img src="https://lh3.googleusercontent.com/-YVT2ayySR6I/W5chW1iHrMI/AAAAAAAAAX4/GMCxl-itNoEk_jJa89nplur8JFkzvedFgCHMYCw/I/15366311285837.jpg" alt=""></p><p>表现(分享到「微博故事」):<img src="https://lh3.googleusercontent.com/-6u1wLkwp9gI/W5chbBWK83I/AAAAAAAAAX8/P95diV00laEFaTIzr1aUk8U99sQ5UTreACHMYCw/I/15366311481945.jpg" alt=""></p><p><strong>网页分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSinaWeiboManager.getInstance().shareWebpage(context, webapgeUrl, title, description, thumbImage, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSinaWeiboManager.instance.shareWebpage(context, webpageUrl, title, description, thumbImage,callback)</span><br></pre></td></tr></table></figure></p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-vbuWfq1M1n8/W5coCWrME6I/AAAAAAAAAYM/MFi4hsw7h-kFGdA3qhpjNn9vGp0NMPFVACHMYCw/I/15366328390733.jpg" alt=""></p><blockquote><p>⚠️ 1. 网页 <code>thumbImage</code> 字段的缩略图数据不能大于 550 Kb <strong>(新浪的 SDK 控制的很严格)</strong>.⚠️ 2. 在这里表现和 iOS 略有不同.</p></blockquote><h3>Facebook</h3><h4>准备</h4><p>分享需要注册平台, <a href="https://developers.facebook.com/" target="_blank" rel="noopener">Facebook 开发者主页</a>, Facebook SDK <strong>支持 compile 集成</strong>, <a href="https://developers.facebook.com/docs/sharing/android" target="_blank" rel="noopener">分享接口调用说明</a>.</p><h4>集成</h4><p>a.在 <strong>Project 级 <code>build.gradle</code> 中配置:</strong></p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <strong>Application 级 <code>build.gradle</code> 中配置:</strong></p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation 'com.facebook.android:facebook-share:4.34.0'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>b. 在 <strong>AndroidManifest.xml</strong> 的 <code>&lt;application&gt;</code> 节点下增加:</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"com.facebook.sdk.ApplicationId"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"@string/facebook_app_id"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:authorities</span>=<span class="string">"com.facebook.app.FacebookContentProviderYOURAPPID"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">"com.facebook.FacebookContentProvider"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"com.facebook.CustomTabActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"fbYOURAPPID"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4>接口调用及内部实现</h4><p><strong>a. 内部初始化 SDK</strong></p><p>Facebook 分享在配置 <strong>AndroidManifest.xml</strong> 后无需代码代码初始化.</p><p><strong>b. 分享</strong></p><p>参数的包装, 借助工具类 <code>RFacebookHelper</code> 来处理, Facebook 已经封装好了各个类型的分享内容载体 (SharePhotoContent、ShareVideoContent ...), 对应设置属性值就可以; 对于图片的分享, 和新浪的图片分享思路相同, 即: 无论是单张还是多图, 一概通过数组包装传递给 <code>RFacebookHelper</code>, 然后它自行处理.</p><p><strong>网页分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RFacebookManager.getInstance().shareWebpage(context, webapgeUrl, description, hashTag, mode , listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RFacebookManager.instance.shareWebpage(context, webpageUrl, description, hashTag, mode, callback)</span><br></pre></td></tr></table></figure></p><p>Facebook 的 SDK 在迭代的过程中, 舍弃了很多字段, 分享参数不如新浪那样多样, 但是其分享的表现形式却比国内的要友好很多, 特别是在网页分享这块体现的更加明显, 值得注意的是, <strong>非网页形式的分享回调无效</strong>, 努力地在 <strong>Github</strong>、<strong>Stack Overflow</strong> 和 <strong>Facebook Developer 论坛</strong>找答案但都没有找到解决办法, 根据 <code>postId</code> 的判断分享结果状态的方法早已失效, 无论是 Android 还是 iOS 端, 目前都没办法.</p><blockquote><p>⚠️ <code>hashTag (话题)</code> 的表现形式不同于国内, 新浪的话题格式: <strong>#话题#</strong>, 两个 <strong>#</strong> 之间一切内容都能成为话题, 而 Twitter、Instagram、Facebook 的格式: <strong>#话题</strong>, 话题内容词组之间不能有任何符号且必须连在一起.</p></blockquote><p>表现:客户端形式的分享(无回调):<img src="https://lh3.googleusercontent.com/-Xqf4psPm0SM/W5cu2VZiQyI/AAAAAAAAAYY/v3kmkYC1C0QYCm83zH9_CyVwVdtVtdYmwCHMYCw/I/15366345820939.jpg" alt=""></p><p><strong>iOS 端是跳转到 Facebook 客户端分享, 且在通过客户端分享的过程中, <code>quote</code> 字段已经丢失; 且 Android 通过客户端分享需要提前打开 Facebook 客户端, 否则无法弹出分享对话框, 测试过美图秀秀的图片分享, 也是一样, 需要提前打开客户端.</strong></p><p>网页形式的分享(有回调):<img src="https://lh3.googleusercontent.com/-YXURoOGNuJc/W5cxUoJ8M9I/AAAAAAAAAYk/_T40tCXIkz0tlRDreQ-sEYG5xJMpmRZywCHMYCw/I/15366352153227.jpg" alt=""></p><p><strong>图片分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RFacebookManager.getInstance().sharePhoto(context, targetImages);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RFacebookManager.instance.sharePhoto(context, targetImages)</span><br></pre></td></tr></table></figure></p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-yFCTb2hHMAU/W5cyjMJqnWI/AAAAAAAAAYw/JxFTudmZYYA2IEDRjo7JUSbPB_xT1vP5wCHMYCw/I/15366355297333.jpg" alt=""></p><p><strong>本地视频分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RFacebookManager.getInstance().shareLocalVideo(context, localVideoUrl);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RFacebookManager.instance.shareLocalVideo(context, localVideoUrl)</span><br></pre></td></tr></table></figure></p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-abqHI4K0exU/W5czPT4tQXI/AAAAAAAAAY4/_lWw41A4zig5LnA-ocY1SnT6x21V7ptmgCHMYCw/I/15366357079456.jpg" alt=""></p><p><strong>c. 获取散列</strong></p><p><code>RFacebookManager</code> 提供了获取散列的方法.</p><h3>Twitter</h3><h4>准备</h4><p>分享需要注册平台, <a href="https://developer.twitter.com/content/developer-twitter/en.html" target="_blank" rel="noopener">Twitter 开发者主页</a>, <a href="https://apps.twitter.com/" target="_blank" rel="noopener">注册应用主页</a>, Twitter SDK <strong>支持 compile 集成</strong>, <a href="https://github.com/twitter/twitter-kit-android/wiki/Compose-Tweets" target="_blank" rel="noopener">分享接口调用说明</a>.</p><p><strong>⚠️: Twitter SDK 将于 2018/10/31 后不再进行维护, 但是不影响后续使用, 需自行维护, <a href="https://blog.twitter.com/developer/en_us/topics/tools/2018/discontinuing-support-for-twitter-kit-sdk.html" target="_blank" rel="noopener">Twitter 产品经理 Neil Shah 对 Twitter SDK 放弃维护迭代的声明博客</a>.</strong></p><h4>集成</h4><p>a. 在 <strong>Project 级 <code>build.gradle</code> 中配置:</strong></p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <strong>Application 级 <code>build.gradle</code> 中配置:</strong></p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation 'com.twitter.sdk.android:tweet-composer:3.1.1'</span><br><span class="line">    implementation 'com.twitter.sdk.android:twitter-core:3.1.1'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>接口调用及内部实现</h4><p><strong>a. 内部初始化 SDK</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TwitterConfig config = <span class="keyword">new</span> TwitterConfig.Builder(context)</span><br><span class="line">                .logger(<span class="keyword">new</span> DefaultLogger(Log.DEBUG))</span><br><span class="line">                .twitterAuthConfig(<span class="keyword">new</span> TwitterAuthConfig(key, secret))</span><br><span class="line">                .debug(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">Twitter.initialize(config);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = TwitterConfig.Builder(context)</span><br><span class="line">                .logger(DefaultLogger(Log.DEBUG))</span><br><span class="line">                .twitterAuthConfig(TwitterAuthConfig(key, secret))</span><br><span class="line">                .debug(<span class="literal">true</span>)</span><br><span class="line">                .build()</span><br><span class="line">Twitter.initialize(config)</span><br></pre></td></tr></table></figure></p><p><strong>b. 授权 Twitter 客户端</strong>与其他平台分享不同的是, Twitter 在进行发推(分享)的时候会先进行检测本地的 <code>activeSession</code> 的标记判断是否登录(授权)过, 所以在进行发推的时候需要进行这一步的判断, 在未登录的情况下需进行授权, 在此使用 <code>RTwitterAuthHelper</code> 进行处理, 登录(授权监听接口以及 callback):</p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RTwitterAuthCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(String errorInfo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> typealias RTwitterAuthCallback = ((state : <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span>)</span><br></pre></td></tr></table></figure></p><p>Kotlin 的 callback <code>state</code> 包括成功失败两种结果.</p><p><strong>判断是否登录过:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTwitterAuthHelper.getInstance().hasLogged()</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTwitterAuthHelper.instance.hasLogged</span><br></pre></td></tr></table></figure></p><p><strong>登录授权:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RTwitterAuthHelper.getInstance().authorizeTwitter(context, <span class="keyword">new</span> RTwitterAuthCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(String errorInfo)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// ...                    &#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RTwitterAuthHelper.instance.authorizeTwitter(context) &#123; state -&gt;</span><br><span class="line">    <span class="keyword">when</span> (state) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// ...     </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这一步<strong>目前的情况就是把 Twitter SDK 提供的授权方法重新包装写了遍, 但是考虑到未来可能用到 <code>session</code> 和 <code>token</code> 等信息并处理, 所以单独写了类讲授权和分享隔离.</strong></p><p><strong>c. 分享</strong></p><p>在本人写的 demo 中, <em>分享</em>和<em>登录授权</em>是衔接的, 即: 若未登录过 -&gt; 登录授权 -&gt; 分享.Twitter 能分享的内容相对较少, 所以关于<strong>文字、网页、图片</strong>的分享, 统一到一个分享接口里, 三者不能同时为空.另, Twitter Android 分享包括两种模式: <strong>直接构建 Intent 分享和跳转 Twitter 客户端分享</strong>, 前者有回调(Demo 中注册 <code>RTwitterTweetResultReciver</code> 监听回调), 后者无回调且支持 <code>hashTag</code>.</p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTwitterManager.getInstance().share(context, webapgeUrl, description, targetImage, hashTag, mode, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTwitterManager.instance.share(context, webpageUrl, description, targetImage, hashTag, mode, callback)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 测试多次发推内容不要重复, 否则会分享失败.</p></blockquote><p>表现:</p><p>应用内分享(有回调):<img src="https://lh3.googleusercontent.com/-c5I4chuawhk/W5dnV0p1ksI/AAAAAAAAAZE/HBu1kom59Rs_q2B3ZMtQqzqPJBnbJRccACHMYCw/I/15366490447032.jpg" alt=""></p><p>跳转 Twitter 客户端分享(无回调):</p><p><img src="https://lh3.googleusercontent.com/-oA7HlkrGvx0/W5dnu8fKzKI/AAAAAAAAAZU/g6qT1kewvPk-Yzb1LnlH_kad--REvEQDQCHMYCw/I/15366491440513.jpg" alt=""></p><h3>Instagram</h3><h4>准备</h4><p>分享无需注册平台无需 SDK, <a href="https://www.instagram.com/developer/" target="_blank" rel="noopener">Instagram 开发者主页</a>, <a href="https://www.instagram.com/developer/mobile-sharing/android-intents/" target="_blank" rel="noopener">构建 Intent 方式分享</a>.</p><h4>接口调用及内部实现</h4><p><strong>分享</strong></p><p>Intent 构建(以 Java 为例):</p><p>图片:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_STREAM, targetImageUrl);</span><br><span class="line">intent.setPackage(<span class="string">"com.instagram.android"</span>);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure></p><p><strong>图片分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RInstagramManager.getInstance().shareImage(context, targetImage);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RInstagramManager.instance.shareImage(context, targetImage)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-nXN8PeYeBI8/W5druQz7D7I/AAAAAAAAAZg/tqdkoNdlZ_gYq5pb2VTS6qe7nB8go0slwCHMYCw/I/15366501677018.jpg" alt=""></p><p>本地视频:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent.setType(<span class="string">"video/*"</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_STREAM, localVideoUrl);</span><br><span class="line">intent.setPackage(<span class="string">"com.instagram.android"</span>);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure></p><p><strong>本地视频分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RInstagramManager.getInstance().shareVideo(context, localVideoUrl);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RInstagramManager.instance.shareVideo(context, localVideoUrl)</span><br></pre></td></tr></table></figure></p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-53x4U8Iht94/W5drxU3QLhI/AAAAAAAAAZk/zebiYGtry1McCJ6P35Es-niqeCMyzfh-ACHMYCw/I/15366501815031.jpg" alt=""></p><h3>Tumblr</h3><h4>准备</h4><p>分享需要注册平台, <a href="https://www.tumblr.com/developers" target="_blank" rel="noopener">Tumblr 开发者主页</a>, <a href="https://dev.flurry.com/admin/applications" target="_blank" rel="noopener">注册应用主页</a>, Tumblr SDK <strong>支持 compile 集成</strong>, <a href="https://developer.yahoo.com/flurry/docs/integrateflurry/android/" target="_blank" rel="noopener">分享接口调用说明</a>.</p><h4>集成</h4><p>a. 此 Demo 中是手动集成的 6.1.0 版本的 SDK.</p><p>⚠️: 一定是这个版本的, 最新版本的 SDK 我没有找到分享的接口.</p><h4>接口调用及内部实现</h4><p><strong>a. 内部初始化 SDK</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FlurryAgent.setLogEnabled(<span class="keyword">true</span>);</span><br><span class="line">FlurryAgent.init(context, flurryKey);</span><br><span class="line">TumblrShare.setOAuthConfig(key, secret);</span><br></pre></td></tr></table></figure></p><p>⚠️ 在 iOS 端初始化 SDK 仅需要 <code>key</code> 和 <code>secret</code> 两个参数.</p><p><strong>b. 分享</strong></p><p>Tumblr 分享体只包括<strong>图片</strong>和<strong>文字</strong>两种, 并且图片还是网络图片的链接, 并不能分享本地图片, 所以 Tumblr 的局限性很大, 这两种分享体的模型通过 SDK 中 <code>PhotoPost</code> 和 <code>TextPost</code> 来构建;Tumblr 分享是通过当前界面弹出对话框分享的, 和 Twitter 类似, 所以不需要判断 Tumblr 程序是否安装;Tumblr 的分享流程是: <strong>登录 -&gt; 分享</strong>, 但是登录的逻辑不需要在代码中实现, 他会自动呈现浏览器的登录界面.</p><p><strong>文字分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTumblrManager.getInstance().shareText(context, description, title, webapgeUrl, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTumblrManager.instance.shareText(context, description, title, webpageUrl, callback)</span><br></pre></td></tr></table></figure></p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-cuff8oox2QA/W5dut_wRKII/AAAAAAAAAZ0/b0KlLvRRbicTVejB97QaI5DSn-5yWABXQCHMYCw/I/15366509337750.jpg" alt=""></p><p><strong>图片链接分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTumblrManager.getInstance().shareImage(context, targetImageUrl, description, webapgeUrl, listener);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTumblrManager.instance.shareImage(context, targetImageUrl, description, webpageUrl, callback )</span><br></pre></td></tr></table></figure></p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-MOOQGS65kE4/W5dvOW95NhI/AAAAAAAAAZ8/xdpBtn3Lr187Fm6zjHKoCfl-fsj64uDMwCHMYCw/I/15366510641749.jpg" alt=""></p><h3>Pinterest</h3><h4>集成</h4><p>Android 端无需集成 SDK, 仅通过 Intent 方式就可以分享, 但是 iOS 需要.</p><p><strong>b. 分享</strong></p><p><strong>Pinterest 只能分享图片链接.</strong></p><p>Intent 构建(以 Java 为例):</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent.setPackage(<span class="string">"com.pinterest"</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_STREAM, Uri.parse(targetImageUrl));</span><br><span class="line">intent.setType(<span class="string">"*/*"</span>);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure></p><p><strong>图片链接分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPinterestManager.getInstance().shareImage(context, targetImageUrl);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPinterestManager.instance.shareImage(context, targetImageUrl)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-IQc0WbK_d2Q/W5dyAGaQ1AI/AAAAAAAAAaI/M1V76h1-NFg-Kh84iCjFOQ50BI9AYCT7QCHMYCw/I/15366517749056.jpg" alt=""></p><h3>Line</h3><h4>集成</h4><p>无需集成 SDK, 仅通过 Intent 方式就可以分享.</p><p><strong>b. 分享</strong></p><p>Intent 构建(以 Java 为例):</p><p>文字：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(Intent.ACTION_SEND);</span><br><span class="line">intent.putExtra(Intent.EXTRA_TEXT, text);</span><br><span class="line">intent.setType(<span class="string">"text/*"</span>);</span><br><span class="line">intent.setPackage(<span class="string">"jp.naver.line.android"</span>);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure></p><p><strong>文字分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLineManager.getInstance().shareText(context, text);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLineManager.instance.share(context, text)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-ps4ZtMCw-R0/W5d-SMQEz0I/AAAAAAAAAaY/BgkApt-Nzgo3LBvYIBACO0uYO2EgR-thQCHMYCw/I/15366549202862.jpg" alt=""></p><p>图片:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_STREAM, targetImageUrl);</span><br><span class="line">intent.setPackage(<span class="string">"jp.naver.line.android"</span>);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure></p><p><strong>图片分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLineManager.getInstance().shareImage(context, targetImage);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLineManager.instance.share(context, targetImage)</span><br></pre></td></tr></table></figure></p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-WIxiBag-ZsE/W5d-I4YUj9I/AAAAAAAAAaU/-4XSuRZpELsRUzbNFssC7AgHAUkD9hgNgCHMYCw/I/15366548801345.jpg" alt=""></p><h3>WhatsApp</h3><h4>准备</h4><p>分享无需注册平台.</p><p>Android 端无需集成 SDK, 仅通过 Intent 方式就可以分享, 但是 iOS 需要.</p><p><strong>b. 分享</strong></p><p>WhatsApp 支持同时分享文字和图片, iOS 端不可以.</p><p>Intent 构建(以 Java 为例):</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(Intent.ACTION_SEND);</span><br><span class="line">intent.putExtra(Intent.EXTRA_TEXT, description);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_STREAM, targetImageUrl);</span><br><span class="line">intent.setType(<span class="string">"image/jpeg"</span>);</span><br><span class="line">intent.setPackage(<span class="string">"com.whatsapp"</span>);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure></p><p><strong>图文分享:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWhatsAppManager.getInstance().share(context, targetImage, description);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWhatsAppManager.instance.share(context, targetImage, description)</span><br></pre></td></tr></table></figure></p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-b2WSm80d_Us/W5eC13XcH1I/AAAAAAAAAak/3CsSs5ULiQ8Ng_-6zU3vyVrmCyzbEw2VgCHMYCw/I/15366560853962.jpg" alt=""></p><h3>GooglePlus</h3><h4>准备</h4><p>需要注册平台, <a href="https://developers.google.com/+/" target="_blank" rel="noopener">Google Plus 开发者主页</a>, <a href="https://developers.google.com/+/mobile/android/getting-started" target="_blank" rel="noopener">创建流程</a>.</p><h4>集成</h4><p>需要 <strong>Google Service 的支持</strong>, 在 <strong>Application 级 <code>build.gradle</code> 中配置:</strong></p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation 'com.google.android.gms:play-services-plus:15.0.1'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>接口调用及内部实现</h4><p>Google Plus 分享只支持<strong>分享网页</strong>,  通过 <code>PlusShare.Builder</code> 来构建网页分享模型, Java 为例:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent shareIntent = <span class="keyword">new</span> PlusShare.Builder(context)</span><br><span class="line">                .setType(<span class="string">"text/plain"</span>)</span><br><span class="line">                .setText(text)</span><br><span class="line">                .setContentUrl(Uri.parse(webpageUrl)</span><br><span class="line">                .getIntent();</span><br></pre></td></tr></table></figure></p><p><strong>分享网页:</strong></p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RGooglePlusManager.getInstance().share(context, webapgeUrl, description);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RGooglePlusManager.instance.share(context, webpageUrl, description)</span><br></pre></td></tr></table></figure></p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-1yxGGEo9QuI/W5eHx0NVl3I/AAAAAAAAAaw/og3n-vItwB8ruMgT6rfqD5OA46CS3QjoQCHMYCw/I/15366573475615.jpg" alt=""></p><h2>统一分享接口</h2><h3>缺陷</h3><p><strong>缺陷说在前面, 其实本来不打算统一接口的.</strong></p><ul><li>主分享 Manager 和子平台分享 Manager 存在耦和(没有参考 ShareSDK 的 jar 包方式去做);</li><li>分享接口优化受限制, 由于前面的平台分享对比表格可知, 国外的平台分享很多都没有回调, 而国内的平台分享内容又存在多种形式, 无法实现高度统一;</li><li>添加平台没有做<strong>去重处理</strong>, 造成不必要的开销;</li></ul><h3>类图</h3><p><img src="https://lh3.googleusercontent.com/-O0rTTel0iHc/W5eJdrZJVII/AAAAAAAAAbI/JdickRAMap45EJT6Lrmizg1X6z9mJqtOACHMYCw/I/Android%2B" alt="Android 统一接口类图"></p><ul><li><strong>RShareManger:</strong> 主分享 Manager, 子平台 Manager 的初始化、分享、应用跳转和一些其他操作都在此进行;</li><li><strong>RImageContent、RVideoContent、RTextContent、RWebpageContent</strong> 为四种对应分享内容模型.</li></ul><h3>详细设计</h3><p><strong>分享频道</strong></p><p>以 Java 为例, 在 <code>RShareManager</code> 种定义了分享通道枚举:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareChannel</span> </span>&#123;</span><br><span class="line">    QQSession,</span><br><span class="line">    QQFavorite,</span><br><span class="line">    QQDataLine,</span><br><span class="line">    QZone,</span><br><span class="line">    WechatSession,</span><br><span class="line">    WechatFavorite,</span><br><span class="line">    WechatTimeline,</span><br><span class="line">    FacebookClient,</span><br><span class="line">    FacebookBroswer,</span><br><span class="line">    TwitterInnerApp,</span><br><span class="line">    TwitterClient,</span><br><span class="line">    SinaWeibo,</span><br><span class="line">    SinaWeiboStory,</span><br><span class="line">    Line,</span><br><span class="line">    Instagram,</span><br><span class="line">    Tumblr,</span><br><span class="line">    Pinterest,</span><br><span class="line">    GooglePlus,</span><br><span class="line">    WhatsApp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>接口</h3><p><strong>构建分享模型</strong></p><p>以 <code>RImageContent</code> 为例:</p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RImageContent content = <span class="keyword">new</span> RImageContent.Builder(targetImage, targetImageUrl)</span><br><span class="line">                 <span class="comment">// ...</span></span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> content : RImageContent = RImageContent().apply &#123; </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>分享：</strong></p><p>以分享 <code>RImageContent</code> 为例:</p><p>Java:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RShareManager.getInstance().shareImage(context, content, channel, <span class="keyword">new</span> RShareListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(RSharePlatform.Platform platform)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...  </span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(RSharePlatform.Platform platform, String errorInfo)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">(RSharePlatform.Platform platform)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>Kotlin:</p><p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> RShareManager.instance.shareImage(context, content, channel) &#123; platform, state, errorInfo -&gt;</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>源码</h2><p><a href="https://github.com/rexzx/rshare_java" target="_blank" rel="noopener">Java 版本源码</a>、 <a href="https://github.com/rexzx/rshare_kotlin" target="_blank" rel="noopener">Kotlin 版本源码</a>, 还在学习中, 请多指教.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为公司的项目里集成了一键分享的这个模块, 而在我设计的时候发现国内的官方文档和提供的 Sample 有混乱和容易混淆的地方, 而且除了普通的网页、图片、文字分享到各大 Social 平台以外, 对于视频、文件和其他内容的分享 Demo 在百度或者 Google 几乎搜不到
      
    
    </summary>
    
    
      <category term="share" scheme="http://yoursite.com/tags/share/"/>
    
      <category term="social" scheme="http://yoursite.com/tags/social/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>「RSHARE」 一键分享 iOS 版</title>
    <link href="http://yoursite.com/2018/08/28/2018-08-28/"/>
    <id>http://yoursite.com/2018/08/28/2018-08-28/</id>
    <published>2018-08-28T09:05:43.000Z</published>
    <updated>2018-09-04T07:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为公司的项目里集成了一键分享的这个模块, 而在我设计的时候发现国内的官方文档和提供的 Sample 有混乱和容易混淆的地方, 而且除了普通的网页、图片、文字分享到各大 Social 平台以外, 对于视频、文件和其他内容的分享 Demo 在百度或者 Google 几乎搜不到. 自己也是踩了很多坑才把很多问题解决.</p><h2>测试设备</h2><p>iPhone 7 Plus, iOS 11.4.1.</p><h2>支持平台</h2><p><strong>RSHARE</strong> 这个 Demo 中支持: 微信、QQ、新浪微博、Facebook、GooglePlus(Google +)、Twitter、WhatsApp、Line、Tumblr、Instagram、Pinterest 11 个 Social 平台.</p><h3>平台差异</h3><p>主要罗列了常用的 5 个分享内容的对比菜单(网页、文字、图片、本地视频、文件).<strong>注意菜单内字母以及菜单后面对应字母的注释⚠️</strong></p><table><thead><tr><th>❤️</th><th>QQ</th><th>微信</th><th>微博</th><th>Facebook</th><th>Twitter</th><th>Instagram</th><th>WhatsApp</th><th>Line</th><th>Tumblr</th><th>Pinterest</th><th>Google+</th></tr></thead><tbody><tr><td>网页</td><td>✓a</td><td>✓</td><td>✓</td><td>✓b</td><td>✓</td><td>✗</td><td>✓</td><td>✓</td><td>✓</td><td>✗</td><td>✓</td></tr><tr><td>文字</td><td>✓c</td><td>✓</td><td>✓</td><td>✗</td><td>✓</td><td>✗</td><td>✓</td><td>✓</td><td>✓</td><td>✗</td><td>✗</td></tr><tr><td>图片</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓d</td><td>✓d</td><td>✗</td></tr><tr><td>视频</td><td>?e</td><td>✗</td><td>✓</td><td>✓</td><td>✗</td><td>✓</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td></tr><tr><td>文件</td><td>✓</td><td>✓</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td></tr></tbody></table><p>a. QQ 虽支持网页分享, 但是不允许带着网页的 <code>description</code> 字段, 且分享到 QQ 空间只支持通过文字分享, 这和 Android 表现不同;b. Facebook 的网页分享支持 <strong>hashtag</strong>;c. iOS 端分享文字到 QQ 客户端是可行的, 但是 Android 端不允许, 其实 QQ 的分享目地就是<strong>让用户自行输入有价值、有意义的文字信息</strong>;d. Pinterest 和 Tumblr 虽支持图片分享, 但仅仅支持分享图片的 URL, 它会自行解析并显示;e. QQ 客户端分享分两类: 1 好友、收藏、数据线(我的电脑)分享; 2 QQ 空间分享. 本地视频的分享只支持 QQ 空间分享.</p><blockquote><ol><li>对比列表得知, 国内的平台分享内容是最丰富的, 但是存在一个主要的问题(主要是 QQ), iOS 和 Android 双端的接口以及实现的功能也并不统一(后面的部分会具体说); 微信双端当分享的图片过大的时候的表现也有不统一的时候, 其余都很完善; 新浪的表现是最统一的, 且没有过多限制; 国内的平台分享最让人头疼的就是官方的 Sample 很混乱, 但是在实践代码的时候还是要以官方为主.</li><li>国外的文档和 Sample 很明了且注释详细, 但也存在双端不统一的情况, Twitter 的双端表现就不一样(后面细说), 但是国外的平台分享几乎没有回调, Facebook 的回调只有 Feed 形式的分享才有效, Instagram、Line、Google+这些是没有 SDK 的, 仅仅是通过打开 Application URL scheme 来分享.</li></ol></blockquote><h2>分享总体设计</h2><p>大概的分享逻辑如下:<img src="https://lh3.googleusercontent.com/-nkYbZ2cgYmc/W4UX1OlhWtI/AAAAAAAAAOs/1L_K_q1HlqgShbk-crxnCNfHRCEu6lDWwCHMYCw/I/iOS%2B" alt=" 分享逻辑"></p><p>iOS 的分享是参照各大平台的分享逻辑得到比较统一思路, 即: 先判断是否安装对应应用, 然后初始化 SDK 与官方平台连接, 然后包装分享参数进行分享, 最后处理分享回调.</p><blockquote><ol><li>有些平台不存在 SDK, 所以直接判断是否平台安装然后包装分享参数进行分享;</li><li>Tumblr 比较特殊, 有 SDK 但是不需要判断应用是否安装就可以分享, Twitter 也如此, 具体情况在 Twitter 的部分说明;</li><li>SDK 的初始化, 统一函数名字为 <code>sdkInitialize</code>, <code>Key</code>、<code>Secret</code>以及<code>AppID</code>等信息在注释中有标明.</li></ol></blockquote><h2>详细逻辑</h2><p><strong>关于各个平台的开发者主页和文档信息以这里为主, 代码注释的可能不准确.</strong></p><p>平台分享都是通过<strong>单例模式</strong>实现.</p><p><strong>在手动导入框架的时候尽量, 放在项目根目录下然后通过下图的方式导入:</strong><img src="https://lh3.googleusercontent.com/-nBpiXhkaRik/W4UYPSwxW0I/AAAAAAAAAO0/q5MIjcFrvikjPcupMmDhnpwjb2pPI8I5gCHMYCw/I/15354491482307.jpg" alt=""></p><blockquote><p>在项目级 <code>Framework</code> 目录下右键执行 <code>Add Files to &quot;name&quot;</code>.</p></blockquote><p>子平台分享完毕<strong>返回到本应用</strong>的接口再封装 Objective-C 版本用的是<strong>实例方法</strong>, Swift 版本使用的是<strong>类方法</strong>.</p><h3>基类</h3><p>子平台 Manager 都是继承自<strong>RShare</strong>, 这个类中定义了分享 <strong>Mode(代码注释中有标明, iOS 中使用范围较小)</strong>、分享结果 <strong>ShareResult</strong> (成功、取消、失败)以及最重要的<strong>回调</strong>.</p><p><strong>回调:</strong>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^RShareCompletion)(RShareSDKPlatform platform, ShareResult result, <span class="built_in">NSString</span>* _Nullable errorInfo);</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">RShareCompletion</span> = (<span class="number">_</span> paltform : <span class="type">RShareSDKPlatform</span>,<span class="number">_</span> result : <span class="type">ShareResult</span>,<span class="number">_</span> errorInfo : <span class="type">String</span>?) -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure></p><p><strong>Mode(仅对 Facebook、Twitter、Instagram 有效, Android 亦然):</strong>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, Mode) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     @Displays 优先选择原生应用分享, 原生应用未安装的情况可能跳转内置 WebView 或者 Safari 进行分享.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ShareModeAutomatic,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     @Displays 原生应用分享.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ShareModeNative,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     @Displays 应用内置 UIWebView 分享.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ShareModeWeb,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     @Displays the dialog in the iOS integrated share sheet, 仅对 Facebook 分享有效.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ShareModeSheet,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     @Displays 跳转至 Safari 分享, 仅对 Facebook 分享有效.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ShareModeBrowser,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     @Displays 跳转至 Safari 进行 Feed 形式的分享, 仅对 Facebook 分享有效.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ShareModeFeedBrowser,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     @Displays 应用内置 UIWebView 的 Feed 形式分享, 仅对 Facebook 分享有效.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ShareModeFeed,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     @Displays iOS 的系统分享.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ShareModeSystem</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3>QQ</h3><h4>准备</h4><p>分享需要注册平台, <a href="http://open.qq.com/" target="_blank" rel="noopener">腾讯开发者主页</a>, <a href="http://wiki.open.qq.com/wiki/mobile/SDK%E4%B8%8B%E8%BD%BD" target="_blank" rel="noopener">SDK 下载</a>, QQ SDK 目前<strong>不支持 pod 安装</strong>, iOS API 调用说明<a href="http://wiki.open.qq.com/index.php?title=iOS_API%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E&amp;oldid=46716" target="_blank" rel="noopener">文档</a>.</p><h4>集成</h4><p>a. <code>TencentOpenAPI.framework</code>导入项目中;b. 添加系统依赖<code>Security.framework</code>、<code>SystemConfiguration.framework</code>、<code>CoreGraphic.framework</code>、<code>libsqilte3.0.tbd</code>、<code>CoreTelephony.framework</code>、<code>libz.tbd</code>.c. 设置 <strong>The Other Flags</strong> 为 <strong>-ObjC</strong>.d. 在<code>info.plist</code>文件的<code>CFBundleURLTypes</code>中添加:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;CFBundleURLSchemes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;string&gt;tencentYOURAPPID&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure></p><p>e. 添加以下至白名单:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;mqq&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqapi&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqwpa&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqbrowser&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mttbrowser&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqOpensdkSSoLogin&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqopensdkapiV2&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqopensdkapiV3&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqopensdkapiV4&lt;/string&gt;</span><br><span class="line">&lt;string&gt;wtloginmqq2&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqzone&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqzoneopensdk&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqzoneopensdkapi&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqzoneopensdkapi19&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqzoneopensdkapiV2&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqapiwallet&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqopensdkfriend&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqopensdkdataline&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqgamebindinggroup&lt;/string&gt;</span><br><span class="line">&lt;string&gt;mqqopensdkgrouptribeshare&lt;/string&gt;</span><br><span class="line">&lt;string&gt;tencentapi.qq.reqContent&lt;/string&gt;</span><br><span class="line">&lt;string&gt;tencentapi.qzone.reqContent&lt;/string&gt;</span><br></pre></td></tr></table></figure></p><p>f. Swift 语言集成需要 <strong>Objective-C - Swift 桥接文件</strong>.</p><h4>接口调用及内部实现</h4><p><strong>a. 初始化 SDK</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RQqManager shared] sdkInitializeByAppID:yourAppId appKey:yourAppKey];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RQqManager</span>.shared.sdkInitialize(appID: yourAppId, appKey: yourAppKey)</span><br></pre></td></tr></table></figure></p><p>内部实现 (Objective-C):</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[TencentOAuth alloc]initWithAppId:appID andDelegate:<span class="keyword">self</span>];</span><br></pre></td></tr></table></figure></p><blockquote><p>由此看出, 其实仅仅是用作<strong><em>分享</em></strong>功能的话, 是不需要 <code>appKey</code> 这个字段的.</p></blockquote><p><strong>b. 分享</strong></p><p>对于分享内容的包装, 通过建立 <strong>RQqHelper</strong> 来实现分享内容的处理和平台 <strong>Manager</strong> 的分隔, 这样有利于逻辑的处理, 结构明显, 代码可控.关于参数包装的细节, 没什么好细说的, QQ 提供的接口简单明了(Android 不是这样).</p><p>另, 除在 <code>QQApiInterfaceDelegate</code> 代理函数 <code>- (void)onResp:(QQBaseResp *)resp</code> 中处理分享回调外, 在发起手 Q 分享请求的接口 <code>[QQApiInterface sendReq: request]</code> 返回的 <strong>QQApiSendResultCode</strong> 做了<strong>分享失败的请求码</strong>处理, Objective-C 中单独建立的处理函数 <code>- (void)handleResultCode:(QQApiSendResultCode)code</code>, Swift 则直接在 <strong>resultCode</strong> 的 <code>set 方法</code>处理.</p><p>分享到 QQ 的接口中 <code>scene</code> 字段细分到 QQ 好友、我的收藏、数据线(我的电脑), <strong>但 Android 中不支持直接打开‘我的收藏’和‘数据线(我的电脑)’面板, 须自行选择.</strong></p><p><strong>文字分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RQqManager shared] shareTextToQQ:text scene:scene completion:completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RQqManager</span>.shared.share(text: text, scene: scene, completion: completion)</span><br></pre></td></tr></table></figure></p><p>表现(QQ 好友分享):</p><p><img src="https://lh3.googleusercontent.com/-Vp5k2Jeea5s/W4UbVJdJGkI/AAAAAAAAAPU/D2NEk19T6mQ9x2vPu3-GyXQhZztjF7l_gCHMYCw/I/15354499398368.jpg" alt=""></p><p><strong>图片分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RQqManager shared] shareImageToQQ:targetImage title:title description:description scene:scene completion:completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RQqManager</span>.shared.share(image: targetImage, title: title, description: description, scene: scene, completion: completion)</span><br></pre></td></tr></table></figure></p><p>表现(QQ 好友分享且分享面板样式):<img src="https://lh3.googleusercontent.com/-ErRQl0eJpeg/W4Ubi-g9cII/AAAAAAAAAPY/-bbsGVhG8RItJh1X-_jVycwA_LiDkWVggCHMYCw/I/15354499949591.jpg" alt=""></p><p><strong>网页分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RQqManager shared] shareWebpageToQQWithURL:webpageURL title:title description:description thumbImage:image scene:scene completion:completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RQqManager</span>.shared.share(webpageURL: webpageURL, title: title, description: description, thumbImage: image, scene: scene, completion: completion)</span><br></pre></td></tr></table></figure></p><p>表现(QQ 好友分享):<img src="https://lh3.googleusercontent.com/-MHYM0SOfRHk/W4Ub4rRBDjI/AAAAAAAAAPo/YKnnwsVd7cEGjwwjqZWJCQlCcgo2Ws-egCHMYCw/I/15354500801834.jpg" alt=""></p><p><strong>视频链分享:</strong>实质就是网页的分享, 在此不作代码示例.</p><p><strong>音频链分享:</strong>大致和网页的分享相同, 但是多了一个 <code>streamURL</code> 的字段.</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RQqManager shared] shareAudioToQQWithStreamURL:audioStreamURL title:title description:description thumbImage:image webpageURL:webpageURL scene:scene completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RQqManager</span>.shared.share(audioStreamURL: audioStreamURL, title: title, description: description, thumbImage: image, webpageURL: webpageURL, scene: scene, completion: completion)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 1.<code>Tencent.framework</code> 中 <code>QQApiVideoObject</code>的<code>flashURL</code> 属性设置音频流.⚠️ 2. <code>audioStreamURL</code> 请设置音频的音频流链接, 不要把音乐平台分享的音乐网链直接赋值在该字段上, 否则点击播放按钮是无法播放的, 音乐网链是放在 <code>webpageURL</code> 字段上的.</p></blockquote><p>表现(QQ 好友分享):<img src="https://lh3.googleusercontent.com/-5p5QMz5CkGY/W4Ucppvr1CI/AAAAAAAAAPw/qdCLblW82x8udcHyzTjCEAPHaj5JBC1pACHMYCw/I/15354502762733.jpg" alt=""></p><p><strong>文件分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RQqManager shared] shareFileToQQWithFileData:fileData fileName:fileName title:title description:description thumbImage:image completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RQqManager</span>.shared.share(fileData: filedata, fileName: fileName, title: title, description: description, thumbImage: image, compeltion: completion)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 1. <code>fileName</code> 字段设置方式是: ‘文件名’+‘.扩展名’, 形如:HelloWorld.doc, 这样 QQ 系统内部能够解析并且可以友好的展示分享内容, 经测试大部分常规的文件都能友好的展示.⚠️ 2. 文件分享<strong>只支持</strong> QQ 客户端数据线(我的电脑)分享, 并且 Android 端无法分享文件, 也或许其实是可以分享文件只不过本人技拙没发现实现方法罢.</p></blockquote><p>表现(以视频为例):<img src="https://lh3.googleusercontent.com/-xKnv6_7ebBg/W4UdbhyfQTI/AAAAAAAAAQA/ZZFvVKmYFvICLoQ5BlxSje1YPfZ7AEvrQCHMYCw/I/15354504763841.jpg" alt=""><img src="https://lh3.googleusercontent.com/-Pl9WwhypgYo/W4Udejynh2I/AAAAAAAAAQE/vYrYyzjFDHQaFZrB6qcmVF7ia9VoRATIwCHMYCw/I/15354504904821.jpg" alt=""></p><p><strong>分享文字到 QQ 空间:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RQqManager shared] shareTextToQZone:description completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RQqManager</span>.shared.share(text: description, completion: completion)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ Android 端不支持纯文字分享到 QQ 空间, 且 iOS 端不支持网页分享到 QQ 空间, 除非把字符串形式的网链通过文字的方式分享, 这是可行的.</p></blockquote><p>表现:<img src="https://lh3.googleusercontent.com/-ryCutX6_irs/W4Ud0B8t3NI/AAAAAAAAAQQ/uDY0aOn5fpM1dOZfruxhEOh_kerWf9jBgCHMYCw/I/15354505745293.jpg" alt=""></p><p><strong>分享图片到 QQ 空间:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RQqManager shared] shareImagesToQZone: targetImageArray  description:description completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RQqManager</span>.shared.share(images: targetImageArray, description: description, completion: completion)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ <code>description</code> 字段实际是失效的, 但不保证未来一定不用这个字段, 所以暂且保留这个字段.</p></blockquote><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-syLYwcpYpWY/W4Ud5CLTBOI/AAAAAAAAAQU/fYiLQzFjTWYyTP5nYwbUx1YBohhiZ4ePACHMYCw/I/15354505948736.jpg" alt=""></p><p><strong>分享本地视频到 QQ 空间:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RQqManager shared] shareVideoToQZoneWithAssetURL:videoAssetURL description:description completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RQqManager</span>.shared.share(videoAssetURL: videoAssetURL, description: description, completion: completion)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 1. <code>description</code> 字段实际是失效的.⚠️ 2. 本地视频 URL 为通过 <code>UIImagePickerController</code> 选择的媒体 <strong>info</strong> 的 <code>UIImagePickerControllerReferenceURL</code> 的值, <strong>形如: assets-library://asset/asset.MP4?id=8FF2F03F-DD84-41A5-A20C-B745E793C0DC&amp;ext=MP4</strong></p></blockquote><p>表现:<img src="https://lh3.googleusercontent.com/-8G6RSAMHpOc/W4UeDvPPAlI/AAAAAAAAAQY/Y7ylDXDDK34aVE5E_A-x04QyLhtAUsXjgCHMYCw/I/15354506381172.jpg" alt=""></p><p><strong>c. 返回本应用</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RQqManager shared] application:app openURL:url options: options];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RQqManager</span>.application(app, <span class="keyword">open</span>: url, options : options)</span><br></pre></td></tr></table></figure></p><h3>微信</h3><h4>准备</h4><p>分享需要注册平台, <a href="https://open.weixin.qq.com/" target="_blank" rel="noopener">微信开放平台</a>, <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319164&amp;token=015161c07a6a155cf6424904a9febe4301efaa49&amp;lang=zh_CN" target="_blank" rel="noopener">SDK 下载</a>, 微信 SDK <strong>支持 pod 安装</strong>, <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317332&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">分享 &amp; 收藏 API 调用说明</a>.</p><h4>集成</h4><p>a. 手动: <code>libWeChatSDK.a</code>、<code>WXApi.h</code>、<code>WXApiObject.h</code>, 导入项目中;pod 集成: <code>pod 'WechatOpenSDK'</code>, 若出现:</p><blockquote><p>Use the $(inherited) flag, orRemove the build settings from the target.🔧解决方法(引自<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=1417694084&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">微信集成说明</a>, 未亲自测试): 把工程 target 中的 build Setting 里面 <strong>PODS_ROOT</strong> 的值替换成 <strong>$(inherited)</strong>, <strong>Other Linker Flags</strong> 中 <strong>-all_load</strong> 替换成 <strong>$(inherited).</strong></p></blockquote><p>b. 添加系统依赖 <code>SystemConfiguration.framework</code>, <code>libz.dylib</code>, <code>libsqlite3.0.dylib</code>, <code>libc++.dylib</code>, <code>Security.framework</code>, <code>CoreTelephony.framework</code>, <code>CFNetwork.framework</code>.c. 手动集成的情况下, 需设置 <strong>The Other Flags</strong> 为 <strong>-ObjC</strong>.d. 在<code>info.plist</code> 文件的 <code>CFBundleURLTypes</code> 中添加:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;CFBundleURLSchemes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;string&gt;wxYOURAPPID&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure></p><p>e. 添加以下至白名单:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;weixin&lt;/string&gt;</span><br><span class="line">&lt;string&gt;wechat&lt;/string&gt;</span><br></pre></td></tr></table></figure></p><p>f. Swift 语言集成需要 <strong>Objective-C - Swift 桥接文件</strong>.</p><h4>接口调用及内部实现</h4><p><strong>a. 初始化 SDK</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RWechatManager shared] sdkInitializeByAppID:appID appSecret:secret];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RWechatManager</span>.shared.sdkInitialize(appID: appID, appSecret: secret)</span><br></pre></td></tr></table></figure></p><blockquote><p>仅做<em>分享</em>功能的话, <code>secret</code> 字段无用.</p></blockquote><p>初始化内部实现略微有区别:</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UInt64</span> typeFlag = MMAPP_SUPPORT_TEXT | MMAPP_SUPPORT_PICTURE | MMAPP_SUPPORT_VIDEO | MMAPP_SUPPORT_LOCATION | MMAPP_SUPPORT_AUDIO | MMAPP_SUPPORT_WEBPAGE; </span><br><span class="line">[WXApi registerAppSupportContentFlag:typeFlag];</span><br><span class="line">[WXApi registerApp:appID];</span><br></pre></td></tr></table></figure></p><blockquote><p>Objective-C 中同时设置多个枚举值可以通过 '|' 来实现 option 的设置.</p></blockquote><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> typeFlag : <span class="type">TypeFlag</span> = [.<span class="type">Text</span>, .<span class="type">Picture</span>, .<span class="type">Video</span>, .<span class="type">Audio</span>, .<span class="type">Webpage</span>]</span><br><span class="line"><span class="type">WXApi</span>.registerAppSupportContentFlag(typeFlag.rawValue)</span><br><span class="line"><span class="type">WXApi</span>.registerApp(appID)</span><br></pre></td></tr></table></figure></p><blockquote><p>Swift 中设置多个枚举值不可用 '|' 来实现, 想要达到这样的效果, 必须新建结构体并且实现 <code>OptionSetType</code> 协议, <code>OptionSetType</code> 改变了 Objective-C 中 <code>NS_ENUM</code> / <code>NS_OPTIONS</code> 的行为方式赋予可多选的能力.</p></blockquote><p>TypeFlag 的声明(没有写全, 但实际测试并不影响<em>文件</em>的分享):</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeFlag</span> : <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> rawValue: <span class="type">UInt64</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Text</span> = <span class="type">TypeFlag</span>(rawValue: enAppSupportContentFlag.<span class="type">MMAPP_SUPPORT_TEXT</span>.rawValue)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Picture</span> = <span class="type">TypeFlag</span>(rawValue: enAppSupportContentFlag.<span class="type">MMAPP_SUPPORT_PICTURE</span>.rawValue)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Video</span> = <span class="type">TypeFlag</span>(rawValue: enAppSupportContentFlag.<span class="type">MMAPP_SUPPORT_VIDEO</span>.rawValue)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Audio</span> = <span class="type">TypeFlag</span>(rawValue: enAppSupportContentFlag.<span class="type">MMAPP_SUPPORT_AUDIO</span>.rawValue)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Webpage</span> = <span class="type">TypeFlag</span>(rawValue: enAppSupportContentFlag.<span class="type">MMAPP_SUPPORT_WEBPAGE</span>.rawValue)     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>b. 分享</strong></p><p>微信分享的内容包装同样通过一个 <code>RWechatHelper</code> 进行单独处理, 对于文字、网页、图片、视频网链、小程序、文件的分享内容处理都很简单, 特别注意的就是对于音乐链的分享, 同 QQ 一样, 需要区别两个参数, 一个是<strong>音频流</strong>链, 一个是<strong>音频网页</strong>, 播放的是音频流, 点击背景进入的是音频网页.</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WXMusicObject* obj = [WXMusicObject object];</span><br><span class="line">obj.musicDataUrl = musicURL;</span><br><span class="line">obj.musicUrl = webpageURL;</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="type">WXMusicObject</span>()</span><br><span class="line">obj.musicUrl = audioStreamURL</span><br><span class="line">obj.musicUrl = webpageURL</span><br></pre></td></tr></table></figure></p><p><strong>文字分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RWechatManager shared] shareText:text scene: scene completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RWechatManager</span>.shared.share(text: shareDescription, scene: scene, completion: shareCompletion)</span><br></pre></td></tr></table></figure></p><p>表现(分享到好友):</p><p><img src="https://lh3.googleusercontent.com/-o2fUUxvNwcs/W4YI-snwrLI/AAAAAAAAAQs/mHN1KvfzSCIielykQq5yhdkFQTbMo_H5QCHMYCw/I/15355107755808.jpg" alt=""></p><p><strong>图片分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RWechatManager shared] shareImage:targetImage scene: scene completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RWechatManager</span>.shared.share(image: targetImage, scene: scene, completion: completion)</span><br></pre></td></tr></table></figure></p><p>表现(分享到好友列表):</p><p><img src="https://lh3.googleusercontent.com/-TmP4cckgG5k/W4YJJKitRkI/AAAAAAAAAQw/GLlGIFGTVOwWA1VCWJrI1pgCDecxeXUfgCHMYCw/I/15355108192461.jpg" alt=""></p><p><strong>网页分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RWechatManager shared] shareWebpageWithURL:webpageURL title:title description:description thumbImage:thumbImage scene: scene completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RWechatManager</span>.shared.share(webpageURL: webpageURL, title: title, description: description, thumbImage: thumbImage, scene: scene, completion: completion)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 1. <code>thumbImage</code> 字段的缩略图大小不能超过 32 Kb, 但实际测试 100 Kb 左右也是完全可行的, 但一定不能过大, 否则会出现:<strong>分享 N 次才能成功一次, 或者干脆无法调起微信的客户端进行分享</strong>.⚠️ 2. Android  对于缩略图的处理相对友好很多, 对于 iOS 无法分享的过大的缩略图数据一般情况下 Android 都能成功启动微信客户端并且成功分享(亲测).⚠️ 3. 在缩略图没有符合规范的时候, 即使成功分享在 iOS 端也会出现<strong>缩略图不显示</strong>的情况, Android 几乎都会显示.</p></blockquote><p>表现(分享到好友):<img src="https://lh3.googleusercontent.com/-7NvBzYlIjXI/W4YJXjkMN1I/AAAAAAAAAQ0/2anBhoYU_Zon4vPh-DqchfGxFJXfFx3sQCHMYCw/I/15355108753889.jpg" alt=""></p><p><strong>视频链分享:</strong>实质就是网页的分享, 在此不作代码示例.</p><p><strong>音频链分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RWechatManager shared] shareMusicWithStreamURL: audioStreamURL webpageURL:audioWebpageURL title: title description: description thumbImage:image scene:scene completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RWechatManager</span>.shared.share(audioStreamURL: audioStreamURL, webpageURL: audioWebpageURL, title: title, description: description, thumbImage: thumbImage, scene: scene, completion: completion)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 注意 <code>audioStreamURL</code> 和 <code>webpageURL</code> 的区别, 前面有提及.</p></blockquote><p>表现(分享到微信好友):<img src="https://lh3.googleusercontent.com/-cDx4NkYCZPc/W4YJjFYPhCI/AAAAAAAAAQ4/CVokIDzFsHktVslrXC0ywoTij51u4RAtgCHMYCw/I/15355109233109.jpg" alt=""></p><p><strong>小程序分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RWechatManager shared] shareMiniProgramWithUserName:userName path:path type:type webpageURL:webpageURL title:title description:description thumbImage:image scene: scene completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RWechatManager</span>.shared.shareMiniProgram(userName: userName, path: path, type: type, webpageURL: webpageURL, title: title, description: description, thumbImage: thumbImage, scene: scene, completion: completion)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 1. demo 中笔者并没有编写小程序, 仅仅依照微信的 SDK 进行了参数的设置, 所以无法分享, 但具体的参数设置形式在 demo 中明确标明.⚠️ 2. 小程序分三种类型, <code>type</code> 字段分: <strong>发布</strong>、<strong>预览</strong>以及<strong>体验</strong>三个版本.</p></blockquote><p><strong>文件分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RWechatManager shared] shareFileWithData:fileData extension:fileExtensionName title:title thumbImage:image scene:scene completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RWechatManager</span>.shared.share(fileData: fileData, extensionName: fileExtensionName, title: title, thumbImage: thumbImage, scene: scene, completion: completion)</span><br></pre></td></tr></table></figure></p><p>对于体积稍大的图片、小体积视频、doc 文本、PDF 文件 都测试过, 可以正常分享, 且通过微信内部的解析可以显示.</p><blockquote><p>⚠️ 1. 必须设置文件的<strong>扩展名</strong>.⚠️ 2. 文件分享<strong>不支持分享到朋友圈</strong>.⚠️ 3. 在设置<strong>缩略图</strong>的情况下, iOS 端的对话框是不显示缩略图的, 但是 Android 可以, 但也仅限于发送方能看见.</p></blockquote><p>表现(分享视频到微信好友):<img src="https://lh3.googleusercontent.com/-QGo4SsF44vo/W4YJ3SOMecI/AAAAAAAAAQ8/6gKbrNg0OVs2Tu5PqrK8KtMy6Xt7Y62DgCHMYCw/I/15355110031716.jpg" alt=""></p><p><img src="https://lh3.googleusercontent.com/-cyVIk6orcNM/W4YJ4qrqPrI/AAAAAAAAARA/mAhpKKsDtF4YrTJ1wxePbuV2RUPJkY4aQCHMYCw/I/15355110092048.jpg" alt=""></p><p><strong>c. 返回本应用</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RWechatManager shared] application:app openURL:url options:options];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RWechatManager</span>.application(app, <span class="keyword">open</span>: url, options : options)</span><br></pre></td></tr></table></figure></p><h3>新浪</h3><h4>准备</h4><p>分享需要注册平台, <a href="http://open.weibo.com/" target="_blank" rel="noopener">新浪开放平台</a>, <a href="http://open.weibo.com/wiki/SDK#iOS_SDK" target="_blank" rel="noopener">SDK 下载</a>, 新浪 SDK <strong>支持 pod 安装</strong>, <a href="https://github.com/sinaweibosdk/weibo_ios_sdk" target="_blank" rel="noopener">iOS 接口调用文档</a>.</p><h4>集成</h4><p>a. 手动导入 <code>WeiboSDK.h</code>、 <code>WBHttpRequest.h</code>、<code>libWeiboSDK.a</code> 和 <code>WeiboSDK.bundle</code> 到项目中.pod 集成: <code>pod &quot;Weibo_SDK&quot;, :git =&gt; &quot;https://github.com/sinaweibosdk/weibo_ios_sdk.git&quot;</code> (未实际测试过).</p><p>b. 添加系统依赖<code>QuartzCore.framework</code>、<code>SystemConfiguration.framework</code>、<code>ImageIO.framework</code>、<code>CoreGraphic.framework</code>、<code>Security.framework</code>、<code>libsqilte3.0.tbd</code>、<code>CoreTelephony.framework</code>、<code>CoreText.framework</code>、<code>libz.tbd</code>.c. 设置 <strong>The Other Flags</strong> 为 <strong>-ObjC</strong>.d. 在 <code>info.plist</code> 文件的 <code>CFBundleURLTypes</code> 中添加:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;CFBundleURLSchemes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;string&gt;wbYOURAPPKEY&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure></p><p>e.对传输安全的支持, 在当下的 iOS 系统中，默认需要为每次网络传输建立 <strong>SSL</strong>, 所以需在 plist 中设置 <strong>NSAppTransportSecurity 的 NSAllowsArbitraryLoads</strong> 为 <strong>YES</strong>.</p><p>f. 解除原有 <strong>ATS</strong>设置在 iOS 10+ 的网络限制:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;sina.com.cn&lt;/key&gt;</span><br><span class="line">  &lt;dict&gt;</span><br><span class="line">  &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;</span><br><span class="line">  &lt;<span class="literal">true</span>/&gt;</span><br><span class="line">  &lt;key&gt;NSThirdPartyExceptionAllowsInsecureHTTPLoads&lt;/key&gt;</span><br><span class="line">  &lt;<span class="literal">true</span>/&gt;</span><br><span class="line">  &lt;key&gt;NSExceptionMinimumTLSVersion&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;TLSv1.0&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;NSThirdPartyExceptionRequiresForwardSecrecy&lt;/key&gt;</span><br><span class="line">  &lt;<span class="literal">false</span>/&gt;</span><br><span class="line">  &lt;/dict&gt;</span><br></pre></td></tr></table></figure></p><p>g. 添加以下至白名单:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;sinaweibohd&lt;/string&gt;</span><br><span class="line">&lt;string&gt;sinaweibo&lt;/string&gt;</span><br><span class="line">&lt;string&gt;weibosdk&lt;/string&gt;</span><br><span class="line">&lt;string&gt;weibosdk2.5&lt;/string&gt;</span><br></pre></td></tr></table></figure></p><p>h. Swift 语言集成需要 <strong>Objective-C - Swift 桥接文件</strong>.</p><h4>接口调用及内部实现</h4><p><strong>a. 初始化 SDK</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RSinaWeiboManager shared] sdkInitializeByAppKey:YourAppKey appSecret:YourAppSecret];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RSinaWeiboManager</span>.shared.sdkInitialize(appKey: <span class="type">YourAppKey</span>, appSecret: <span class="type">YourAppSecret</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p>仅做<em>分享</em>的话, <code>secret</code> 字段无用.</p></blockquote><p><strong>b. 分享</strong></p><p>对于分享内容的包装新浪处理的比 QQ 简练, 所以无需借助新的类去处理分享内容, 文字是最简单的, 不需要对文字内容进行二次包装, 直接对 <code>WBMessageObject</code> 进行文字设置然后发送分享请求即可;</p><p>图片和视频(包括到「微博故事」)的分享需要 <code>WBImageObject</code> 和 <code>WBNewVideoObject</code> 的包装, 执行 <code>addImages</code> 和 <code>addVideo</code> 方法将要分享的图片/视频处理, 在此需要注意的是:<strong>实例化 <code>WBImageObject</code> 和 <code>WBNewVideoObject</code> 的时候必须设置 delegate, 并实现 <code>WBMediaTransferProtocol</code> 协议, 由于 <code>addImages</code> 和 <code>addVideo</code> 是异步操作, 所以 <code>wbsdk_TransferDidReceiveObject</code> 回调中发送分享请求!</strong></p><p>另, 经测试, 在参数准备失败的回调函数 <code>wbsdk_TransferDidFailWithErrorCode</code> 中, 出现的错误场景总结:</p><blockquote><ul><li>图片、视频体积过大;</li><li>图片数量不在 1 ~ 9 范围内;</li><li>倘若分享到「微博故事」, 照片只能分享一张, 而传了多张图片;</li><li><code>WBImageObject</code> 多参数并存: 单张的 Data 格式的图片和图片数组共存;</li><li>视频 URL 错误.</li></ul></blockquote><p><strong>文字分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RSinaWeiboManager shared] shareText: text completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RSinaWeiboManager</span>.shared.share(text: text, completion: completion)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-n6JtHRllWwQ/W4YK1a9xZbI/AAAAAAAAARc/xhiZef6skBUY_sr9V3zvuH08c1Ot0YXbQCHMYCw/I/15355112516411.jpg" alt=""></p><p><strong>图片分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RSinaWeiboManager shared] shareImage:images text: text toStory: yesOrNo completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RSinaWeiboManager</span>.shared.share(images: images, text: text, isToStory: trueOrFalse, completion: completion)</span><br></pre></td></tr></table></figure></p><p>为统一接口, 图片用数组包装; 分享到「微博故事」功能中 <code>text</code> 字段会失效.</p><blockquote><p>⚠️ 1. 开启「分享到微博故事」功能图片只能传一张; 多张图片分享的情况下「分享到微博故事」的功能必须关闭!⚠️ 2. 图片单张不能超过 10 MB, 最多 9 张图片.</p></blockquote><p>表现:分享到微博:<img src="https://lh3.googleusercontent.com/-aCBLxWXifUA/W4YLXeo0OTI/AAAAAAAAARo/VdzbwYQwydAv6EG66DgaWTF2CPiN_QY0ACHMYCw/I/15355113873506.jpg" alt=""></p><p>分享到「微博故事」:</p><p><img src="https://lh3.googleusercontent.com/-I6gUuJZj1Ag/W4YK_2MRjaI/AAAAAAAAARg/9zJxYQknfxU8XpeNTVTrXRThKui_65cMACHMYCw/I/15355112934927.jpg" alt=""></p><p><strong>本地视频分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RSinaWeiboManager shared] shareVideoWithLocalURL:videoFileURL text:text toStory:YesOrNo completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RSinaWeiboManager</span>.shared.share(localVideoURL: videoFileURL, text: text, isToStory: trueOrFalse, completion: completion)</span><br></pre></td></tr></table></figure></p><p>分享到「微博故事」功能中 <code>text</code> 字段会失效.</p><blockquote><p>⚠️ 本地视频 URL 为通过 <code>UIImagePickerController</code> 选择的媒体 <strong>info</strong> 的 <code>UIImagePickerControllerMediaURL</code> 的值,<strong>形如: file:///private/var/mobile/Containers/Data/Application/3B368706-001D-4018-901B-284D64FA50E2/tmp/17BD98B4-A498-46E7-9715-6F39E73DFD75.MOV</strong></p></blockquote><p>表现:分享到微博:<img src="https://lh3.googleusercontent.com/-hotp8LeIirg/W4YNSYqE6pI/AAAAAAAAASA/azcKxSHX3_4OHh29cLjtEK_IbAzlOMvaQCHMYCw/I/15355118787181.jpg" alt=""></p><p>分享到「微博故事」:<img src="https://lh3.googleusercontent.com/-WmJCSwfIlD0/W4YNAsLSyCI/AAAAAAAAAR4/YrO0ceKCmAoZZF6NV_tJ5iAiKwvftfJAQCHMYCw/I/15355118081232.jpg" alt=""></p><p><strong>网页分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RSinaWeiboManager shared] shareWebpageWithURL: webpageURL objectID: <span class="string">@"id"</span> title: title description: description thumbImage:thumbImage completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RSinaWeiboManager</span>.shared.share(webpageURL: webpageURL, objectID: <span class="string">"id"</span>, title: title, description: description, thumbImage: thumbImage, completion: completion)</span><br></pre></td></tr></table></figure></p><p><code>objectID</code> 字段用于表示一个多媒体内容; 网页的消息体设置无需设置 <strong>delegate</strong>, 因为不涉及异步操作, 而且 <code>thumbImage</code> 字段应该是失效的, 即不显示缩略图.</p><blockquote><p>⚠️ 1. 网页 <code>thumbImage</code> 字段的缩略图数据不能大于 32 Kb <strong>(新浪的 SDK 控制的很严格)</strong>.⚠️ 2. <code>WBWebpageObject</code> 的 <code>description</code> 设置无效, 想要显示网页的相关描述, 只能设置 <code>WBMessageObject</code> 的 <code>text</code> 字段.</p></blockquote><p>表现:<img src="https://lh3.googleusercontent.com/-fjHloKNsXbw/W4YNme4qZXI/AAAAAAAAASE/rWh2Yf5V20IRCPqeTd5pmPmQuFUJlew8wCHMYCw/I/15355119596149.jpg" alt=""></p><p><strong>c. 返回本应用</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RSinaWeiboManager shared] application:app openURL:url options:options];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RSinaWeiboManager</span>.application(app, <span class="keyword">open</span>: url, options : options)</span><br></pre></td></tr></table></figure></p><h3>Facebook</h3><h4>准备</h4><p>分享需要注册平台, <a href="https://developers.facebook.com/" target="_blank" rel="noopener">Facebook 开发者主页</a>, Facebook SDK <strong>支持 pod 集成</strong>, <a href="https://developers.facebook.com/docs/sharing/ios" target="_blank" rel="noopener">分享接口调用说明</a>.</p><h4>集成</h4><p>a. pod 集成: <code>pod 'FBSDKLoginKit'</code>b. 在<code>info.plist</code>文件的<code>CFBundleURLTypes</code>中添加:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;CFBundleURLSchemes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;string&gt;fbYOURAPPID&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;key&gt;FacebookAppID&lt;/key&gt;</span><br><span class="line">&lt;string&gt;YOURAPPID&lt;/string&gt;</span><br><span class="line">&lt;key&gt;FacebookDisplayName&lt;/key&gt;</span><br><span class="line">&lt;string&gt;SOMENAME&lt;/string&gt;</span><br></pre></td></tr></table></figure></p><p>c. 添加以下至白名单:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;fbapi&lt;/string&gt;</span><br><span class="line">&lt;string&gt;fb-messenger-share-api&lt;/string&gt;</span><br><span class="line">&lt;string&gt;fbauth2&lt;/string&gt;</span><br><span class="line">&lt;string&gt;fbshareextension&lt;/string&gt;</span><br></pre></td></tr></table></figure></p><p>d. Swift 语言集成需要 <strong>Objective-C - Swift 桥接文件</strong>.</p><h4>接口调用及内部实现</h4><p><strong>a. 初始化 SDK</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RFacebookManager shared] sdkInitializeByID:appID secret:secret];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RFacebookManager</span>.shared.sdkInitialize(appID: appID, secret: secret)</span><br></pre></td></tr></table></figure></p><blockquote><p>仅做<em>分享</em>功能的话, <code>secret</code> 字段无用.</p></blockquote><p><strong>b. 分享</strong>参数的包装, 借助工具类 <code>RFacebookHelper</code> 来处理, Facebook 已经封装好了各个类型的分享内容载体 (FBSDKSharePhotoContent、FBSDKShareVideoContent ...), 对应设置属性值就可以; 对于图片的分享, 和新浪的图片分享思路相同, 即: 无论是单张还是多图, 一概通过数组包装传递给 <code>RFacebookHelper</code>, 然后它自行处理.</p><p><strong>网页分享:</strong>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[RFacebookManager shared] shareWebpageWithURL: webpageURL</span><br><span class="line">                           quote: quote</span><br><span class="line">                         hashTag: hashTag</span><br><span class="line">                            from: context</span><br><span class="line">                            mode: mode</span><br><span class="line">                      completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RFacebookManager</span>.shared.share(webpageURL: webpageURL, quote: quote, hashTag: hashTag, from: context, mode: mode, completion: completion)</span><br></pre></td></tr></table></figure></p><p>Facebook 的 SDK 在迭代的过程中, 舍弃了很多字段, 分享参数不如新浪那样多样, 但是其分享的表现形式却比国内的要友好很多, 特别是在网页分享这块体现的更加明显, 值得注意的是, <strong>非网页形式的分享回调无效</strong>, 努力地在 <strong>Github</strong>、<strong>Stack Overflow</strong> 和 <strong>Facebook Developer 论坛</strong>找答案但都没有找到解决办法, 根据 <code>postId</code> 的判断分享结果状态的方法早已失效, 无论是 Android 还是 iOS 端, 目前都没办法.</p><blockquote><p>⚠️ <code>hashTag (话题)</code> 的表现形式不同于国内, 新浪的话题格式: <strong>#话题#</strong>, 两个 <strong>#</strong> 之间一切内容都能成为话题, 而 Twitter、Instagram、Facebook 的格式: <strong>#话题</strong>, 话题内容词组之间不能有任何符号且必须连在一起.</p></blockquote><p>表现:客户端形式的分享(无回调):<img src="https://lh3.googleusercontent.com/-9s9itZnYAGU/W4YO10hlHrI/AAAAAAAAASU/4QsiueemIrYkysCjjj2SA-OozJlDHPBFwCHMYCw/I/15355122765780.jpg" alt=""></p><p>由上图可见, 在通过客户端分享的过程中, <code>quote</code> 字段已经丢失, <strong>Android 表现不同, <code>quote</code> 保留, 其次, iOS 是跳转到 Facebook 客户端分享, Android 是在本应用内弹出对话框分享, 且 Android 通过客户端分享需要提前打开 Facebook 客户端, 否则无法弹出分享对话框, 测试过美图秀秀的图片分享, 也是一样, 需要提前打开客户端.</strong></p><p>网页形式的分享(有回调):<img src="https://lh3.googleusercontent.com/-7IgEDiuEqLY/W4YOSe_rlUI/AAAAAAAAASI/CfX0IhaYObU9cokYviBpS_0OsL6BP6WEgCHMYCw/I/15355121341100.jpg" alt=""></p><p><strong>图片分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[RFacebookManager shared] sharePhotos: targetImageArray</span><br><span class="line">                    from:context</span><br><span class="line">              completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RFacebookManager</span>.shared.share(photos: targetImageArray, from: context, completion: completion)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 1. 照片大小必须小于 12MB.⚠️ 2. 用户需要安装版本 7.0 或以上的原生 iOS 版 Facebook 应用.</p></blockquote><p>表现:<img src="https://lh3.googleusercontent.com/-7s5lsBjmdsA/W4YPBKPBeeI/AAAAAAAAASY/uMC9yyi8N88rH6NOWUh8zNFw-FFk8e30gCHMYCw/I/15355123174456.jpg" alt=""></p><p><strong>本地视频分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RFacebookManager shared] shareVideoWithLocalURL: videoURL from: context];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RFacebookManager</span>.shared.share(localVideoURL: videoURL, from: context)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️  本地视频 URL 为通过 <code>UIImagePickerController</code> 选择的媒体 <strong>info</strong> 的 <code>UIImagePickerControllerReferenceURL</code> 的值, <strong>形如: assets-library://asset/asset.MP4?id=8FF2F03F-DD84-41A5-A20C-B745E793C0DC&amp;ext=MP4</strong></p></blockquote><p>倘若通过 Facebook 的 SDK <strong>自行</strong>构建本地视频分享模型, 需注意 iOS 11 前后的模型属性设置不同:Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)imagePickerController:(<span class="built_in">UIImagePickerController</span> *)picker</span><br><span class="line">didFinishPickingMediaWithInfo:(<span class="built_in">NSDictionary</span> *)info</span><br><span class="line">&#123;</span><br><span class="line">  FBSDKShareVideo *video = [[FBSDKShareVideo alloc] init];</span><br><span class="line">  <span class="keyword">if</span> (@available(iOS <span class="number">11</span>, *)) &#123;</span><br><span class="line">    video.videoAsset = [info objectForKey:<span class="built_in">UIImagePickerControllerPHAsset</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    video.videoURL = [info objectForKey:<span class="built_in">UIImagePickerControllerReferenceURL</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any])</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> video = <span class="type">FBSDKShareVideo</span>()</span><br><span class="line">    <span class="keyword">if</span> #available(iOS <span class="number">11</span>, *) &#123;</span><br><span class="line">        video.videoAsset = info[<span class="type">UIImagePickerControllerPHAsset</span>]     </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        video.videoURL = info[<span class="type">UIImagePickerControllerReferenceURL</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了统一使用 URL 分享本地视频, 所以笔者并没有考虑使用上述的写法.</p><p>表现:<img src="https://lh3.googleusercontent.com/-nqS8NqcuAWA/W4YPhs9jfPI/AAAAAAAAASk/L7tpwjijq8Q1KKY_mbgd1HVRYm24BGNXgCHMYCw/I/15355124530548.jpg" alt=""></p><p><strong>C. 返回本应用</strong></p><p>Objective-C：</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RFacebookManager shared]application:app openURL:url options:options];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RFacebookManager</span>.application(app, <span class="keyword">open</span>: url, options : options)</span><br></pre></td></tr></table></figure></p><p><strong>d. 其他设置</strong></p><p>在完成 Facebook 登录、分享等操作的时候还需要连接本应用的 <code>AppDelegate</code> , 故在 <code>didFinishLaunchingWithOptions</code> 函数中添加:</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RFacebookManager shared] application:application didFinishLaunchingWithOptions:launchOptions];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RFacebookManager</span>.shared.application(application, didFinishLaunchingWithOptions: launchOptions)</span><br></pre></td></tr></table></figure></p><p>当需要记录有多少用户激活的时候需要在 <code>applicationDidBecomeActive</code> 方法中添加:</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RFacebookManager shared]applicationDidBecomeActive:application];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RFacebookManager</span>.shared.applicationDidBecomeActive(application)</span><br></pre></td></tr></table></figure></p><h3>Twitter</h3><h4>准备</h4><p>分享需要注册平台, <a href="https://developer.twitter.com/content/developer-twitter/en.html" target="_blank" rel="noopener">Twitter 开发者主页</a>, <a href="https://apps.twitter.com/" target="_blank" rel="noopener">注册应用主页</a>, Twitter SDK <strong>支持 pod 集成</strong>, <a href="https://github.com/twitter/twitter-kit-ios/wiki/Compose-Tweets" target="_blank" rel="noopener">分享接口调用说明</a>.</p><p><strong>⚠️: Twitter SDK 将于 2018/10/31 后不再进行维护, 但是不影响后续使用, 需自行维护, <a href="https://blog.twitter.com/developer/en_us/topics/tools/2018/discontinuing-support-for-twitter-kit-sdk.html" target="_blank" rel="noopener">Twitter 产品经理 Neil Shah 对 Twitter SDK 放弃维护迭代的声明博客</a>.</strong></p><h4>集成</h4><p>a. pod 集成: <code>pod 'TwitterKit'</code>b. 在 <code>info.plist</code> 文件的<code>CFBundleURLTypes</code>中添加:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;CFBundleURLSchemes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;string&gt;twitterkit-YOURCONSUMERKEY&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure></p><p>c. 添加以下至白名单:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;twitter&lt;/string&gt;</span><br><span class="line">&lt;string&gt;twitterauth&lt;/string&gt;</span><br></pre></td></tr></table></figure></p><p>d. Swift 语言集成需要 <strong>Objective-C - Swift 桥接文件</strong>.</p><h4>接口调用及内部实现</h4><p><strong>a. 初始化 SDK</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RTwitterManager shared] sdkInitializeByConsumerKey:yourConsumerKey consumerSecret:yourConsumerSecret];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RTwitterManager</span>.shared.sdkInitialize(consumerKey: consumerKey, consumerSecret: secret)</span><br></pre></td></tr></table></figure></p><blockquote><p>仅做<em>分享</em>的话, <code>secret</code> 字段无用.</p></blockquote><p><strong>b. 授权 Twitter 客户端</strong>与其他平台分享不同的是, Twitter 在进行发推(分享)的时候会先进行检测本地的 <code>SessionStore</code> 的标记判断是否登录(授权)过, 所以在进行发推的时候需要进行这一步的判断, 在未登录的情况下需进行授权, 在此使用 <code>RTwitterAuthHelper</code> 进行处理, 登录(授权回调):</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^auth)(RTWAuthState state, <span class="built_in">NSString</span>* _Nullable errorInfo);</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">RTWAuthCompletion</span> = (<span class="number">_</span> state : <span class="type">RTWAuthState</span>,<span class="number">_</span> errorInfo : <span class="type">String</span>?) -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure></p><p><code>state</code> 包括成功和失败两种结果.</p><p><strong>判断是否登录过:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> flag = [[RTwitterAuthHepler shared] hasLogged];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="number">_</span> = <span class="type">RTwitterAuthHepler</span>.shared.hasLogged</span><br></pre></td></tr></table></figure></p><p><strong>登录授权:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[RTwitterAuthHelper shared]authorizeTwitter:^(RTWAuthState state, <span class="built_in">NSString</span> * _Nullable errorInfo) &#123;</span><br><span class="line">    <span class="comment">// some code ...</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RTwitterAuthHepler</span>.shared.authorizeTwitter &#123; (state, errorInfo) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// some code ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这一步<strong>目前的情况就是把 Twitter SDK 提供的授权方法重新包装写了遍, 但是考虑到未来可能用到 <code>session</code> 和 <code>token</code> 等信息并处理, 所以单独写了类讲授权和分享隔离.</strong></p><p><strong>返回本应用:</strong></p><p>Twitter 分享是不需要进行程序跳转的, 只有在登录授权的时候才会需要下述方法, 所以当你成功授权了以后卸载掉 Twitter 的客户端依然可以进行分享.</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RTwitterManager shared] application:app openURL:url options:options];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RTwitterManager</span>.application(app, <span class="keyword">open</span>: url, options : options)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ Twitter 最新 SDK 要求项目的  <code>Deloyment Target</code> 至少为 <strong>9.0</strong>.</p></blockquote><p><strong>c. 分享</strong></p><p>在本人写的 demo 中, <em>分享</em>和<em>登录授权</em>是衔接的, 即: 若未登录过 -&gt; 登录授权 -&gt; 分享.另, Twitter 能分享的内容相对较少, 所以关于<strong>文字、网页、图片</strong>的分享, 统一到一个分享接口里, 三者不能同时为空.</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RTwitterManager shared]shareWithWebpageURL: webpageURL text: text image: image from: context completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RTwitterManager</span>.shared.share(webpageURL: webpageURL, text: text, image: image, from: context, completion: completion)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-nMmPYSlGflE/W4YQCh8Ae0I/AAAAAAAAASw/unxfmpNFv-UaHYRwEQew8ov00nyOGmNIACHMYCw/I/15355125823965.jpg" alt=""></p><p>Twitter 分享是在本应用内弹出分享框进行分享.</p><h3>Instagram</h3><h4>准备</h4><p>分享无需注册平台无需 SDK, <a href="https://www.instagram.com/developer/" target="_blank" rel="noopener">Instagram 开发者主页</a>, <a href="https://www.instagram.com/developer/mobile-sharing/iphone-hooks/" target="_blank" rel="noopener">Custom URL Scheme 方式分享</a>.</p><h4>配置</h4><p>在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">添加以下至白名单:</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">&lt;string&gt;instagram&lt;/string&gt;</span><br></pre></td></tr></table></figure></p><h4>接口调用及内部实现</h4><p><strong>分享</strong></p><p>无论照片还是视频都是通过 <strong>Custom URL Scheme</strong> 来打开 Instagram 客户端, 但 demo 中实际的方法和 <a href="https://www.instagram.com/developer/mobile-sharing/iphone-hooks/" target="_blank" rel="noopener">Instagram 提供的 Custom URL</a>不同.</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSURL</span>* instagramLibraryURL() &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"instagram://library?AssetPath=%@"</span>, <span class="string">@""</span>];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> URLWithString:str];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">let</span> instagramURL = <span class="type">URL</span>(string: <span class="type">String</span>(format: <span class="string">"instagram://library?AssetPath=%@"</span>, <span class="string">""</span> <span class="keyword">as</span> <span class="type">CVarArg</span>))</span><br></pre></td></tr></table></figure></p><p>分享流程是<strong>先保存</strong>照片/视频再分享.保存照片:</p><p>Objective-C</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="keyword">self</span>, <span class="keyword">@selector</span>(image:didFinishSavingWithError:contextInfo:), (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>);</span><br></pre></td></tr></table></figure></p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)image:(<span class="built_in">UIImage</span> *)image didFinishSavingWithError:(<span class="built_in">NSError</span> *)error contextInfo:(<span class="keyword">void</span> *)contextInfo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:instagramLibraryURL()]) &#123;</span><br><span class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] openURL:instagramLibraryURL()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UISaveVideoAtPathToSavedPhotosAlbum</span>(localVideoURL.path, <span class="keyword">self</span>, #selector(video(path:didFinishSavingWithError:contextInfo:)), <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span><span class="params">(image: UIImage!, didFinishSavingWithError error: NSError!, contextInfo: AnyObject!)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">UIApplication</span>.shared.canOpenURL(instagramURL!) &#123;</span><br><span class="line">            <span class="type">UIApplication</span>.shared.openURL(instagramURL!)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存视频:</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UISaveVideoAtPathToSavedPhotosAlbum</span>(localeVideoURL.path, <span class="keyword">self</span>, <span class="keyword">@selector</span>(video:didFinishSavingWithError:contextInfo:), <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure></p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)video:(<span class="built_in">NSString</span> *)path didFinishSavingWithError:(<span class="built_in">NSError</span> *)error contextInfo:(<span class="keyword">void</span> *)contextInfo &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:instagramLibraryURL()]) &#123;</span><br><span class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] openURL:instagramLibraryURL()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UISaveVideoAtPathToSavedPhotosAlbum</span>(localVideoURL.path, <span class="keyword">self</span>, #selector(video(path:didFinishSavingWithError:contextInfo:)), <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">video</span><span class="params">(path: String!, didFinishSavingWithError error: NSError!, contextInfo: AnyObject!)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">UIApplication</span>.shared.canOpenURL(instagramURL!) &#123;</span><br><span class="line">        <span class="type">UIApplication</span>.shared.openURL(instagramURL!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>分享图片:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RInstagramManager shared] share: targetImage];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RInstagramManager</span>.shared.share(image: targetImage)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-KOdrkJJWdhg/W4YQMFwhXgI/AAAAAAAAAS0/PP0Jd2caT6IONmtn2T_ejcUbESMGJw6OgCHMYCw/I/15355126186609.jpg" alt=""></p><p><strong>分享本地视频:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RInstagramManager shared]shareVideoWithLocalURL: videoURL description: description]</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RInstagramManager</span>.shared.share(localVideoURL: videoFileURL!, description: description)</span><br></pre></td></tr></table></figure></p><p><code>description</code> 字段在实际传递过程中是失效的.</p><blockquote><p>⚠️ 本地视频 URL 为通过 <code>UIImagePickerController</code> 选择的媒体 <strong>info</strong> 的 <code>UIImagePickerControllerMediaURL</code> 的值,<strong>形如: file:///private/var/mobile/Containers/Data/Application/3B368706-001D-4018-901B-284D64FA50E2/tmp/17BD98B4-A498-46E7-9715-6F39E73DFD75.MOV</strong></p></blockquote><p>表现:<img src="https://lh3.googleusercontent.com/-adPs5mfSxuU/W4ZKVbqhdWI/AAAAAAAAAUU/7dYZkYK_zJ4wYF4vc1Mnt2bSPiMOmb1CgCHMYCw/I/15355275057159.jpg" alt=""></p><h3>Tumblr</h3><h4>准备</h4><p>分享需要注册平台, <a href="https://www.tumblr.com/developers" target="_blank" rel="noopener">Tumblr 开发者主页</a>, <a href="https://dev.flurry.com/admin/applications" target="_blank" rel="noopener">注册应用主页</a>, Tumblr SDK <strong>支持 pod 集成</strong>, <a href="https://developer.yahoo.com/flurry/docs/tumblrsharing/iOS/" target="_blank" rel="noopener">分享接口调用说明</a>.</p><h4>集成</h4><p>a. pod 集成: <code>pod 'Flurry-iOS-SDK/TumblrAPI'</code>⚠️: 一定是这个, 最新版本的 SDK 我没有找到分享的接口.</p><p>b. Swift 语言集成需要 <strong>Objective-C - Swift 桥接文件</strong>.</p><h4>接口调用及内部实现</h4><p><strong>a. 初始化 SDK</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RTumblrManager shared] sdkInitializeByConsumerKey:yourConsumerKey consumerSecret: yourConsumerSecret];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RTumblrManager</span>.shared.sdkInitialize(consumerKey: yourConsumerKey, consumerSecret: yourConsumerSecret)</span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 在 iOS 端初始化 SDK 需要 <code>consumerKey</code> 和 <code>consumerSecret</code> 两个参数, Android 端还需要 <code>flurryKey</code> 这个参数才能完成分享.</p></blockquote><p><strong>b. 分享</strong></p><p>Tumblr 分享体只包括<strong>图片</strong>和<strong>文字</strong>两种, 并且图片还是网络图片的链接, 并不能分享本地图片, 所以 Tumblr 的局限性很大, 这两种分享体的模型通过 SDK 中 <code>FlurryImageShareParameters</code> 和 <code>FlurryTextShareParameters</code> 来构建;Tumblr 分享是通过当前界面弹出对话框分享的, 和 Twitter 类似, 所以不需要判断 Tumblr 程序是否安装;Tumblr 的分享流程是: <strong>登录 -&gt; 分享</strong>, 但是登录的逻辑不需要在代码中实现, 他会自动呈现浏览器的登录界面.</p><p><strong>文字分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RTumblrManager shared] shareText: text title: title webpageURL: webpageURL from: context completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RTumblrManager</span>.shared.share(text: text, title: title, webpageURL: webpageURL, from: context, completion: completion)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-rxIzydhFUx8/W4YQj8-tj-I/AAAAAAAAAS8/D0aXCfI4dnEZ5kQhMSuaPgpJN7ZXgZ-JQCHMYCw/I/15355127160288.jpg" alt=""></p><p><strong>图片链接分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RTumblrManager shared] shareImageWithURL: targetImageURL description: description webpageURL: webpageURL from: context completion: completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RTumblrManager</span>.shared.share(imageURL: targetImageURL, description: description, webpageURL: webpageURL, from: context, completion: completion)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-D28ugrWNaAo/W4YQndOmnhI/AAAAAAAAATI/Ld5F_uF6_Oor4qbfVrlljAuZs3pV8q0EACHMYCw/I/15355127308166.jpg" alt=""></p><h3>Pinterest</h3><h4>准备</h4><p>分享需要注册平台, <a href="https://developers.pinterest.com/" target="_blank" rel="noopener">Pinterest 开发者主页</a>, <a href="https://developers.pinterest.com/apps/" target="_blank" rel="noopener">注册应用主页</a>, Pinterest SDK <strong>支持 pod 集成</strong>, <a href="https://developers.pinterest.com/docs/sdks/ios/" target="_blank" rel="noopener">接口调用说明</a>.</p><h4>集成</h4><p>a. pod 集成: <code>pod “PinterestSDK”, :git =&gt; “git@github.com:pinterest/ios-pdk.git”</code></p><p>d. 在 <code>info.plist</code> 文件的 <code>CFBundleURLTypes</code> 中添加:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;CFBundleURLTypes&lt;/key&gt;</span><br><span class="line">  &lt;array&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">      &lt;key&gt;CFBundleURLName&lt;/key&gt;</span><br><span class="line">      &lt;string&gt;&lt;/string&gt;</span><br><span class="line">      &lt;key&gt;CFBundleURLSchemes&lt;/key&gt;</span><br><span class="line">      &lt;array&gt;</span><br><span class="line">        &lt;string&gt;pdkYOURAPPID&lt;/string&gt;</span><br><span class="line">      &lt;/array&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">  &lt;/array&gt;</span><br></pre></td></tr></table></figure></p><p>e. 添加以下至白名单:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;pinterestsdk.v1&lt;/string&gt;</span><br></pre></td></tr></table></figure></p><p>b. Swift 语言集成需要 <strong>Objective-C - Swift 桥接文件</strong>.</p><h4>接口调用及内部实现</h4><p><strong>a. 初始化 SDK</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RPinterestManager shared] sdkInitializeByAppID: yourAppID appSecret:yourAppSecret];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RPinterestManager</span>.shared.sdkInitialize(appID: yourAppID, appSecret: yourAppSecret)</span><br></pre></td></tr></table></figure></p><blockquote><p>仅做<em>分享</em>功能的话, <code>secret</code> 字段无用.</p></blockquote><p><strong>b. 分享</strong></p><p><strong>⚠️: Pinterest 分享要求项目的 CFBundleDisplayName 一定不能为空!!!</strong></p><p><strong>图片链接分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RPinterestManager shared] shareImageWithURL: targetImageURL webpageURL: webpageURL onBoard:boardName description: description  from: context completion:completion];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RPinterestManager</span>.shared.share(imageURL: targetImageURL, webpageURL: webpageURL, boardName: boardName, description: description, from: context, completion: completion)</span><br></pre></td></tr></table></figure></p><p><code>boardName</code> 字段即使随便设置也不影响, 考虑到有可能对 Pinterest 功能细化的时候会用到这个字段就保留下来了.</p><p>表现:<img src="https://lh3.googleusercontent.com/-Zl6L5gyovmg/W4YQzHlhROI/AAAAAAAAATM/k-eeicQBCHEeKkR_JqaBey6tYVUe7M5TQCHMYCw/I/15355127771748.jpg" alt=""></p><p><strong>c. 返回本应用</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RPinterestManager shared] application:app openURL:url options:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RPinterestManager</span>.application(app, <span class="keyword">open</span>: url, options : options)</span><br></pre></td></tr></table></figure></p><h3>Line</h3><h4>准备</h4><p>分享无需注册平台.</p><h4>配置</h4><p>在<code>info.plist</code>文件中:添加以下至白名单:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;line&lt;/string&gt;</span><br></pre></td></tr></table></figure></p><h4>接口调用及内部实现</h4><p><strong>分享</strong></p><p>Line 分享是通过 <strong>Custom URL Scheme</strong> 来打开 Line 客户端进行分享, 但 demo 中实际的方法和 <a href="https://developers.line.me/en/docs/messaging-api/using-line-url-scheme/" target="_blank" rel="noopener">Line 提供的 Custom URL</a>.</p><p>文本分享的 URL 为 <code>line://msg/text/?targetText</code>, 要对 <code>targetText</code> 中的<strong>中文、特殊字符等</strong>进行处理:</p><p>Object-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[targetText stringByAddingPercentEncodingWithAllowedCharacters:[<span class="built_in">NSCharacterSet</span> URLQueryAllowedCharacterSet]];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetText.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)</span><br></pre></td></tr></table></figure></p><p>图片分享的 URL 为 <code>line://msg/image/</code>, URL 后面的部分可通过 UIPasteboard 实例的 <code>name</code> 属性拼接:</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIPasteboard</span>* p = [<span class="built_in">UIPasteboard</span> generalPasteboard];</span><br><span class="line">[p setData:(<span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">1</span>)) forPasteboardType:<span class="string">@"public.jpeg"</span>];</span><br><span class="line"><span class="built_in">NSURL</span>* lineURL = [<span class="built_in">NSURL</span> URLWithString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"line://msg/image/%@"</span>,p.name]];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="type">UIPasteboard</span>.general</span><br><span class="line">p.setData(<span class="type">UIImageJPEGRepresentation</span>(image, <span class="number">0.1</span>)!, forPasteboardType:<span class="string">"public.jpeg"</span>)</span><br><span class="line"><span class="keyword">let</span> lineURL = <span class="type">URL</span>(string: <span class="type">String</span>(format: lineURLPrefix + <span class="string">"line://msg/image/%@"</span>, p.name <span class="keyword">as</span> <span class="type">CVarArg</span>))</span><br></pre></td></tr></table></figure></p><p><strong>文字分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RLineManager shared] shareText: text];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLineManager</span>.shared.share(text: text)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-Of4c5pwNEgk/W4YQ9tIGYLI/AAAAAAAAATQ/0_jYP-ZUPngqxOTY1_yzdZ-tJCr5yMLIgCHMYCw/I/15355128195870.jpg" alt=""></p><p><strong>图片分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RLineManager shared] shareImage: targetImage];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLineManager</span>.shared.share(image: targetImage)</span><br></pre></td></tr></table></figure></p><p>表现:</p><p><img src="https://lh3.googleusercontent.com/-vQoxgTyCGw8/W4YRA72WbLI/AAAAAAAAATU/WOc97RD-b-8aZoqVTIDYdt_F4DDioa85gCHMYCw/I/15355128334097.jpg" alt=""></p><h3>WhatsApp</h3><h4>准备</h4><p>分享无需注册平台.</p><h4>配置</h4><p>在<code>info.plist</code>文件中:添加以下至白名单:</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;whatsapp&lt;/string</span><br></pre></td></tr></table></figure></p><h4>接口调用及内部实现</h4><p><strong>分享</strong>通过 <strong>Custom URL Scheme</strong> 分享文字, 图片是通过 <code>UIDocumentInteractionController</code> 来实现应用间数据共享, 构建文字的 URL 为 <code>whatsapp://send?text=targetText</code></p><p><strong>文字分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RWhatsAppManager shared]shareText: text]</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWhatsAppManager.shared.share(text: text)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-xb2FYN3K0iU/W4YRR8B2ooI/AAAAAAAAATY/REtWJ6bOf3oIIpgCOqpIA4Y6S1uBM9ErgCHMYCw/I/15355129015872.jpg" alt=""></p><p><strong>图片分享:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RWhatsAppManager shared]shareImage: targetImage from: context];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RWhatsAppManager</span>.shared.share(image: targetImage , from: context)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-OyXKD3CaCjw/W4YRUpjYnJI/AAAAAAAAATc/bUSIY503n7QLm56sS6eNwboBpPY4NCIEgCHMYCw/I/15355129126452.jpg" alt=""></p><h3>GooglePlus</h3><h4>准备</h4><p>分享无需注册平台, <a href="https://developers.google.com/+/" target="_blank" rel="noopener">Google Plus 开发者主页</a>已经把 iOS 相关移除了.</p><h4>接口调用及内部实现</h4><p><strong>分享</strong>Google Plus 只支持通过 <strong>Custom URL Scheme</strong> 分享网页, 构建 URL 为 <code>https://plus.google.com/share</code></p><p>内部构建:</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLComponents</span>* urlComponents = [[<span class="built_in">NSURLComponents</span> alloc]</span><br><span class="line">                                      initWithString:<span class="string">@"https://plus.google.com/share"</span>];</span><br><span class="line">urlComponents.queryItems = @[[[<span class="built_in">NSURLQueryItem</span> alloc]</span><br><span class="line">                                  initWithName:<span class="string">@"url"</span></span><br><span class="line">                                  value:[shareURL absoluteString]]];</span><br><span class="line"><span class="built_in">NSURL</span>* url = [urlComponents URL];    </span><br><span class="line"><span class="keyword">if</span> ([SFSafariViewController <span class="keyword">class</span>]) &#123;</span><br><span class="line">    SFSafariViewController* controller = [[SFSafariViewController alloc] initWithURL:url];</span><br><span class="line">    controller.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [from presentViewController:controller animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> components = <span class="type">URLComponents</span>(string: <span class="string">"https://plus.google.com/share"</span>)</span><br><span class="line">components?.queryItems = [<span class="type">URLQueryItem</span>(name: <span class="string">"url"</span>, value: webpageURL.absoluteString)]</span><br><span class="line"><span class="keyword">let</span> url = components?.url</span><br><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">9</span>, *) &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = <span class="type">SFSafariViewController</span>(url: url!)</span><br><span class="line">    vc.delegate = <span class="keyword">self</span></span><br><span class="line">    from.present(vc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.openURL(url!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>网页分享:</strong>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RGooglePlusManager shared]shareURL:[<span class="built_in">NSURL</span> URLWithString: targetURL] from: context];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RGooglePlusManager</span>.shared.share(webpageURL: <span class="type">URL</span>(string: targetURL)!, from: context)</span><br></pre></td></tr></table></figure></p><p>表现:<img src="https://lh3.googleusercontent.com/-RBbwgH1Ny_U/W4YTC4ngt3I/AAAAAAAAAUI/TXhK8rrXdOE9_-tlzNqehW91DmqGW7eGwCHMYCw/I/15355133524598.jpg" alt=""></p><h2>统一分享接口</h2><h3>缺陷</h3><p><strong>缺陷说在前面, 其实本来不打算统一接口的.</strong></p><ul><li>假如只想分享某五个平台, 其余的六个平台仍然不可以删掉, 主分享 Manager 和子平台分享 Manager 存在耦和;</li><li>分享接口优化受限制, 由于前面的平台分享对比表格可知, 国外的平台分享很多都没有回调, 而国内的平台分享内容又存在多种形式, 无法实现高度统一;</li><li>添加平台没有做<strong>去重处理</strong>, 造成不必要的开销;</li><li>分享完毕返回到本应用的统一处理中子平台分享 Manager 和主分享 Manager 存在代码污染.</li></ul><h3>类图</h3><p><img src="https://lh3.googleusercontent.com/-qS7DNoxlpi0/W4YRwCQ7qhI/AAAAAAAAATw/2KMok4xcqTg-qLFtY9V9h9xV8ys8jf9sgCHMYCw/I/iOS%2B" alt="iOS 分享统一接口类图"></p><ul><li><strong>RShareManger:</strong> 主分享 Manager, 子平台 Manager 的初始化、分享、应用跳转和一些其他操作都在此进行;</li><li><strong>RPlatform:</strong> 主要进行应用是否安装、添加目标应用的操作;</li><li><strong>RRegister:</strong> 主要进行 <code>RShareManager</code> 和子平台分享 Manager 的 SDK 初始化衔接;</li><li><strong>RImageContent、RVideoContent、RTextContent、RWebpageContent</strong> 为四种对应分享内容模型.</li></ul><h3>详细设计</h3><p>**a. 平台添加 **</p><p>平台相关都交给 <code>RPlatform</code> 去处理, 平台的添加借鉴了 Java 中的 <strong>Builder 模式</strong>思路去处理, <code>RPlatform</code> 的成员属性 <code>targets</code> 在 Objective-C 中为:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;Class&gt;* targets;</span><br></pre></td></tr></table></figure></p><p>Swift 中为:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targets : <span class="type">Array</span>&lt;<span class="type">RShare</span>.<span class="type">Type</span>&gt; = [] <span class="comment">// 多态的体现</span></span><br></pre></td></tr></table></figure></p><p><code>add</code> 函数为添加平台的操作, 参数为平台枚举 <code>RShareSDKPlatform</code>, <code>RPlatform</code> 的私有成员属性 <code>info</code> 为字典类型, key 为平台的字符串形式,  value 平台类型 , 通过 <code>add</code> 操作的平台枚举去取出 <code>info</code> 中对应的平台类型添加到 <code>targets</code> 中.</p><p><strong>b. 分享频道</strong></p><p>以 Objective-C 为例, 在 <code>RShareManager</code> 定义了分享通道枚举:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RShareChannel) &#123;</span><br><span class="line">    RShareChannelQQSession, <span class="comment">// QQ 好友</span></span><br><span class="line">    RShareChannelQQFavorite, <span class="comment">// QQ 收藏</span></span><br><span class="line">    RShareChannelQQDataLine, <span class="comment">// QQ 我的电脑(数据传输)</span></span><br><span class="line">    RShareChannelQZone, <span class="comment">// QQ 空间</span></span><br><span class="line">    RShareChannelWechatSession, <span class="comment">// 微信好友</span></span><br><span class="line">    RShareChannelWechatFavorite, <span class="comment">// 微信收藏</span></span><br><span class="line">    RShareChannelWechatTimeline, <span class="comment">// 微信朋友圈</span></span><br><span class="line">    RShareChannelFacebookClient, <span class="comment">// Facebook 客户端</span></span><br><span class="line">    RShareChannelFacebookBroswer, <span class="comment">// Facebook Feed 形式网页</span></span><br><span class="line">    RShareChannelTwitter,<span class="comment">// 推特</span></span><br><span class="line">    RShareChannelSinaWeibo, <span class="comment">// 新浪微博</span></span><br><span class="line">    RShareChannelSinaWeiboStory, <span class="comment">// 新浪微博 - 我的故事</span></span><br><span class="line">    RShareChannelLine, <span class="comment">// Line</span></span><br><span class="line">    RShareChannelInstagram, <span class="comment">// Instagram</span></span><br><span class="line">    RShareChannelTumblr, <span class="comment">// Tumblr</span></span><br><span class="line">    RShareChannelPinterest, <span class="comment">// Pinterest</span></span><br><span class="line">    RShareChannelGooglePlus, <span class="comment">// GooglePlus</span></span><br><span class="line">    RShareChannelWhatsApp <span class="comment">// WhatsApp</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>c. 初始化以及注册平台</strong></p><p>由 ShareSDK iOS 版激发灵感进行构建.</p><p><code>RShareManager</code> 通过单例创建, 实例函数 <code>registerPlatforms:</code> 为注册实例化子平台 Manager 的过程, Objective-C 中通过 <code>runtime</code> 实现:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code snippet ...</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    Class cls = p.targets[i];</span><br><span class="line">    <span class="keyword">id</span> obj = objc_msgSend(objc_msgSend(cls, <span class="keyword">@selector</span>(alloc)), <span class="keyword">@selector</span>(init));</span><br><span class="line">    SEL sel = <span class="keyword">@selector</span>(connect:);</span><br><span class="line">    ((<span class="keyword">void</span>(*)(<span class="keyword">id</span>,SEL, RConfiguration))objc_msgSend)(obj, sel, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Swift 中暂时没找到类似的方法, 采用了原始的 <code>switch-case</code> 逐个判断并初始化.其中 <code>RConfiguration</code> 为:</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在 RShare.h 中</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^RConfiguration)(RShareSDKPlatform platform, RRegister* obj);</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在 RShareManager 中</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">RConfiguration</span> = (<span class="number">_</span> paltform : <span class="type">RShareSDKPlatform</span>,<span class="number">_</span> obj : <span class="type">RRegister</span>) -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure></p><p>每个子平台 Manager 都有 <code>connect</code> 函数, 参数是 <code>RConfiguration</code> 类型, 返回平台信息是因为不是所有的平台都需要初始化 SDK, 返回 <code>RRegister</code> 实例的目的是把实例化的工作交给 <code>RRegister</code> 去做.</p><p><code>RRegister</code> 内部逻辑很简单, 只有初始化三方平台 SDK 的工作.</p><p><strong>d. 返回本应用</strong></p><p>Objective-C 中通过 <code>runtime</code> 实现:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIApplicationOpenURLOptionsKey</span>,<span class="keyword">id</span>&gt; *)options &#123; </span><br><span class="line">    SEL sel = <span class="keyword">@selector</span>(application:openURL:options:);</span><br><span class="line">    <span class="keyword">id</span> obj = objc_msgSend(objc_msgSend(_cls, <span class="keyword">@selector</span>(alloc)), <span class="keyword">@selector</span>(init));</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">BOOL</span>(*)(<span class="keyword">id</span>,SEL,<span class="keyword">id</span>,<span class="keyword">id</span>,<span class="keyword">id</span>))objc_msgSend)(obj, sel, application,url,options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>_cls</code> 是在分享的时候通过分享接口中 <code>channel</code> 字段通过 <code>-(Class)getCls:(RShareChannel)channel</code> 确定, <code>objCls</code> 在 Swift 中通过同样的方法获得: <code>func getSubCls(channel : RShareChannel) -&gt; RShare.Type</code>.</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> app: UIApplication, <span class="keyword">open</span> url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> objCls.application(app, <span class="keyword">open</span>: url, options : options)     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>接口</h3><p><strong>添加平台及初始化需要注册的平台:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    RPlatform* p = [RPlatform make:^(PlatformBuilder *builder) &#123;</span><br><span class="line">        [builder add:RShareSDKPinterest];</span><br><span class="line">        [builder add:RShareSDKWhatsApp];</span><br><span class="line">        [builder add:RShareSDKWechat];</span><br><span class="line">        [builder add:RShareSDKSina];</span><br><span class="line">        [builder add:RShareSDKQQ];</span><br><span class="line">        [builder add:RShareSDKTumblr];</span><br><span class="line">        [builder add:RShareSDKFacebook];</span><br><span class="line">        [builder add:RShareSDKTwitter];</span><br><span class="line">        [builder add:RShareSDKLine];</span><br><span class="line">        [builder add:RShareSDKGooglePlus];</span><br><span class="line">        [builder add:RShareSDKInstagram];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[RShareManager shared] registerPlatforms:p onConfiguration:^(RShareSDKPlatform platform, RRegister *obj) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (platform) &#123;</span><br><span class="line">            <span class="keyword">case</span> RShareSDKPinterest:</span><br><span class="line">                [obj connectPinterestByAppID: yourAppID appSecret: <span class="literal">nil</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RShareSDKQQ:</span><br><span class="line">                [obj connectQQByAppID:yourAppID appKey: yourKey];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> RShareSDKSina:</span><br><span class="line">                [obj connectSinaWeiboByAppKey: yourKey  appSecret:yourSecret];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RShareSDKWechat:</span><br><span class="line">                [obj connectWechatByAppID: yourAppID appSecret:yourSecret];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RShareSDKTumblr:</span><br><span class="line">                [obj conncetTumblrByConsumerKey: yourKey  consumerSecret: yourSecret];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RShareSDKFacebook:</span><br><span class="line">                [obj connectFacebookByID:yourAppID secret:<span class="literal">nil</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RShareSDKTwitter:</span><br><span class="line">                [obj connectTwitterByConsumerKey:yourKey consumerSecret:yourSecret];</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> platform = <span class="type">RPlatform</span>.make &#123; (builder) <span class="keyword">in</span></span><br><span class="line">        builder.add(p: .<span class="type">Facebook</span>)</span><br><span class="line">        builder.add(p: .<span class="type">Twitter</span>)</span><br><span class="line">        builder.add(p: .<span class="type">QQ</span>)</span><br><span class="line">        builder.add(p: .<span class="type">Wechat</span>)</span><br><span class="line">        builder.add(p: .<span class="type">Instagram</span>)</span><br><span class="line">        builder.add(p: .<span class="type">Tumblr</span>)</span><br><span class="line">        builder.add(p: .<span class="type">Pinterest</span>)</span><br><span class="line">        builder.add(p: .<span class="type">Sina</span>)</span><br><span class="line">        builder.add(p: .<span class="type">GooglePlus</span>)</span><br><span class="line">        builder.add(p: .<span class="type">Line</span>)</span><br><span class="line">        builder.add(p: .<span class="type">WhatsApp</span>)       </span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RShareManager</span>.shared.registerPlatform(platform: platform) &#123; (p, obj) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> p &#123;</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Facebook</span>:</span><br><span class="line">                obj.connectFacebook(appID: yourAppID, secret: <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Pinterest</span>:</span><br><span class="line">                obj.connectPinterest(appID: yourAppID, secret: <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">QQ</span>:</span><br><span class="line">                obj.connectQQ(appID: yourAppID, key: yourKey)</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Sina</span>:</span><br><span class="line">                obj.connectSinaWeibo(appKey: yourKey, secret: yourSecret)</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Wechat</span>:</span><br><span class="line">                obj.connectWechat(appID: yourAppID, secret: yourSecret)</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Tumblr</span>:</span><br><span class="line">                obj.connectTumblr(consumerKey: yourKey, secret: yourSecret)</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Twitter</span>:</span><br><span class="line">                obj.connectTwitter(consumerKey: yourKey, secret: yourSecret)</span><br><span class="line">            <span class="keyword">default</span> : <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>构建分享模型:</strong></p><p>以 <code>RImageContent</code> 为例:</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RImageContent* content = RImageContent make:^(RImageContentBuilder *builder) &#123;</span><br><span class="line">     <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RImageContent</span>.make &#123; (builder) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>分享：</strong></p><p>以分享 <code>RImageContent</code> 为例:</p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RShareManager shared] shareImageWithContent:content channel: channel from: context completion:^(RShareSDKPlatform platform, ShareResult result, <span class="built_in">NSString</span> * _Nullable errorInfo) &#123;</span><br><span class="line">     <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RShareManager</span>.shared.shareImage(content: content, channel: channel, from: context) &#123; (platform, result, errorInfo <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>返回本应用:</strong></p><p>Objective-C:</p><p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RShareManager shared]application:app openURL:url options:options];</span><br></pre></td></tr></table></figure></p><p>Swift:</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RShareManager</span>.shared.application(app, <span class="keyword">open</span>: url, options : options)</span><br></pre></td></tr></table></figure></p><h2>源码</h2><p><a href="https://github.com/rexzx/rshare_objective_c" target="_blank" rel="noopener">Objective-C 版本源码</a>、 <a href="https://github.com/rexzx/rshare_swift" target="_blank" rel="noopener">Swift 版本源码</a>, 还在学习中, 请多指教.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为公司的项目里集成了一键分享的这个模块, 而在我设计的时候发现国内的官方文档和提供的 Sample 有混乱和容易混淆的地方, 而且除了普通的网页、图片、文字分享到各大 Social 平台以外, 对于视频、文件和其他内容的分享 Demo 在百度或者 Google 几乎搜不到
      
    
    </summary>
    
    
      <category term="share" scheme="http://yoursite.com/tags/share/"/>
    
      <category term="social" scheme="http://yoursite.com/tags/social/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
</feed>
